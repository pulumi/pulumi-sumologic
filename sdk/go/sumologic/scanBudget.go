// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a [Sumologic Scan Budget](https://help.sumologic.com/docs/manage/manage-subscription/usage-management/).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := sumologic.NewScanBudget(ctx, "budget", &sumologic.ScanBudgetArgs{
//				Name:         pulumi.String("TestBudget"),
//				Capacity:     pulumi.Int(10),
//				Unit:         pulumi.String("GB"),
//				BudgetType:   pulumi.String("ScanBudget"),
//				Window:       pulumi.String("Query"),
//				ApplicableOn: pulumi.String("PerEntity"),
//				GroupBy:      pulumi.String("User"),
//				Action:       pulumi.String("StopScan"),
//				Status:       pulumi.String("active"),
//				Scope: &sumologic.ScanBudgetScopeArgs{
//					IncludedUsers: pulumi.StringArray{
//						pulumi.String("000000000000011C"),
//					},
//					ExcludedUsers: pulumi.StringArray{},
//					IncludedRoles: pulumi.StringArray{},
//					ExcludedRoles: pulumi.StringArray{
//						pulumi.String("0000000000000196"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// Scan budgets can be imported using the budget ID, e.g.:
//
// hcl
//
// ```sh
// $ pulumi import sumologic:index/scanBudget:ScanBudget budget 00000000000123AB
// ```
//
// [1]: https://help.sumologic.com/docs/manage/manage-subscription/usage-management/
type ScanBudget struct {
	pulumi.CustomResourceState

	// Action to be taken if the budget is breached. Supported values are: `StopForeGroundScan` and `Warn`.
	Action pulumi.StringOutput `pulumi:"action"`
	// Grouping of the budget. Supported values are: `PerEntity` and `Sum`.
	ApplicableOn pulumi.StringOutput `pulumi:"applicableOn"`
	// Type of the budget. Supported values are: `ScanBudget`.
	BudgetType pulumi.StringOutput `pulumi:"budgetType"`
	// Capacity of the scan budget. Only whole numbers are supported.
	Capacity pulumi.IntOutput `pulumi:"capacity"`
	// Grouping Entity of the budget. Supported values are: `User`.
	GroupBy pulumi.StringOutput `pulumi:"groupBy"`
	// Display name of the scan budget. This must be unique across all the scan budgets.
	Name pulumi.StringOutput `pulumi:"name"`
	// Scope of the budget.
	Scope ScanBudgetScopeOutput `pulumi:"scope"`
	// Signifies the state of the budget. Supported values are: `active` and `inactive`.
	//
	// The following attributes are exported:
	Status pulumi.StringOutput `pulumi:"status"`
	// Unit of the capacity. Supported values are: `MB`, `GB` and `TB`.
	Unit pulumi.StringOutput `pulumi:"unit"`
	// Window of the budget. Supported values are: `Query`, `Daily`, `Weekly` and `Monthly`.
	Window pulumi.StringOutput `pulumi:"window"`
}

// NewScanBudget registers a new resource with the given unique name, arguments, and options.
func NewScanBudget(ctx *pulumi.Context,
	name string, args *ScanBudgetArgs, opts ...pulumi.ResourceOption) (*ScanBudget, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Action == nil {
		return nil, errors.New("invalid value for required argument 'Action'")
	}
	if args.ApplicableOn == nil {
		return nil, errors.New("invalid value for required argument 'ApplicableOn'")
	}
	if args.BudgetType == nil {
		return nil, errors.New("invalid value for required argument 'BudgetType'")
	}
	if args.Capacity == nil {
		return nil, errors.New("invalid value for required argument 'Capacity'")
	}
	if args.GroupBy == nil {
		return nil, errors.New("invalid value for required argument 'GroupBy'")
	}
	if args.Scope == nil {
		return nil, errors.New("invalid value for required argument 'Scope'")
	}
	if args.Status == nil {
		return nil, errors.New("invalid value for required argument 'Status'")
	}
	if args.Unit == nil {
		return nil, errors.New("invalid value for required argument 'Unit'")
	}
	if args.Window == nil {
		return nil, errors.New("invalid value for required argument 'Window'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource ScanBudget
	err := ctx.RegisterResource("sumologic:index/scanBudget:ScanBudget", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetScanBudget gets an existing ScanBudget resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetScanBudget(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ScanBudgetState, opts ...pulumi.ResourceOption) (*ScanBudget, error) {
	var resource ScanBudget
	err := ctx.ReadResource("sumologic:index/scanBudget:ScanBudget", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering ScanBudget resources.
type scanBudgetState struct {
	// Action to be taken if the budget is breached. Supported values are: `StopForeGroundScan` and `Warn`.
	Action *string `pulumi:"action"`
	// Grouping of the budget. Supported values are: `PerEntity` and `Sum`.
	ApplicableOn *string `pulumi:"applicableOn"`
	// Type of the budget. Supported values are: `ScanBudget`.
	BudgetType *string `pulumi:"budgetType"`
	// Capacity of the scan budget. Only whole numbers are supported.
	Capacity *int `pulumi:"capacity"`
	// Grouping Entity of the budget. Supported values are: `User`.
	GroupBy *string `pulumi:"groupBy"`
	// Display name of the scan budget. This must be unique across all the scan budgets.
	Name *string `pulumi:"name"`
	// Scope of the budget.
	Scope *ScanBudgetScope `pulumi:"scope"`
	// Signifies the state of the budget. Supported values are: `active` and `inactive`.
	//
	// The following attributes are exported:
	Status *string `pulumi:"status"`
	// Unit of the capacity. Supported values are: `MB`, `GB` and `TB`.
	Unit *string `pulumi:"unit"`
	// Window of the budget. Supported values are: `Query`, `Daily`, `Weekly` and `Monthly`.
	Window *string `pulumi:"window"`
}

type ScanBudgetState struct {
	// Action to be taken if the budget is breached. Supported values are: `StopForeGroundScan` and `Warn`.
	Action pulumi.StringPtrInput
	// Grouping of the budget. Supported values are: `PerEntity` and `Sum`.
	ApplicableOn pulumi.StringPtrInput
	// Type of the budget. Supported values are: `ScanBudget`.
	BudgetType pulumi.StringPtrInput
	// Capacity of the scan budget. Only whole numbers are supported.
	Capacity pulumi.IntPtrInput
	// Grouping Entity of the budget. Supported values are: `User`.
	GroupBy pulumi.StringPtrInput
	// Display name of the scan budget. This must be unique across all the scan budgets.
	Name pulumi.StringPtrInput
	// Scope of the budget.
	Scope ScanBudgetScopePtrInput
	// Signifies the state of the budget. Supported values are: `active` and `inactive`.
	//
	// The following attributes are exported:
	Status pulumi.StringPtrInput
	// Unit of the capacity. Supported values are: `MB`, `GB` and `TB`.
	Unit pulumi.StringPtrInput
	// Window of the budget. Supported values are: `Query`, `Daily`, `Weekly` and `Monthly`.
	Window pulumi.StringPtrInput
}

func (ScanBudgetState) ElementType() reflect.Type {
	return reflect.TypeOf((*scanBudgetState)(nil)).Elem()
}

type scanBudgetArgs struct {
	// Action to be taken if the budget is breached. Supported values are: `StopForeGroundScan` and `Warn`.
	Action string `pulumi:"action"`
	// Grouping of the budget. Supported values are: `PerEntity` and `Sum`.
	ApplicableOn string `pulumi:"applicableOn"`
	// Type of the budget. Supported values are: `ScanBudget`.
	BudgetType string `pulumi:"budgetType"`
	// Capacity of the scan budget. Only whole numbers are supported.
	Capacity int `pulumi:"capacity"`
	// Grouping Entity of the budget. Supported values are: `User`.
	GroupBy string `pulumi:"groupBy"`
	// Display name of the scan budget. This must be unique across all the scan budgets.
	Name *string `pulumi:"name"`
	// Scope of the budget.
	Scope ScanBudgetScope `pulumi:"scope"`
	// Signifies the state of the budget. Supported values are: `active` and `inactive`.
	//
	// The following attributes are exported:
	Status string `pulumi:"status"`
	// Unit of the capacity. Supported values are: `MB`, `GB` and `TB`.
	Unit string `pulumi:"unit"`
	// Window of the budget. Supported values are: `Query`, `Daily`, `Weekly` and `Monthly`.
	Window string `pulumi:"window"`
}

// The set of arguments for constructing a ScanBudget resource.
type ScanBudgetArgs struct {
	// Action to be taken if the budget is breached. Supported values are: `StopForeGroundScan` and `Warn`.
	Action pulumi.StringInput
	// Grouping of the budget. Supported values are: `PerEntity` and `Sum`.
	ApplicableOn pulumi.StringInput
	// Type of the budget. Supported values are: `ScanBudget`.
	BudgetType pulumi.StringInput
	// Capacity of the scan budget. Only whole numbers are supported.
	Capacity pulumi.IntInput
	// Grouping Entity of the budget. Supported values are: `User`.
	GroupBy pulumi.StringInput
	// Display name of the scan budget. This must be unique across all the scan budgets.
	Name pulumi.StringPtrInput
	// Scope of the budget.
	Scope ScanBudgetScopeInput
	// Signifies the state of the budget. Supported values are: `active` and `inactive`.
	//
	// The following attributes are exported:
	Status pulumi.StringInput
	// Unit of the capacity. Supported values are: `MB`, `GB` and `TB`.
	Unit pulumi.StringInput
	// Window of the budget. Supported values are: `Query`, `Daily`, `Weekly` and `Monthly`.
	Window pulumi.StringInput
}

func (ScanBudgetArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*scanBudgetArgs)(nil)).Elem()
}

type ScanBudgetInput interface {
	pulumi.Input

	ToScanBudgetOutput() ScanBudgetOutput
	ToScanBudgetOutputWithContext(ctx context.Context) ScanBudgetOutput
}

func (*ScanBudget) ElementType() reflect.Type {
	return reflect.TypeOf((**ScanBudget)(nil)).Elem()
}

func (i *ScanBudget) ToScanBudgetOutput() ScanBudgetOutput {
	return i.ToScanBudgetOutputWithContext(context.Background())
}

func (i *ScanBudget) ToScanBudgetOutputWithContext(ctx context.Context) ScanBudgetOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScanBudgetOutput)
}

// ScanBudgetArrayInput is an input type that accepts ScanBudgetArray and ScanBudgetArrayOutput values.
// You can construct a concrete instance of `ScanBudgetArrayInput` via:
//
//	ScanBudgetArray{ ScanBudgetArgs{...} }
type ScanBudgetArrayInput interface {
	pulumi.Input

	ToScanBudgetArrayOutput() ScanBudgetArrayOutput
	ToScanBudgetArrayOutputWithContext(context.Context) ScanBudgetArrayOutput
}

type ScanBudgetArray []ScanBudgetInput

func (ScanBudgetArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScanBudget)(nil)).Elem()
}

func (i ScanBudgetArray) ToScanBudgetArrayOutput() ScanBudgetArrayOutput {
	return i.ToScanBudgetArrayOutputWithContext(context.Background())
}

func (i ScanBudgetArray) ToScanBudgetArrayOutputWithContext(ctx context.Context) ScanBudgetArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScanBudgetArrayOutput)
}

// ScanBudgetMapInput is an input type that accepts ScanBudgetMap and ScanBudgetMapOutput values.
// You can construct a concrete instance of `ScanBudgetMapInput` via:
//
//	ScanBudgetMap{ "key": ScanBudgetArgs{...} }
type ScanBudgetMapInput interface {
	pulumi.Input

	ToScanBudgetMapOutput() ScanBudgetMapOutput
	ToScanBudgetMapOutputWithContext(context.Context) ScanBudgetMapOutput
}

type ScanBudgetMap map[string]ScanBudgetInput

func (ScanBudgetMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScanBudget)(nil)).Elem()
}

func (i ScanBudgetMap) ToScanBudgetMapOutput() ScanBudgetMapOutput {
	return i.ToScanBudgetMapOutputWithContext(context.Background())
}

func (i ScanBudgetMap) ToScanBudgetMapOutputWithContext(ctx context.Context) ScanBudgetMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ScanBudgetMapOutput)
}

type ScanBudgetOutput struct{ *pulumi.OutputState }

func (ScanBudgetOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**ScanBudget)(nil)).Elem()
}

func (o ScanBudgetOutput) ToScanBudgetOutput() ScanBudgetOutput {
	return o
}

func (o ScanBudgetOutput) ToScanBudgetOutputWithContext(ctx context.Context) ScanBudgetOutput {
	return o
}

// Action to be taken if the budget is breached. Supported values are: `StopForeGroundScan` and `Warn`.
func (o ScanBudgetOutput) Action() pulumi.StringOutput {
	return o.ApplyT(func(v *ScanBudget) pulumi.StringOutput { return v.Action }).(pulumi.StringOutput)
}

// Grouping of the budget. Supported values are: `PerEntity` and `Sum`.
func (o ScanBudgetOutput) ApplicableOn() pulumi.StringOutput {
	return o.ApplyT(func(v *ScanBudget) pulumi.StringOutput { return v.ApplicableOn }).(pulumi.StringOutput)
}

// Type of the budget. Supported values are: `ScanBudget`.
func (o ScanBudgetOutput) BudgetType() pulumi.StringOutput {
	return o.ApplyT(func(v *ScanBudget) pulumi.StringOutput { return v.BudgetType }).(pulumi.StringOutput)
}

// Capacity of the scan budget. Only whole numbers are supported.
func (o ScanBudgetOutput) Capacity() pulumi.IntOutput {
	return o.ApplyT(func(v *ScanBudget) pulumi.IntOutput { return v.Capacity }).(pulumi.IntOutput)
}

// Grouping Entity of the budget. Supported values are: `User`.
func (o ScanBudgetOutput) GroupBy() pulumi.StringOutput {
	return o.ApplyT(func(v *ScanBudget) pulumi.StringOutput { return v.GroupBy }).(pulumi.StringOutput)
}

// Display name of the scan budget. This must be unique across all the scan budgets.
func (o ScanBudgetOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *ScanBudget) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Scope of the budget.
func (o ScanBudgetOutput) Scope() ScanBudgetScopeOutput {
	return o.ApplyT(func(v *ScanBudget) ScanBudgetScopeOutput { return v.Scope }).(ScanBudgetScopeOutput)
}

// Signifies the state of the budget. Supported values are: `active` and `inactive`.
//
// The following attributes are exported:
func (o ScanBudgetOutput) Status() pulumi.StringOutput {
	return o.ApplyT(func(v *ScanBudget) pulumi.StringOutput { return v.Status }).(pulumi.StringOutput)
}

// Unit of the capacity. Supported values are: `MB`, `GB` and `TB`.
func (o ScanBudgetOutput) Unit() pulumi.StringOutput {
	return o.ApplyT(func(v *ScanBudget) pulumi.StringOutput { return v.Unit }).(pulumi.StringOutput)
}

// Window of the budget. Supported values are: `Query`, `Daily`, `Weekly` and `Monthly`.
func (o ScanBudgetOutput) Window() pulumi.StringOutput {
	return o.ApplyT(func(v *ScanBudget) pulumi.StringOutput { return v.Window }).(pulumi.StringOutput)
}

type ScanBudgetArrayOutput struct{ *pulumi.OutputState }

func (ScanBudgetArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*ScanBudget)(nil)).Elem()
}

func (o ScanBudgetArrayOutput) ToScanBudgetArrayOutput() ScanBudgetArrayOutput {
	return o
}

func (o ScanBudgetArrayOutput) ToScanBudgetArrayOutputWithContext(ctx context.Context) ScanBudgetArrayOutput {
	return o
}

func (o ScanBudgetArrayOutput) Index(i pulumi.IntInput) ScanBudgetOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *ScanBudget {
		return vs[0].([]*ScanBudget)[vs[1].(int)]
	}).(ScanBudgetOutput)
}

type ScanBudgetMapOutput struct{ *pulumi.OutputState }

func (ScanBudgetMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*ScanBudget)(nil)).Elem()
}

func (o ScanBudgetMapOutput) ToScanBudgetMapOutput() ScanBudgetMapOutput {
	return o
}

func (o ScanBudgetMapOutput) ToScanBudgetMapOutputWithContext(ctx context.Context) ScanBudgetMapOutput {
	return o
}

func (o ScanBudgetMapOutput) MapIndex(k pulumi.StringInput) ScanBudgetOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *ScanBudget {
		return vs[0].(map[string]*ScanBudget)[vs[1].(string)]
	}).(ScanBudgetOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ScanBudgetInput)(nil)).Elem(), &ScanBudget{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScanBudgetArrayInput)(nil)).Elem(), ScanBudgetArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ScanBudgetMapInput)(nil)).Elem(), ScanBudgetMap{})
	pulumi.RegisterOutputType(ScanBudgetOutput{})
	pulumi.RegisterOutputType(ScanBudgetArrayOutput{})
	pulumi.RegisterOutputType(ScanBudgetMapOutput{})
}
