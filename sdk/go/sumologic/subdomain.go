// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a [Sumologic Subdomain](https://help.sumologic.com/Manage/01Account_Usage/05Manage_Organization#change-account-subdomain).
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		_, err := sumologic.NewSubdomain(ctx, "exampleSubdomain", &sumologic.SubdomainArgs{
// 			Subdomain: pulumi.String("my-company"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Argument reference
//
// The following arguments are supported:
//
// - `subdomain` - (Required) The subdomain.
//
// ## Attributes reference
//
// The following attributes are exported:
//
// - `id` - Unique identifier for the subdomain.
//
// [1]: https://help.sumologic.com/Manage/01Account_Usage/05Manage_Organization#change-account-subdomain
type Subdomain struct {
	pulumi.CustomResourceState

	Subdomain pulumi.StringOutput `pulumi:"subdomain"`
}

// NewSubdomain registers a new resource with the given unique name, arguments, and options.
func NewSubdomain(ctx *pulumi.Context,
	name string, args *SubdomainArgs, opts ...pulumi.ResourceOption) (*Subdomain, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Subdomain == nil {
		return nil, errors.New("invalid value for required argument 'Subdomain'")
	}
	var resource Subdomain
	err := ctx.RegisterResource("sumologic:index/subdomain:Subdomain", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSubdomain gets an existing Subdomain resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSubdomain(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SubdomainState, opts ...pulumi.ResourceOption) (*Subdomain, error) {
	var resource Subdomain
	err := ctx.ReadResource("sumologic:index/subdomain:Subdomain", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Subdomain resources.
type subdomainState struct {
	Subdomain *string `pulumi:"subdomain"`
}

type SubdomainState struct {
	Subdomain pulumi.StringPtrInput
}

func (SubdomainState) ElementType() reflect.Type {
	return reflect.TypeOf((*subdomainState)(nil)).Elem()
}

type subdomainArgs struct {
	Subdomain string `pulumi:"subdomain"`
}

// The set of arguments for constructing a Subdomain resource.
type SubdomainArgs struct {
	Subdomain pulumi.StringInput
}

func (SubdomainArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*subdomainArgs)(nil)).Elem()
}

type SubdomainInput interface {
	pulumi.Input

	ToSubdomainOutput() SubdomainOutput
	ToSubdomainOutputWithContext(ctx context.Context) SubdomainOutput
}

func (*Subdomain) ElementType() reflect.Type {
	return reflect.TypeOf((*Subdomain)(nil))
}

func (i *Subdomain) ToSubdomainOutput() SubdomainOutput {
	return i.ToSubdomainOutputWithContext(context.Background())
}

func (i *Subdomain) ToSubdomainOutputWithContext(ctx context.Context) SubdomainOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubdomainOutput)
}

func (i *Subdomain) ToSubdomainPtrOutput() SubdomainPtrOutput {
	return i.ToSubdomainPtrOutputWithContext(context.Background())
}

func (i *Subdomain) ToSubdomainPtrOutputWithContext(ctx context.Context) SubdomainPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubdomainPtrOutput)
}

type SubdomainPtrInput interface {
	pulumi.Input

	ToSubdomainPtrOutput() SubdomainPtrOutput
	ToSubdomainPtrOutputWithContext(ctx context.Context) SubdomainPtrOutput
}

type subdomainPtrType SubdomainArgs

func (*subdomainPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Subdomain)(nil))
}

func (i *subdomainPtrType) ToSubdomainPtrOutput() SubdomainPtrOutput {
	return i.ToSubdomainPtrOutputWithContext(context.Background())
}

func (i *subdomainPtrType) ToSubdomainPtrOutputWithContext(ctx context.Context) SubdomainPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubdomainPtrOutput)
}

// SubdomainArrayInput is an input type that accepts SubdomainArray and SubdomainArrayOutput values.
// You can construct a concrete instance of `SubdomainArrayInput` via:
//
//          SubdomainArray{ SubdomainArgs{...} }
type SubdomainArrayInput interface {
	pulumi.Input

	ToSubdomainArrayOutput() SubdomainArrayOutput
	ToSubdomainArrayOutputWithContext(context.Context) SubdomainArrayOutput
}

type SubdomainArray []SubdomainInput

func (SubdomainArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Subdomain)(nil)).Elem()
}

func (i SubdomainArray) ToSubdomainArrayOutput() SubdomainArrayOutput {
	return i.ToSubdomainArrayOutputWithContext(context.Background())
}

func (i SubdomainArray) ToSubdomainArrayOutputWithContext(ctx context.Context) SubdomainArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubdomainArrayOutput)
}

// SubdomainMapInput is an input type that accepts SubdomainMap and SubdomainMapOutput values.
// You can construct a concrete instance of `SubdomainMapInput` via:
//
//          SubdomainMap{ "key": SubdomainArgs{...} }
type SubdomainMapInput interface {
	pulumi.Input

	ToSubdomainMapOutput() SubdomainMapOutput
	ToSubdomainMapOutputWithContext(context.Context) SubdomainMapOutput
}

type SubdomainMap map[string]SubdomainInput

func (SubdomainMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Subdomain)(nil)).Elem()
}

func (i SubdomainMap) ToSubdomainMapOutput() SubdomainMapOutput {
	return i.ToSubdomainMapOutputWithContext(context.Background())
}

func (i SubdomainMap) ToSubdomainMapOutputWithContext(ctx context.Context) SubdomainMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SubdomainMapOutput)
}

type SubdomainOutput struct{ *pulumi.OutputState }

func (SubdomainOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Subdomain)(nil))
}

func (o SubdomainOutput) ToSubdomainOutput() SubdomainOutput {
	return o
}

func (o SubdomainOutput) ToSubdomainOutputWithContext(ctx context.Context) SubdomainOutput {
	return o
}

func (o SubdomainOutput) ToSubdomainPtrOutput() SubdomainPtrOutput {
	return o.ToSubdomainPtrOutputWithContext(context.Background())
}

func (o SubdomainOutput) ToSubdomainPtrOutputWithContext(ctx context.Context) SubdomainPtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v Subdomain) *Subdomain {
		return &v
	}).(SubdomainPtrOutput)
}

type SubdomainPtrOutput struct{ *pulumi.OutputState }

func (SubdomainPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Subdomain)(nil))
}

func (o SubdomainPtrOutput) ToSubdomainPtrOutput() SubdomainPtrOutput {
	return o
}

func (o SubdomainPtrOutput) ToSubdomainPtrOutputWithContext(ctx context.Context) SubdomainPtrOutput {
	return o
}

func (o SubdomainPtrOutput) Elem() SubdomainOutput {
	return o.ApplyT(func(v *Subdomain) Subdomain {
		if v != nil {
			return *v
		}
		var ret Subdomain
		return ret
	}).(SubdomainOutput)
}

type SubdomainArrayOutput struct{ *pulumi.OutputState }

func (SubdomainArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Subdomain)(nil))
}

func (o SubdomainArrayOutput) ToSubdomainArrayOutput() SubdomainArrayOutput {
	return o
}

func (o SubdomainArrayOutput) ToSubdomainArrayOutputWithContext(ctx context.Context) SubdomainArrayOutput {
	return o
}

func (o SubdomainArrayOutput) Index(i pulumi.IntInput) SubdomainOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Subdomain {
		return vs[0].([]Subdomain)[vs[1].(int)]
	}).(SubdomainOutput)
}

type SubdomainMapOutput struct{ *pulumi.OutputState }

func (SubdomainMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Subdomain)(nil))
}

func (o SubdomainMapOutput) ToSubdomainMapOutput() SubdomainMapOutput {
	return o
}

func (o SubdomainMapOutput) ToSubdomainMapOutputWithContext(ctx context.Context) SubdomainMapOutput {
	return o
}

func (o SubdomainMapOutput) MapIndex(k pulumi.StringInput) SubdomainOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Subdomain {
		return vs[0].(map[string]Subdomain)[vs[1].(string)]
	}).(SubdomainOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SubdomainInput)(nil)).Elem(), &Subdomain{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubdomainPtrInput)(nil)).Elem(), &Subdomain{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubdomainArrayInput)(nil)).Elem(), SubdomainArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SubdomainMapInput)(nil)).Elem(), SubdomainMap{})
	pulumi.RegisterOutputType(SubdomainOutput{})
	pulumi.RegisterOutputType(SubdomainPtrOutput{})
	pulumi.RegisterOutputType(SubdomainArrayOutput{})
	pulumi.RegisterOutputType(SubdomainMapOutput{})
}
