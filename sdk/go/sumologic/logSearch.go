// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Sumologic Log Search.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			personalFolder, err := sumologic.GetPersonalFolder(ctx, &sumologic.GetPersonalFolderArgs{}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = sumologic.NewLogSearch(ctx, "example_log_search", &sumologic.LogSearchArgs{
//				Name:        pulumi.String("Demo Search"),
//				Description: pulumi.String("Demo search description"),
//				ParentId:    pulumi.String(personalFolder.Id),
//				QueryString: pulumi.String(`        _sourceCategory=api
//	        | parse "parameter1=*," as parameter1
//	        | parse "parameter2=*," as parameter2
//	        | where parameter1 matches {{param1}}
//	        | where parameter2 matches {{param2}}
//	        | count by _sourceHost
//
// `),
//
//				ParsingMode:      pulumi.String("AutoParse"),
//				RunByReceiptTime: pulumi.Bool(true),
//				TimeRange: &sumologic.LogSearchTimeRangeArgs{
//					BeginBoundedTimeRange: &sumologic.LogSearchTimeRangeBeginBoundedTimeRangeArgs{
//						From: &sumologic.LogSearchTimeRangeBeginBoundedTimeRangeFromArgs{
//							RelativeTimeRange: &sumologic.LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs{
//								RelativeTime: pulumi.String("-30m"),
//							},
//						},
//					},
//				},
//				QueryParameters: sumologic.LogSearchQueryParameterArray{
//					&sumologic.LogSearchQueryParameterArgs{
//						Name:        pulumi.String("param1"),
//						Description: pulumi.String("Description for param1"),
//						DataType:    pulumi.String("STRING"),
//						Value:       pulumi.String("*"),
//					},
//					&sumologic.LogSearchQueryParameterArgs{
//						Name:        pulumi.String("param2"),
//						Description: pulumi.String("Description for param2"),
//						DataType:    pulumi.String("STRING"),
//						Value:       pulumi.String("*"),
//					},
//				},
//				Schedule: &sumologic.LogSearchScheduleArgs{
//					CronExpression:  pulumi.String("0 0 * * * ? *"),
//					MuteErrorEmails: pulumi.Bool(false),
//					Notification: &sumologic.LogSearchScheduleNotificationArgs{
//						EmailSearchNotification: &sumologic.LogSearchScheduleNotificationEmailSearchNotificationArgs{
//							IncludeCsvAttachment: pulumi.Bool(false),
//							IncludeHistogram:     pulumi.Bool(false),
//							IncludeQuery:         pulumi.Bool(true),
//							IncludeResultSet:     pulumi.Bool(true),
//							SubjectTemplate:      pulumi.String("Search Alert: {{TriggerCondition}} found for {{SearchName}}"),
//							ToLists: pulumi.StringArray{
//								pulumi.String("will@acme.com"),
//							},
//						},
//					},
//					ParseableTimeRange: &sumologic.LogSearchScheduleParseableTimeRangeArgs{
//						BeginBoundedTimeRange: &sumologic.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgs{
//							From: &sumologic.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgs{
//								RelativeTimeRange: &sumologic.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs{
//									RelativeTime: pulumi.String("-15m"),
//								},
//							},
//						},
//					},
//					ScheduleType: pulumi.String("1Week"),
//					Threshold: &sumologic.LogSearchScheduleThresholdArgs{
//						Count:         pulumi.Int(10),
//						Operator:      pulumi.String("gt"),
//						ThresholdType: pulumi.String("group"),
//					},
//					TimeZone: pulumi.String("America/Los_Angeles"),
//					Parameters: sumologic.LogSearchScheduleParameterArray{
//						&sumologic.LogSearchScheduleParameterArgs{
//							Name:  pulumi.String("param1"),
//							Value: pulumi.String("*"),
//						},
//						&sumologic.LogSearchScheduleParameterArgs{
//							Name:  pulumi.String("param2"),
//							Value: pulumi.String("*"),
//						},
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Attributes reference
//
// In addition to all arguments above, the following attributes are exported:
//
// - `id` - The ID of the log search.
//
// ## Import
//
// A log search can be imported using it's identifier, e.g.:
//
// hcl
//
// ```sh
// $ pulumi import sumologic:index/logSearch:LogSearch example_search 0000000007FFD79D
// ```
type LogSearch struct {
	pulumi.CustomResourceState

	// Description of the search.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// Name of the search.
	Name pulumi.StringOutput `pulumi:"name"`
	// The identifier of the folder to create the log search in.
	ParentId pulumi.StringOutput `pulumi:"parentId"`
	// Define the parsing mode to scan the JSON format log messages. Possible values are:
	// `AutoParse` and  `Manual`. Default value is `Manual`.
	//
	// In `AutoParse` mode, the system automatically figures out fields to parse based on the search query. While in
	// the `Manual` mode, no fields are parsed out automatically. For more information see
	// [Dynamic Parsing](https://help.sumologic.com/?cid=0011).
	ParsingMode pulumi.StringPtrOutput `pulumi:"parsingMode"`
	// Up to 10 `queryParameter` blocks can be added one for each parameter in the `queryString`.
	// See query parameter schema.
	QueryParameters LogSearchQueryParameterArrayOutput `pulumi:"queryParameters"`
	// Log query to perform.
	QueryString pulumi.StringOutput `pulumi:"queryString"`
	// This has the value `true` if the search is to be run by receipt time and
	// `false` if it is to be run by message time. Default value is `false`.
	RunByReceiptTime pulumi.BoolPtrOutput `pulumi:"runByReceiptTime"`
	// Schedule of the log search. See schedule schema
	Schedule LogSearchSchedulePtrOutput `pulumi:"schedule"`
	// Time range of the log search. See time range schema
	TimeRange LogSearchTimeRangeOutput `pulumi:"timeRange"`
}

// NewLogSearch registers a new resource with the given unique name, arguments, and options.
func NewLogSearch(ctx *pulumi.Context,
	name string, args *LogSearchArgs, opts ...pulumi.ResourceOption) (*LogSearch, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ParentId == nil {
		return nil, errors.New("invalid value for required argument 'ParentId'")
	}
	if args.QueryString == nil {
		return nil, errors.New("invalid value for required argument 'QueryString'")
	}
	if args.TimeRange == nil {
		return nil, errors.New("invalid value for required argument 'TimeRange'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LogSearch
	err := ctx.RegisterResource("sumologic:index/logSearch:LogSearch", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLogSearch gets an existing LogSearch resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLogSearch(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LogSearchState, opts ...pulumi.ResourceOption) (*LogSearch, error) {
	var resource LogSearch
	err := ctx.ReadResource("sumologic:index/logSearch:LogSearch", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LogSearch resources.
type logSearchState struct {
	// Description of the search.
	Description *string `pulumi:"description"`
	// Name of the search.
	Name *string `pulumi:"name"`
	// The identifier of the folder to create the log search in.
	ParentId *string `pulumi:"parentId"`
	// Define the parsing mode to scan the JSON format log messages. Possible values are:
	// `AutoParse` and  `Manual`. Default value is `Manual`.
	//
	// In `AutoParse` mode, the system automatically figures out fields to parse based on the search query. While in
	// the `Manual` mode, no fields are parsed out automatically. For more information see
	// [Dynamic Parsing](https://help.sumologic.com/?cid=0011).
	ParsingMode *string `pulumi:"parsingMode"`
	// Up to 10 `queryParameter` blocks can be added one for each parameter in the `queryString`.
	// See query parameter schema.
	QueryParameters []LogSearchQueryParameter `pulumi:"queryParameters"`
	// Log query to perform.
	QueryString *string `pulumi:"queryString"`
	// This has the value `true` if the search is to be run by receipt time and
	// `false` if it is to be run by message time. Default value is `false`.
	RunByReceiptTime *bool `pulumi:"runByReceiptTime"`
	// Schedule of the log search. See schedule schema
	Schedule *LogSearchSchedule `pulumi:"schedule"`
	// Time range of the log search. See time range schema
	TimeRange *LogSearchTimeRange `pulumi:"timeRange"`
}

type LogSearchState struct {
	// Description of the search.
	Description pulumi.StringPtrInput
	// Name of the search.
	Name pulumi.StringPtrInput
	// The identifier of the folder to create the log search in.
	ParentId pulumi.StringPtrInput
	// Define the parsing mode to scan the JSON format log messages. Possible values are:
	// `AutoParse` and  `Manual`. Default value is `Manual`.
	//
	// In `AutoParse` mode, the system automatically figures out fields to parse based on the search query. While in
	// the `Manual` mode, no fields are parsed out automatically. For more information see
	// [Dynamic Parsing](https://help.sumologic.com/?cid=0011).
	ParsingMode pulumi.StringPtrInput
	// Up to 10 `queryParameter` blocks can be added one for each parameter in the `queryString`.
	// See query parameter schema.
	QueryParameters LogSearchQueryParameterArrayInput
	// Log query to perform.
	QueryString pulumi.StringPtrInput
	// This has the value `true` if the search is to be run by receipt time and
	// `false` if it is to be run by message time. Default value is `false`.
	RunByReceiptTime pulumi.BoolPtrInput
	// Schedule of the log search. See schedule schema
	Schedule LogSearchSchedulePtrInput
	// Time range of the log search. See time range schema
	TimeRange LogSearchTimeRangePtrInput
}

func (LogSearchState) ElementType() reflect.Type {
	return reflect.TypeOf((*logSearchState)(nil)).Elem()
}

type logSearchArgs struct {
	// Description of the search.
	Description *string `pulumi:"description"`
	// Name of the search.
	Name *string `pulumi:"name"`
	// The identifier of the folder to create the log search in.
	ParentId string `pulumi:"parentId"`
	// Define the parsing mode to scan the JSON format log messages. Possible values are:
	// `AutoParse` and  `Manual`. Default value is `Manual`.
	//
	// In `AutoParse` mode, the system automatically figures out fields to parse based on the search query. While in
	// the `Manual` mode, no fields are parsed out automatically. For more information see
	// [Dynamic Parsing](https://help.sumologic.com/?cid=0011).
	ParsingMode *string `pulumi:"parsingMode"`
	// Up to 10 `queryParameter` blocks can be added one for each parameter in the `queryString`.
	// See query parameter schema.
	QueryParameters []LogSearchQueryParameter `pulumi:"queryParameters"`
	// Log query to perform.
	QueryString string `pulumi:"queryString"`
	// This has the value `true` if the search is to be run by receipt time and
	// `false` if it is to be run by message time. Default value is `false`.
	RunByReceiptTime *bool `pulumi:"runByReceiptTime"`
	// Schedule of the log search. See schedule schema
	Schedule *LogSearchSchedule `pulumi:"schedule"`
	// Time range of the log search. See time range schema
	TimeRange LogSearchTimeRange `pulumi:"timeRange"`
}

// The set of arguments for constructing a LogSearch resource.
type LogSearchArgs struct {
	// Description of the search.
	Description pulumi.StringPtrInput
	// Name of the search.
	Name pulumi.StringPtrInput
	// The identifier of the folder to create the log search in.
	ParentId pulumi.StringInput
	// Define the parsing mode to scan the JSON format log messages. Possible values are:
	// `AutoParse` and  `Manual`. Default value is `Manual`.
	//
	// In `AutoParse` mode, the system automatically figures out fields to parse based on the search query. While in
	// the `Manual` mode, no fields are parsed out automatically. For more information see
	// [Dynamic Parsing](https://help.sumologic.com/?cid=0011).
	ParsingMode pulumi.StringPtrInput
	// Up to 10 `queryParameter` blocks can be added one for each parameter in the `queryString`.
	// See query parameter schema.
	QueryParameters LogSearchQueryParameterArrayInput
	// Log query to perform.
	QueryString pulumi.StringInput
	// This has the value `true` if the search is to be run by receipt time and
	// `false` if it is to be run by message time. Default value is `false`.
	RunByReceiptTime pulumi.BoolPtrInput
	// Schedule of the log search. See schedule schema
	Schedule LogSearchSchedulePtrInput
	// Time range of the log search. See time range schema
	TimeRange LogSearchTimeRangeInput
}

func (LogSearchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*logSearchArgs)(nil)).Elem()
}

type LogSearchInput interface {
	pulumi.Input

	ToLogSearchOutput() LogSearchOutput
	ToLogSearchOutputWithContext(ctx context.Context) LogSearchOutput
}

func (*LogSearch) ElementType() reflect.Type {
	return reflect.TypeOf((**LogSearch)(nil)).Elem()
}

func (i *LogSearch) ToLogSearchOutput() LogSearchOutput {
	return i.ToLogSearchOutputWithContext(context.Background())
}

func (i *LogSearch) ToLogSearchOutputWithContext(ctx context.Context) LogSearchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogSearchOutput)
}

// LogSearchArrayInput is an input type that accepts LogSearchArray and LogSearchArrayOutput values.
// You can construct a concrete instance of `LogSearchArrayInput` via:
//
//	LogSearchArray{ LogSearchArgs{...} }
type LogSearchArrayInput interface {
	pulumi.Input

	ToLogSearchArrayOutput() LogSearchArrayOutput
	ToLogSearchArrayOutputWithContext(context.Context) LogSearchArrayOutput
}

type LogSearchArray []LogSearchInput

func (LogSearchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogSearch)(nil)).Elem()
}

func (i LogSearchArray) ToLogSearchArrayOutput() LogSearchArrayOutput {
	return i.ToLogSearchArrayOutputWithContext(context.Background())
}

func (i LogSearchArray) ToLogSearchArrayOutputWithContext(ctx context.Context) LogSearchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogSearchArrayOutput)
}

// LogSearchMapInput is an input type that accepts LogSearchMap and LogSearchMapOutput values.
// You can construct a concrete instance of `LogSearchMapInput` via:
//
//	LogSearchMap{ "key": LogSearchArgs{...} }
type LogSearchMapInput interface {
	pulumi.Input

	ToLogSearchMapOutput() LogSearchMapOutput
	ToLogSearchMapOutputWithContext(context.Context) LogSearchMapOutput
}

type LogSearchMap map[string]LogSearchInput

func (LogSearchMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogSearch)(nil)).Elem()
}

func (i LogSearchMap) ToLogSearchMapOutput() LogSearchMapOutput {
	return i.ToLogSearchMapOutputWithContext(context.Background())
}

func (i LogSearchMap) ToLogSearchMapOutputWithContext(ctx context.Context) LogSearchMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LogSearchMapOutput)
}

type LogSearchOutput struct{ *pulumi.OutputState }

func (LogSearchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LogSearch)(nil)).Elem()
}

func (o LogSearchOutput) ToLogSearchOutput() LogSearchOutput {
	return o
}

func (o LogSearchOutput) ToLogSearchOutputWithContext(ctx context.Context) LogSearchOutput {
	return o
}

// Description of the search.
func (o LogSearchOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogSearch) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// Name of the search.
func (o LogSearchOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *LogSearch) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The identifier of the folder to create the log search in.
func (o LogSearchOutput) ParentId() pulumi.StringOutput {
	return o.ApplyT(func(v *LogSearch) pulumi.StringOutput { return v.ParentId }).(pulumi.StringOutput)
}

// Define the parsing mode to scan the JSON format log messages. Possible values are:
// `AutoParse` and  `Manual`. Default value is `Manual`.
//
// In `AutoParse` mode, the system automatically figures out fields to parse based on the search query. While in
// the `Manual` mode, no fields are parsed out automatically. For more information see
// [Dynamic Parsing](https://help.sumologic.com/?cid=0011).
func (o LogSearchOutput) ParsingMode() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *LogSearch) pulumi.StringPtrOutput { return v.ParsingMode }).(pulumi.StringPtrOutput)
}

// Up to 10 `queryParameter` blocks can be added one for each parameter in the `queryString`.
// See query parameter schema.
func (o LogSearchOutput) QueryParameters() LogSearchQueryParameterArrayOutput {
	return o.ApplyT(func(v *LogSearch) LogSearchQueryParameterArrayOutput { return v.QueryParameters }).(LogSearchQueryParameterArrayOutput)
}

// Log query to perform.
func (o LogSearchOutput) QueryString() pulumi.StringOutput {
	return o.ApplyT(func(v *LogSearch) pulumi.StringOutput { return v.QueryString }).(pulumi.StringOutput)
}

// This has the value `true` if the search is to be run by receipt time and
// `false` if it is to be run by message time. Default value is `false`.
func (o LogSearchOutput) RunByReceiptTime() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *LogSearch) pulumi.BoolPtrOutput { return v.RunByReceiptTime }).(pulumi.BoolPtrOutput)
}

// Schedule of the log search. See schedule schema
func (o LogSearchOutput) Schedule() LogSearchSchedulePtrOutput {
	return o.ApplyT(func(v *LogSearch) LogSearchSchedulePtrOutput { return v.Schedule }).(LogSearchSchedulePtrOutput)
}

// Time range of the log search. See time range schema
func (o LogSearchOutput) TimeRange() LogSearchTimeRangeOutput {
	return o.ApplyT(func(v *LogSearch) LogSearchTimeRangeOutput { return v.TimeRange }).(LogSearchTimeRangeOutput)
}

type LogSearchArrayOutput struct{ *pulumi.OutputState }

func (LogSearchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LogSearch)(nil)).Elem()
}

func (o LogSearchArrayOutput) ToLogSearchArrayOutput() LogSearchArrayOutput {
	return o
}

func (o LogSearchArrayOutput) ToLogSearchArrayOutputWithContext(ctx context.Context) LogSearchArrayOutput {
	return o
}

func (o LogSearchArrayOutput) Index(i pulumi.IntInput) LogSearchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LogSearch {
		return vs[0].([]*LogSearch)[vs[1].(int)]
	}).(LogSearchOutput)
}

type LogSearchMapOutput struct{ *pulumi.OutputState }

func (LogSearchMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LogSearch)(nil)).Elem()
}

func (o LogSearchMapOutput) ToLogSearchMapOutput() LogSearchMapOutput {
	return o
}

func (o LogSearchMapOutput) ToLogSearchMapOutputWithContext(ctx context.Context) LogSearchMapOutput {
	return o
}

func (o LogSearchMapOutput) MapIndex(k pulumi.StringInput) LogSearchOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LogSearch {
		return vs[0].(map[string]*LogSearch)[vs[1].(string)]
	}).(LogSearchOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LogSearchInput)(nil)).Elem(), &LogSearch{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogSearchArrayInput)(nil)).Elem(), LogSearchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LogSearchMapInput)(nil)).Elem(), LogSearchMap{})
	pulumi.RegisterOutputType(LogSearchOutput{})
	pulumi.RegisterOutputType(LogSearchArrayOutput{})
	pulumi.RegisterOutputType(LogSearchMapOutput{})
}
