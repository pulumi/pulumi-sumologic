// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"encoding/json"
//
//	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			personalFolder, err := sumologic.GetPersonalFolder(ctx, nil, nil)
//			if err != nil {
//				return err
//			}
//			tmpJSON0, err := json.Marshal(map[string]interface{}{
//				"type": "SavedSearchWithScheduleSyncDefinition",
//				"name": "test-333",
//				"search": map[string]interface{}{
//					"queryText":        "\"warn\"",
//					"defaultTimeRange": "-15m",
//					"byReceiptTime":    false,
//					"viewName":         "",
//					"viewStartTime":    "1970-01-01T00:00:00Z",
//					"queryParameters":  []interface{}{},
//					"parsingMode":      "Manual",
//				},
//				"searchSchedule": map[string]interface{}{
//					"cronExpression":       "0 0 * * * ? *",
//					"displayableTimeRange": "-10m",
//					"parseableTimeRange": map[string]interface{}{
//						"type": "BeginBoundedTimeRange",
//						"from": map[string]interface{}{
//							"type":         "RelativeTimeRangeBoundary",
//							"relativeTime": "-50m",
//						},
//						"to": nil,
//					},
//					"timeZone": "America/Los_Angeles",
//					"threshold": map[string]interface{}{
//						"thresholdType": "message",
//						"operator":      "gt",
//						"count":         0,
//					},
//					"notification": map[string]interface{}{
//						"taskType": "EmailSearchNotificationSyncDefinition",
//						"toList": []string{
//							"ops@acme.org",
//						},
//						"subjectTemplate":      "Search Results: {{Name}}",
//						"includeQuery":         true,
//						"includeResultSet":     true,
//						"includeHistogram":     false,
//						"includeCsvAttachment": false,
//					},
//					"scheduleType":    "1Hour",
//					"muteErrorEmails": false,
//					"parameters":      []interface{}{},
//				},
//				"description": "Runs every hour with timerange of 15m and sends email notifications",
//			})
//			if err != nil {
//				return err
//			}
//			json0 := string(tmpJSON0)
//			_, err = sumologic.NewContent(ctx, "test", &sumologic.ContentArgs{
//				ParentId: *pulumi.String(personalFolder.Id),
//				Config:   pulumi.String(json0),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
// ## Attributes reference
//
// The following attributes are exported:
//
// - `id` - Unique identifier for the content item.
//
// [1]: https://help.sumologic.com/APIs/Content-Management-API
type Content struct {
	pulumi.CustomResourceState

	// JSON block for the content to import. NOTE: Updating the name will create a new object and leave a untracked content item (delete the existing content item and create a new content item if you want to update the name).
	Config pulumi.StringOutput `pulumi:"config"`
	// The identifier of the folder to import into. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this provider. The identifier needs to be in hexadecimal format.
	ParentId pulumi.StringOutput `pulumi:"parentId"`
}

// NewContent registers a new resource with the given unique name, arguments, and options.
func NewContent(ctx *pulumi.Context,
	name string, args *ContentArgs, opts ...pulumi.ResourceOption) (*Content, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Config == nil {
		return nil, errors.New("invalid value for required argument 'Config'")
	}
	if args.ParentId == nil {
		return nil, errors.New("invalid value for required argument 'ParentId'")
	}
	var resource Content
	err := ctx.RegisterResource("sumologic:index/content:Content", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetContent gets an existing Content resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetContent(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ContentState, opts ...pulumi.ResourceOption) (*Content, error) {
	var resource Content
	err := ctx.ReadResource("sumologic:index/content:Content", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Content resources.
type contentState struct {
	// JSON block for the content to import. NOTE: Updating the name will create a new object and leave a untracked content item (delete the existing content item and create a new content item if you want to update the name).
	Config *string `pulumi:"config"`
	// The identifier of the folder to import into. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this provider. The identifier needs to be in hexadecimal format.
	ParentId *string `pulumi:"parentId"`
}

type ContentState struct {
	// JSON block for the content to import. NOTE: Updating the name will create a new object and leave a untracked content item (delete the existing content item and create a new content item if you want to update the name).
	Config pulumi.StringPtrInput
	// The identifier of the folder to import into. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this provider. The identifier needs to be in hexadecimal format.
	ParentId pulumi.StringPtrInput
}

func (ContentState) ElementType() reflect.Type {
	return reflect.TypeOf((*contentState)(nil)).Elem()
}

type contentArgs struct {
	// JSON block for the content to import. NOTE: Updating the name will create a new object and leave a untracked content item (delete the existing content item and create a new content item if you want to update the name).
	Config string `pulumi:"config"`
	// The identifier of the folder to import into. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this provider. The identifier needs to be in hexadecimal format.
	ParentId string `pulumi:"parentId"`
}

// The set of arguments for constructing a Content resource.
type ContentArgs struct {
	// JSON block for the content to import. NOTE: Updating the name will create a new object and leave a untracked content item (delete the existing content item and create a new content item if you want to update the name).
	Config pulumi.StringInput
	// The identifier of the folder to import into. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this provider. The identifier needs to be in hexadecimal format.
	ParentId pulumi.StringInput
}

func (ContentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*contentArgs)(nil)).Elem()
}

type ContentInput interface {
	pulumi.Input

	ToContentOutput() ContentOutput
	ToContentOutputWithContext(ctx context.Context) ContentOutput
}

func (*Content) ElementType() reflect.Type {
	return reflect.TypeOf((**Content)(nil)).Elem()
}

func (i *Content) ToContentOutput() ContentOutput {
	return i.ToContentOutputWithContext(context.Background())
}

func (i *Content) ToContentOutputWithContext(ctx context.Context) ContentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentOutput)
}

// ContentArrayInput is an input type that accepts ContentArray and ContentArrayOutput values.
// You can construct a concrete instance of `ContentArrayInput` via:
//
//	ContentArray{ ContentArgs{...} }
type ContentArrayInput interface {
	pulumi.Input

	ToContentArrayOutput() ContentArrayOutput
	ToContentArrayOutputWithContext(context.Context) ContentArrayOutput
}

type ContentArray []ContentInput

func (ContentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Content)(nil)).Elem()
}

func (i ContentArray) ToContentArrayOutput() ContentArrayOutput {
	return i.ToContentArrayOutputWithContext(context.Background())
}

func (i ContentArray) ToContentArrayOutputWithContext(ctx context.Context) ContentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentArrayOutput)
}

// ContentMapInput is an input type that accepts ContentMap and ContentMapOutput values.
// You can construct a concrete instance of `ContentMapInput` via:
//
//	ContentMap{ "key": ContentArgs{...} }
type ContentMapInput interface {
	pulumi.Input

	ToContentMapOutput() ContentMapOutput
	ToContentMapOutputWithContext(context.Context) ContentMapOutput
}

type ContentMap map[string]ContentInput

func (ContentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Content)(nil)).Elem()
}

func (i ContentMap) ToContentMapOutput() ContentMapOutput {
	return i.ToContentMapOutputWithContext(context.Background())
}

func (i ContentMap) ToContentMapOutputWithContext(ctx context.Context) ContentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMapOutput)
}

type ContentOutput struct{ *pulumi.OutputState }

func (ContentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Content)(nil)).Elem()
}

func (o ContentOutput) ToContentOutput() ContentOutput {
	return o
}

func (o ContentOutput) ToContentOutputWithContext(ctx context.Context) ContentOutput {
	return o
}

// JSON block for the content to import. NOTE: Updating the name will create a new object and leave a untracked content item (delete the existing content item and create a new content item if you want to update the name).
func (o ContentOutput) Config() pulumi.StringOutput {
	return o.ApplyT(func(v *Content) pulumi.StringOutput { return v.Config }).(pulumi.StringOutput)
}

// The identifier of the folder to import into. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this provider. The identifier needs to be in hexadecimal format.
func (o ContentOutput) ParentId() pulumi.StringOutput {
	return o.ApplyT(func(v *Content) pulumi.StringOutput { return v.ParentId }).(pulumi.StringOutput)
}

type ContentArrayOutput struct{ *pulumi.OutputState }

func (ContentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Content)(nil)).Elem()
}

func (o ContentArrayOutput) ToContentArrayOutput() ContentArrayOutput {
	return o
}

func (o ContentArrayOutput) ToContentArrayOutputWithContext(ctx context.Context) ContentArrayOutput {
	return o
}

func (o ContentArrayOutput) Index(i pulumi.IntInput) ContentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Content {
		return vs[0].([]*Content)[vs[1].(int)]
	}).(ContentOutput)
}

type ContentMapOutput struct{ *pulumi.OutputState }

func (ContentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Content)(nil)).Elem()
}

func (o ContentMapOutput) ToContentMapOutput() ContentMapOutput {
	return o
}

func (o ContentMapOutput) ToContentMapOutputWithContext(ctx context.Context) ContentMapOutput {
	return o
}

func (o ContentMapOutput) MapIndex(k pulumi.StringInput) ContentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Content {
		return vs[0].(map[string]*Content)[vs[1].(string)]
	}).(ContentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*ContentInput)(nil)).Elem(), &Content{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContentArrayInput)(nil)).Elem(), ContentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*ContentMapInput)(nil)).Elem(), ContentMap{})
	pulumi.RegisterOutputType(ContentOutput{})
	pulumi.RegisterOutputType(ContentArrayOutput{})
	pulumi.RegisterOutputType(ContentMapOutput{})
}
