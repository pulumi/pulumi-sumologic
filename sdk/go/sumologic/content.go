// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a way to interact with Sumologic Content.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"encoding/json"
//
// 	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		personalFolder, err := sumologic.GetPersonalFolder(ctx, nil, nil)
// 		if err != nil {
// 			return err
// 		}
// 		tmpJSON0, err := json.Marshal(map[string]interface{}{
// 			"type": "SavedSearchWithScheduleSyncDefinition",
// 			"name": "test-333",
// 			"search": map[string]interface{}{
// 				"queryText":        "\"warn\"",
// 				"defaultTimeRange": "-15m",
// 				"byReceiptTime":    false,
// 				"viewName":         "",
// 				"viewStartTime":    "1970-01-01T00:00:00Z",
// 				"queryParameters":  []interface{}{},
// 				"parsingMode":      "Manual",
// 			},
// 			"searchSchedule": map[string]interface{}{
// 				"cronExpression":       "0 0 * * * ? *",
// 				"displayableTimeRange": "-10m",
// 				"parseableTimeRange": map[string]interface{}{
// 					"type": "BeginBoundedTimeRange",
// 					"from": map[string]interface{}{
// 						"type":         "RelativeTimeRangeBoundary",
// 						"relativeTime": "-50m",
// 					},
// 					"to": nil,
// 				},
// 				"timeZone":  "America/Los_Angeles",
// 				"threshold": nil,
// 				"notification": map[string]interface{}{
// 					"taskType": "EmailSearchNotificationSyncDefinition",
// 					"toList": []string{
// 						"ops@acme.org",
// 					},
// 					"subjectTemplate":      "Search Results: {{Name}}",
// 					"includeQuery":         true,
// 					"includeResultSet":     true,
// 					"includeHistogram":     false,
// 					"includeCsvAttachment": false,
// 				},
// 				"scheduleType":    "1Hour",
// 				"muteErrorEmails": false,
// 				"parameters":      []interface{}{},
// 			},
// 			"description": "Runs every hour with timerange of 15m and sends email notifications",
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		json0 := string(tmpJSON0)
// 		_, err = sumologic.NewContent(ctx, "test", &sumologic.ContentArgs{
// 			ParentId: pulumi.String(personalFolder.Id),
// 			Config:   pulumi.String(json0),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Argument reference
//
// The following arguments are supported:
//
// - `parentId` - (Required) The identifier of the folder to import into. Identifiers from the Library in the Sumo user interface are provided in decimal format which is incompatible with this provider. The identifier needs to be in hexadecimal format.
// - `config` - (Required) JSON block for the content to import. NOTE: Updating the name will create a new object and leave a untracked content item (delete the existing content item and create a new content item if you want to update the name).
//
// ### Timeouts
//
// `Content` provides the following [Timeouts](https://www.terraform.io/docs/configuration/resources.html#timeouts) configuration options:
//
// - `read` - (Default `1 minute`) Used for waiting for the import job to be successful
// - `create` - (Default `10 minutes`) Used for waiting for the import job to be successful
// - `update` - (Default `10 minutes`) Used for waiting for the import job to be successful
// - `delete` - (Default `1 minute`) Used for waiting for the deletion job to be successful
//
// ## Attributes reference
//
// The following attributes are exported:
//
// - `id` - Unique identifier for the content item.
//
// [1]: https://help.sumologic.com/APIs/Content-Management-API
type Content struct {
	pulumi.CustomResourceState

	Config   pulumi.StringOutput `pulumi:"config"`
	ParentId pulumi.StringOutput `pulumi:"parentId"`
}

// NewContent registers a new resource with the given unique name, arguments, and options.
func NewContent(ctx *pulumi.Context,
	name string, args *ContentArgs, opts ...pulumi.ResourceOption) (*Content, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Config == nil {
		return nil, errors.New("invalid value for required argument 'Config'")
	}
	if args.ParentId == nil {
		return nil, errors.New("invalid value for required argument 'ParentId'")
	}
	var resource Content
	err := ctx.RegisterResource("sumologic:index/content:Content", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetContent gets an existing Content resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetContent(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *ContentState, opts ...pulumi.ResourceOption) (*Content, error) {
	var resource Content
	err := ctx.ReadResource("sumologic:index/content:Content", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Content resources.
type contentState struct {
	Config   *string `pulumi:"config"`
	ParentId *string `pulumi:"parentId"`
}

type ContentState struct {
	Config   pulumi.StringPtrInput
	ParentId pulumi.StringPtrInput
}

func (ContentState) ElementType() reflect.Type {
	return reflect.TypeOf((*contentState)(nil)).Elem()
}

type contentArgs struct {
	Config   string `pulumi:"config"`
	ParentId string `pulumi:"parentId"`
}

// The set of arguments for constructing a Content resource.
type ContentArgs struct {
	Config   pulumi.StringInput
	ParentId pulumi.StringInput
}

func (ContentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*contentArgs)(nil)).Elem()
}

type ContentInput interface {
	pulumi.Input

	ToContentOutput() ContentOutput
	ToContentOutputWithContext(ctx context.Context) ContentOutput
}

func (*Content) ElementType() reflect.Type {
	return reflect.TypeOf((*Content)(nil))
}

func (i *Content) ToContentOutput() ContentOutput {
	return i.ToContentOutputWithContext(context.Background())
}

func (i *Content) ToContentOutputWithContext(ctx context.Context) ContentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentOutput)
}

func (i *Content) ToContentPtrOutput() ContentPtrOutput {
	return i.ToContentPtrOutputWithContext(context.Background())
}

func (i *Content) ToContentPtrOutputWithContext(ctx context.Context) ContentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentPtrOutput)
}

type ContentPtrInput interface {
	pulumi.Input

	ToContentPtrOutput() ContentPtrOutput
	ToContentPtrOutputWithContext(ctx context.Context) ContentPtrOutput
}

type contentPtrType ContentArgs

func (*contentPtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**Content)(nil))
}

func (i *contentPtrType) ToContentPtrOutput() ContentPtrOutput {
	return i.ToContentPtrOutputWithContext(context.Background())
}

func (i *contentPtrType) ToContentPtrOutputWithContext(ctx context.Context) ContentPtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentPtrOutput)
}

// ContentArrayInput is an input type that accepts ContentArray and ContentArrayOutput values.
// You can construct a concrete instance of `ContentArrayInput` via:
//
//          ContentArray{ ContentArgs{...} }
type ContentArrayInput interface {
	pulumi.Input

	ToContentArrayOutput() ContentArrayOutput
	ToContentArrayOutputWithContext(context.Context) ContentArrayOutput
}

type ContentArray []ContentInput

func (ContentArray) ElementType() reflect.Type {
	return reflect.TypeOf(([]*Content)(nil))
}

func (i ContentArray) ToContentArrayOutput() ContentArrayOutput {
	return i.ToContentArrayOutputWithContext(context.Background())
}

func (i ContentArray) ToContentArrayOutputWithContext(ctx context.Context) ContentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentArrayOutput)
}

// ContentMapInput is an input type that accepts ContentMap and ContentMapOutput values.
// You can construct a concrete instance of `ContentMapInput` via:
//
//          ContentMap{ "key": ContentArgs{...} }
type ContentMapInput interface {
	pulumi.Input

	ToContentMapOutput() ContentMapOutput
	ToContentMapOutputWithContext(context.Context) ContentMapOutput
}

type ContentMap map[string]ContentInput

func (ContentMap) ElementType() reflect.Type {
	return reflect.TypeOf((map[string]*Content)(nil))
}

func (i ContentMap) ToContentMapOutput() ContentMapOutput {
	return i.ToContentMapOutputWithContext(context.Background())
}

func (i ContentMap) ToContentMapOutputWithContext(ctx context.Context) ContentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(ContentMapOutput)
}

type ContentOutput struct {
	*pulumi.OutputState
}

func (ContentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*Content)(nil))
}

func (o ContentOutput) ToContentOutput() ContentOutput {
	return o
}

func (o ContentOutput) ToContentOutputWithContext(ctx context.Context) ContentOutput {
	return o
}

func (o ContentOutput) ToContentPtrOutput() ContentPtrOutput {
	return o.ToContentPtrOutputWithContext(context.Background())
}

func (o ContentOutput) ToContentPtrOutputWithContext(ctx context.Context) ContentPtrOutput {
	return o.ApplyT(func(v Content) *Content {
		return &v
	}).(ContentPtrOutput)
}

type ContentPtrOutput struct {
	*pulumi.OutputState
}

func (ContentPtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Content)(nil))
}

func (o ContentPtrOutput) ToContentPtrOutput() ContentPtrOutput {
	return o
}

func (o ContentPtrOutput) ToContentPtrOutputWithContext(ctx context.Context) ContentPtrOutput {
	return o
}

type ContentArrayOutput struct{ *pulumi.OutputState }

func (ContentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]Content)(nil))
}

func (o ContentArrayOutput) ToContentArrayOutput() ContentArrayOutput {
	return o
}

func (o ContentArrayOutput) ToContentArrayOutputWithContext(ctx context.Context) ContentArrayOutput {
	return o
}

func (o ContentArrayOutput) Index(i pulumi.IntInput) ContentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) Content {
		return vs[0].([]Content)[vs[1].(int)]
	}).(ContentOutput)
}

type ContentMapOutput struct{ *pulumi.OutputState }

func (ContentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]Content)(nil))
}

func (o ContentMapOutput) ToContentMapOutput() ContentMapOutput {
	return o
}

func (o ContentMapOutput) ToContentMapOutputWithContext(ctx context.Context) ContentMapOutput {
	return o
}

func (o ContentMapOutput) MapIndex(k pulumi.StringInput) ContentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) Content {
		return vs[0].(map[string]Content)[vs[1].(string)]
	}).(ContentOutput)
}

func init() {
	pulumi.RegisterOutputType(ContentOutput{})
	pulumi.RegisterOutputType(ContentPtrOutput{})
	pulumi.RegisterOutputType(ContentArrayOutput{})
	pulumi.RegisterOutputType(ContentMapOutput{})
}
