// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a Sumologic CSE Tag Schema.
//
// ## Import
//
// # Tag Schema can be imported using the field id, e.g.hcl
//
// ```sh
//
//	$ pulumi import sumologic:index/cseTagSchema:CseTagSchema tag_schema id
//
// ```
type CseTagSchema struct {
	pulumi.CustomResourceState

	// Applicable content types. Valid values: "customInsight", "entity", "rule", "threatIntelligence".
	ContentTypes pulumi.StringArrayOutput `pulumi:"contentTypes"`
	// Whether the tag schema accepts free form custom values.
	FreeForm pulumi.BoolOutput `pulumi:"freeForm"`
	// Tag Schema key.
	Key pulumi.StringOutput `pulumi:"key"`
	// Value option label.
	Label        pulumi.StringOutput                `pulumi:"label"`
	ValueOptions CseTagSchemaValueOptionArrayOutput `pulumi:"valueOptions"`
}

// NewCseTagSchema registers a new resource with the given unique name, arguments, and options.
func NewCseTagSchema(ctx *pulumi.Context,
	name string, args *CseTagSchemaArgs, opts ...pulumi.ResourceOption) (*CseTagSchema, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.FreeForm == nil {
		return nil, errors.New("invalid value for required argument 'FreeForm'")
	}
	if args.Key == nil {
		return nil, errors.New("invalid value for required argument 'Key'")
	}
	if args.Label == nil {
		return nil, errors.New("invalid value for required argument 'Label'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource CseTagSchema
	err := ctx.RegisterResource("sumologic:index/cseTagSchema:CseTagSchema", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetCseTagSchema gets an existing CseTagSchema resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetCseTagSchema(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *CseTagSchemaState, opts ...pulumi.ResourceOption) (*CseTagSchema, error) {
	var resource CseTagSchema
	err := ctx.ReadResource("sumologic:index/cseTagSchema:CseTagSchema", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering CseTagSchema resources.
type cseTagSchemaState struct {
	// Applicable content types. Valid values: "customInsight", "entity", "rule", "threatIntelligence".
	ContentTypes []string `pulumi:"contentTypes"`
	// Whether the tag schema accepts free form custom values.
	FreeForm *bool `pulumi:"freeForm"`
	// Tag Schema key.
	Key *string `pulumi:"key"`
	// Value option label.
	Label        *string                   `pulumi:"label"`
	ValueOptions []CseTagSchemaValueOption `pulumi:"valueOptions"`
}

type CseTagSchemaState struct {
	// Applicable content types. Valid values: "customInsight", "entity", "rule", "threatIntelligence".
	ContentTypes pulumi.StringArrayInput
	// Whether the tag schema accepts free form custom values.
	FreeForm pulumi.BoolPtrInput
	// Tag Schema key.
	Key pulumi.StringPtrInput
	// Value option label.
	Label        pulumi.StringPtrInput
	ValueOptions CseTagSchemaValueOptionArrayInput
}

func (CseTagSchemaState) ElementType() reflect.Type {
	return reflect.TypeOf((*cseTagSchemaState)(nil)).Elem()
}

type cseTagSchemaArgs struct {
	// Applicable content types. Valid values: "customInsight", "entity", "rule", "threatIntelligence".
	ContentTypes []string `pulumi:"contentTypes"`
	// Whether the tag schema accepts free form custom values.
	FreeForm bool `pulumi:"freeForm"`
	// Tag Schema key.
	Key string `pulumi:"key"`
	// Value option label.
	Label        string                    `pulumi:"label"`
	ValueOptions []CseTagSchemaValueOption `pulumi:"valueOptions"`
}

// The set of arguments for constructing a CseTagSchema resource.
type CseTagSchemaArgs struct {
	// Applicable content types. Valid values: "customInsight", "entity", "rule", "threatIntelligence".
	ContentTypes pulumi.StringArrayInput
	// Whether the tag schema accepts free form custom values.
	FreeForm pulumi.BoolInput
	// Tag Schema key.
	Key pulumi.StringInput
	// Value option label.
	Label        pulumi.StringInput
	ValueOptions CseTagSchemaValueOptionArrayInput
}

func (CseTagSchemaArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*cseTagSchemaArgs)(nil)).Elem()
}

type CseTagSchemaInput interface {
	pulumi.Input

	ToCseTagSchemaOutput() CseTagSchemaOutput
	ToCseTagSchemaOutputWithContext(ctx context.Context) CseTagSchemaOutput
}

func (*CseTagSchema) ElementType() reflect.Type {
	return reflect.TypeOf((**CseTagSchema)(nil)).Elem()
}

func (i *CseTagSchema) ToCseTagSchemaOutput() CseTagSchemaOutput {
	return i.ToCseTagSchemaOutputWithContext(context.Background())
}

func (i *CseTagSchema) ToCseTagSchemaOutputWithContext(ctx context.Context) CseTagSchemaOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CseTagSchemaOutput)
}

// CseTagSchemaArrayInput is an input type that accepts CseTagSchemaArray and CseTagSchemaArrayOutput values.
// You can construct a concrete instance of `CseTagSchemaArrayInput` via:
//
//	CseTagSchemaArray{ CseTagSchemaArgs{...} }
type CseTagSchemaArrayInput interface {
	pulumi.Input

	ToCseTagSchemaArrayOutput() CseTagSchemaArrayOutput
	ToCseTagSchemaArrayOutputWithContext(context.Context) CseTagSchemaArrayOutput
}

type CseTagSchemaArray []CseTagSchemaInput

func (CseTagSchemaArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CseTagSchema)(nil)).Elem()
}

func (i CseTagSchemaArray) ToCseTagSchemaArrayOutput() CseTagSchemaArrayOutput {
	return i.ToCseTagSchemaArrayOutputWithContext(context.Background())
}

func (i CseTagSchemaArray) ToCseTagSchemaArrayOutputWithContext(ctx context.Context) CseTagSchemaArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CseTagSchemaArrayOutput)
}

// CseTagSchemaMapInput is an input type that accepts CseTagSchemaMap and CseTagSchemaMapOutput values.
// You can construct a concrete instance of `CseTagSchemaMapInput` via:
//
//	CseTagSchemaMap{ "key": CseTagSchemaArgs{...} }
type CseTagSchemaMapInput interface {
	pulumi.Input

	ToCseTagSchemaMapOutput() CseTagSchemaMapOutput
	ToCseTagSchemaMapOutputWithContext(context.Context) CseTagSchemaMapOutput
}

type CseTagSchemaMap map[string]CseTagSchemaInput

func (CseTagSchemaMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CseTagSchema)(nil)).Elem()
}

func (i CseTagSchemaMap) ToCseTagSchemaMapOutput() CseTagSchemaMapOutput {
	return i.ToCseTagSchemaMapOutputWithContext(context.Background())
}

func (i CseTagSchemaMap) ToCseTagSchemaMapOutputWithContext(ctx context.Context) CseTagSchemaMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(CseTagSchemaMapOutput)
}

type CseTagSchemaOutput struct{ *pulumi.OutputState }

func (CseTagSchemaOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**CseTagSchema)(nil)).Elem()
}

func (o CseTagSchemaOutput) ToCseTagSchemaOutput() CseTagSchemaOutput {
	return o
}

func (o CseTagSchemaOutput) ToCseTagSchemaOutputWithContext(ctx context.Context) CseTagSchemaOutput {
	return o
}

// Applicable content types. Valid values: "customInsight", "entity", "rule", "threatIntelligence".
func (o CseTagSchemaOutput) ContentTypes() pulumi.StringArrayOutput {
	return o.ApplyT(func(v *CseTagSchema) pulumi.StringArrayOutput { return v.ContentTypes }).(pulumi.StringArrayOutput)
}

// Whether the tag schema accepts free form custom values.
func (o CseTagSchemaOutput) FreeForm() pulumi.BoolOutput {
	return o.ApplyT(func(v *CseTagSchema) pulumi.BoolOutput { return v.FreeForm }).(pulumi.BoolOutput)
}

// Tag Schema key.
func (o CseTagSchemaOutput) Key() pulumi.StringOutput {
	return o.ApplyT(func(v *CseTagSchema) pulumi.StringOutput { return v.Key }).(pulumi.StringOutput)
}

// Value option label.
func (o CseTagSchemaOutput) Label() pulumi.StringOutput {
	return o.ApplyT(func(v *CseTagSchema) pulumi.StringOutput { return v.Label }).(pulumi.StringOutput)
}

func (o CseTagSchemaOutput) ValueOptions() CseTagSchemaValueOptionArrayOutput {
	return o.ApplyT(func(v *CseTagSchema) CseTagSchemaValueOptionArrayOutput { return v.ValueOptions }).(CseTagSchemaValueOptionArrayOutput)
}

type CseTagSchemaArrayOutput struct{ *pulumi.OutputState }

func (CseTagSchemaArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*CseTagSchema)(nil)).Elem()
}

func (o CseTagSchemaArrayOutput) ToCseTagSchemaArrayOutput() CseTagSchemaArrayOutput {
	return o
}

func (o CseTagSchemaArrayOutput) ToCseTagSchemaArrayOutputWithContext(ctx context.Context) CseTagSchemaArrayOutput {
	return o
}

func (o CseTagSchemaArrayOutput) Index(i pulumi.IntInput) CseTagSchemaOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *CseTagSchema {
		return vs[0].([]*CseTagSchema)[vs[1].(int)]
	}).(CseTagSchemaOutput)
}

type CseTagSchemaMapOutput struct{ *pulumi.OutputState }

func (CseTagSchemaMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*CseTagSchema)(nil)).Elem()
}

func (o CseTagSchemaMapOutput) ToCseTagSchemaMapOutput() CseTagSchemaMapOutput {
	return o
}

func (o CseTagSchemaMapOutput) ToCseTagSchemaMapOutputWithContext(ctx context.Context) CseTagSchemaMapOutput {
	return o
}

func (o CseTagSchemaMapOutput) MapIndex(k pulumi.StringInput) CseTagSchemaOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *CseTagSchema {
		return vs[0].(map[string]*CseTagSchema)[vs[1].(string)]
	}).(CseTagSchemaOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*CseTagSchemaInput)(nil)).Elem(), &CseTagSchema{})
	pulumi.RegisterInputType(reflect.TypeOf((*CseTagSchemaArrayInput)(nil)).Elem(), CseTagSchemaArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*CseTagSchemaMapInput)(nil)).Elem(), CseTagSchemaMap{})
	pulumi.RegisterOutputType(CseTagSchemaOutput{})
	pulumi.RegisterOutputType(CseTagSchemaArrayOutput{})
	pulumi.RegisterOutputType(CseTagSchemaMapOutput{})
}
