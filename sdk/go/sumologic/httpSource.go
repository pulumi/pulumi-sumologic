// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a [Sumologic HTTP source](https://help.sumologic.com/Send_Data/Sources/02Sources_for_Hosted_Collectors/HTTP_Source), [Sumologic HTTP Traces source](https://help.sumologic.com/Traces/HTTP_Traces_Source), [Sumologic Kinesis Log source](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS_Kinesis_Firehose_for_Logs_Source) and [Sumologic HTTP_OTLP_source][4]. To start using Traces contact your Sumo account representative to activate.
//
// __IMPORTANT:__ The endpoint is stored in plain-text in the state. This is a potential security issue.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		collector, err := sumologic.NewCollector(ctx, "collector", &sumologic.CollectorArgs{
// 			Description: pulumi.String("Just testing this"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sumologic.NewHttpSource(ctx, "httpSource", &sumologic.HttpSourceArgs{
// 			Category:    pulumi.String("my/source/category"),
// 			CollectorId: collector.ID(),
// 			Description: pulumi.String("My description"),
// 			Filters: HttpSourceFilterArray{
// 				&HttpSourceFilterArgs{
// 					FilterType: pulumi.String("Exclude"),
// 					Name:       pulumi.String("Test Exclude Debug"),
// 					Regexp:     pulumi.String(".*DEBUG.*"),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sumologic.NewHttpSource(ctx, "httpTracesSource", &sumologic.HttpSourceArgs{
// 			Category:    pulumi.String("my/source/category"),
// 			CollectorId: collector.ID(),
// 			ContentType: pulumi.String("Zipkin"),
// 			Description: pulumi.String("My description"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sumologic.NewHttpSource(ctx, "kinesisLog", &sumologic.HttpSourceArgs{
// 			Category:    pulumi.String("demo-category"),
// 			CollectorId: pulumi.Any(sumologic_collector.Test.Id),
// 			ContentType: pulumi.String("KinesisLog"),
// 			Description: pulumi.String("demo-desc"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sumologic.NewHttpSource(ctx, "httpOtlpSource", &sumologic.HttpSourceArgs{
// 			Category:    pulumi.String("my/source/category"),
// 			CollectorId: pulumi.Any(sumologic_collector.Test.Id),
// 			ContentType: pulumi.String("Otlp"),
// 			Description: pulumi.String("My description"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
//
// ## Import
//
// HTTP sources can be imported using the collector and source IDs (`collector/source`), e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/httpSource:HttpSource test 123/456
// ```
//
//  HTTP sources can be imported using the collector name and source name (`collectorName/sourceName`), e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/httpSource:HttpSource test my-test-collector/my-test-source
// ```
//
//  [1]https://help.sumologic.com/Send_Data/Sources/02Sources_for_Hosted_Collectors/HTTP_Source [2]https://help.sumologic.com/Traces/HTTP_Traces_Source [3]https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS_Kinesis_Firehose_for_Logs_Source [4]https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/OTLP_HTTP_Source
type HttpSource struct {
	pulumi.CustomResourceState

	AutomaticDateParsing pulumi.BoolPtrOutput   `pulumi:"automaticDateParsing"`
	Category             pulumi.StringPtrOutput `pulumi:"category"`
	CollectorId          pulumi.IntOutput       `pulumi:"collectorId"`
	// When configuring a HTTP Traces Source, set this property to `Zipkin`. When configuring a Kinesis Logs Source, set this property to `KinesisLog`. When configuring a HTTP OTLP Source, set this property to `Otlp`. This should only be used when creating a Traces, Kinesis Log or HTTP OTLP source.
	ContentType        pulumi.StringPtrOutput                 `pulumi:"contentType"`
	CutoffRelativeTime pulumi.StringPtrOutput                 `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp    pulumi.IntPtrOutput                    `pulumi:"cutoffTimestamp"`
	DefaultDateFormats HttpSourceDefaultDateFormatArrayOutput `pulumi:"defaultDateFormats"`
	Description        pulumi.StringPtrOutput                 `pulumi:"description"`
	Fields             pulumi.StringMapOutput                 `pulumi:"fields"`
	Filters            HttpSourceFilterArrayOutput            `pulumi:"filters"`
	ForceTimezone      pulumi.BoolPtrOutput                   `pulumi:"forceTimezone"`
	HostName           pulumi.StringPtrOutput                 `pulumi:"hostName"`
	ManualPrefixRegexp pulumi.StringPtrOutput                 `pulumi:"manualPrefixRegexp"`
	// When set to `true`, will create one log message per HTTP request.
	MessagePerRequest          pulumi.BoolPtrOutput   `pulumi:"messagePerRequest"`
	MultilineProcessingEnabled pulumi.BoolPtrOutput   `pulumi:"multilineProcessingEnabled"`
	Name                       pulumi.StringOutput    `pulumi:"name"`
	Timezone                   pulumi.StringPtrOutput `pulumi:"timezone"`
	// The HTTP endpoint to use for sending data to this source.
	Url                 pulumi.StringOutput  `pulumi:"url"`
	UseAutolineMatching pulumi.BoolPtrOutput `pulumi:"useAutolineMatching"`
}

// NewHttpSource registers a new resource with the given unique name, arguments, and options.
func NewHttpSource(ctx *pulumi.Context,
	name string, args *HttpSourceArgs, opts ...pulumi.ResourceOption) (*HttpSource, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CollectorId == nil {
		return nil, errors.New("invalid value for required argument 'CollectorId'")
	}
	var resource HttpSource
	err := ctx.RegisterResource("sumologic:index/httpSource:HttpSource", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetHttpSource gets an existing HttpSource resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetHttpSource(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *HttpSourceState, opts ...pulumi.ResourceOption) (*HttpSource, error) {
	var resource HttpSource
	err := ctx.ReadResource("sumologic:index/httpSource:HttpSource", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering HttpSource resources.
type httpSourceState struct {
	AutomaticDateParsing *bool   `pulumi:"automaticDateParsing"`
	Category             *string `pulumi:"category"`
	CollectorId          *int    `pulumi:"collectorId"`
	// When configuring a HTTP Traces Source, set this property to `Zipkin`. When configuring a Kinesis Logs Source, set this property to `KinesisLog`. When configuring a HTTP OTLP Source, set this property to `Otlp`. This should only be used when creating a Traces, Kinesis Log or HTTP OTLP source.
	ContentType        *string                       `pulumi:"contentType"`
	CutoffRelativeTime *string                       `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp    *int                          `pulumi:"cutoffTimestamp"`
	DefaultDateFormats []HttpSourceDefaultDateFormat `pulumi:"defaultDateFormats"`
	Description        *string                       `pulumi:"description"`
	Fields             map[string]string             `pulumi:"fields"`
	Filters            []HttpSourceFilter            `pulumi:"filters"`
	ForceTimezone      *bool                         `pulumi:"forceTimezone"`
	HostName           *string                       `pulumi:"hostName"`
	ManualPrefixRegexp *string                       `pulumi:"manualPrefixRegexp"`
	// When set to `true`, will create one log message per HTTP request.
	MessagePerRequest          *bool   `pulumi:"messagePerRequest"`
	MultilineProcessingEnabled *bool   `pulumi:"multilineProcessingEnabled"`
	Name                       *string `pulumi:"name"`
	Timezone                   *string `pulumi:"timezone"`
	// The HTTP endpoint to use for sending data to this source.
	Url                 *string `pulumi:"url"`
	UseAutolineMatching *bool   `pulumi:"useAutolineMatching"`
}

type HttpSourceState struct {
	AutomaticDateParsing pulumi.BoolPtrInput
	Category             pulumi.StringPtrInput
	CollectorId          pulumi.IntPtrInput
	// When configuring a HTTP Traces Source, set this property to `Zipkin`. When configuring a Kinesis Logs Source, set this property to `KinesisLog`. When configuring a HTTP OTLP Source, set this property to `Otlp`. This should only be used when creating a Traces, Kinesis Log or HTTP OTLP source.
	ContentType        pulumi.StringPtrInput
	CutoffRelativeTime pulumi.StringPtrInput
	CutoffTimestamp    pulumi.IntPtrInput
	DefaultDateFormats HttpSourceDefaultDateFormatArrayInput
	Description        pulumi.StringPtrInput
	Fields             pulumi.StringMapInput
	Filters            HttpSourceFilterArrayInput
	ForceTimezone      pulumi.BoolPtrInput
	HostName           pulumi.StringPtrInput
	ManualPrefixRegexp pulumi.StringPtrInput
	// When set to `true`, will create one log message per HTTP request.
	MessagePerRequest          pulumi.BoolPtrInput
	MultilineProcessingEnabled pulumi.BoolPtrInput
	Name                       pulumi.StringPtrInput
	Timezone                   pulumi.StringPtrInput
	// The HTTP endpoint to use for sending data to this source.
	Url                 pulumi.StringPtrInput
	UseAutolineMatching pulumi.BoolPtrInput
}

func (HttpSourceState) ElementType() reflect.Type {
	return reflect.TypeOf((*httpSourceState)(nil)).Elem()
}

type httpSourceArgs struct {
	AutomaticDateParsing *bool   `pulumi:"automaticDateParsing"`
	Category             *string `pulumi:"category"`
	CollectorId          int     `pulumi:"collectorId"`
	// When configuring a HTTP Traces Source, set this property to `Zipkin`. When configuring a Kinesis Logs Source, set this property to `KinesisLog`. When configuring a HTTP OTLP Source, set this property to `Otlp`. This should only be used when creating a Traces, Kinesis Log or HTTP OTLP source.
	ContentType        *string                       `pulumi:"contentType"`
	CutoffRelativeTime *string                       `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp    *int                          `pulumi:"cutoffTimestamp"`
	DefaultDateFormats []HttpSourceDefaultDateFormat `pulumi:"defaultDateFormats"`
	Description        *string                       `pulumi:"description"`
	Fields             map[string]string             `pulumi:"fields"`
	Filters            []HttpSourceFilter            `pulumi:"filters"`
	ForceTimezone      *bool                         `pulumi:"forceTimezone"`
	HostName           *string                       `pulumi:"hostName"`
	ManualPrefixRegexp *string                       `pulumi:"manualPrefixRegexp"`
	// When set to `true`, will create one log message per HTTP request.
	MessagePerRequest          *bool   `pulumi:"messagePerRequest"`
	MultilineProcessingEnabled *bool   `pulumi:"multilineProcessingEnabled"`
	Name                       *string `pulumi:"name"`
	Timezone                   *string `pulumi:"timezone"`
	UseAutolineMatching        *bool   `pulumi:"useAutolineMatching"`
}

// The set of arguments for constructing a HttpSource resource.
type HttpSourceArgs struct {
	AutomaticDateParsing pulumi.BoolPtrInput
	Category             pulumi.StringPtrInput
	CollectorId          pulumi.IntInput
	// When configuring a HTTP Traces Source, set this property to `Zipkin`. When configuring a Kinesis Logs Source, set this property to `KinesisLog`. When configuring a HTTP OTLP Source, set this property to `Otlp`. This should only be used when creating a Traces, Kinesis Log or HTTP OTLP source.
	ContentType        pulumi.StringPtrInput
	CutoffRelativeTime pulumi.StringPtrInput
	CutoffTimestamp    pulumi.IntPtrInput
	DefaultDateFormats HttpSourceDefaultDateFormatArrayInput
	Description        pulumi.StringPtrInput
	Fields             pulumi.StringMapInput
	Filters            HttpSourceFilterArrayInput
	ForceTimezone      pulumi.BoolPtrInput
	HostName           pulumi.StringPtrInput
	ManualPrefixRegexp pulumi.StringPtrInput
	// When set to `true`, will create one log message per HTTP request.
	MessagePerRequest          pulumi.BoolPtrInput
	MultilineProcessingEnabled pulumi.BoolPtrInput
	Name                       pulumi.StringPtrInput
	Timezone                   pulumi.StringPtrInput
	UseAutolineMatching        pulumi.BoolPtrInput
}

func (HttpSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*httpSourceArgs)(nil)).Elem()
}

type HttpSourceInput interface {
	pulumi.Input

	ToHttpSourceOutput() HttpSourceOutput
	ToHttpSourceOutputWithContext(ctx context.Context) HttpSourceOutput
}

func (*HttpSource) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpSource)(nil)).Elem()
}

func (i *HttpSource) ToHttpSourceOutput() HttpSourceOutput {
	return i.ToHttpSourceOutputWithContext(context.Background())
}

func (i *HttpSource) ToHttpSourceOutputWithContext(ctx context.Context) HttpSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpSourceOutput)
}

// HttpSourceArrayInput is an input type that accepts HttpSourceArray and HttpSourceArrayOutput values.
// You can construct a concrete instance of `HttpSourceArrayInput` via:
//
//          HttpSourceArray{ HttpSourceArgs{...} }
type HttpSourceArrayInput interface {
	pulumi.Input

	ToHttpSourceArrayOutput() HttpSourceArrayOutput
	ToHttpSourceArrayOutputWithContext(context.Context) HttpSourceArrayOutput
}

type HttpSourceArray []HttpSourceInput

func (HttpSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*HttpSource)(nil)).Elem()
}

func (i HttpSourceArray) ToHttpSourceArrayOutput() HttpSourceArrayOutput {
	return i.ToHttpSourceArrayOutputWithContext(context.Background())
}

func (i HttpSourceArray) ToHttpSourceArrayOutputWithContext(ctx context.Context) HttpSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpSourceArrayOutput)
}

// HttpSourceMapInput is an input type that accepts HttpSourceMap and HttpSourceMapOutput values.
// You can construct a concrete instance of `HttpSourceMapInput` via:
//
//          HttpSourceMap{ "key": HttpSourceArgs{...} }
type HttpSourceMapInput interface {
	pulumi.Input

	ToHttpSourceMapOutput() HttpSourceMapOutput
	ToHttpSourceMapOutputWithContext(context.Context) HttpSourceMapOutput
}

type HttpSourceMap map[string]HttpSourceInput

func (HttpSourceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*HttpSource)(nil)).Elem()
}

func (i HttpSourceMap) ToHttpSourceMapOutput() HttpSourceMapOutput {
	return i.ToHttpSourceMapOutputWithContext(context.Background())
}

func (i HttpSourceMap) ToHttpSourceMapOutputWithContext(ctx context.Context) HttpSourceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpSourceMapOutput)
}

type HttpSourceOutput struct{ *pulumi.OutputState }

func (HttpSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpSource)(nil)).Elem()
}

func (o HttpSourceOutput) ToHttpSourceOutput() HttpSourceOutput {
	return o
}

func (o HttpSourceOutput) ToHttpSourceOutputWithContext(ctx context.Context) HttpSourceOutput {
	return o
}

type HttpSourceArrayOutput struct{ *pulumi.OutputState }

func (HttpSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*HttpSource)(nil)).Elem()
}

func (o HttpSourceArrayOutput) ToHttpSourceArrayOutput() HttpSourceArrayOutput {
	return o
}

func (o HttpSourceArrayOutput) ToHttpSourceArrayOutputWithContext(ctx context.Context) HttpSourceArrayOutput {
	return o
}

func (o HttpSourceArrayOutput) Index(i pulumi.IntInput) HttpSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *HttpSource {
		return vs[0].([]*HttpSource)[vs[1].(int)]
	}).(HttpSourceOutput)
}

type HttpSourceMapOutput struct{ *pulumi.OutputState }

func (HttpSourceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*HttpSource)(nil)).Elem()
}

func (o HttpSourceMapOutput) ToHttpSourceMapOutput() HttpSourceMapOutput {
	return o
}

func (o HttpSourceMapOutput) ToHttpSourceMapOutputWithContext(ctx context.Context) HttpSourceMapOutput {
	return o
}

func (o HttpSourceMapOutput) MapIndex(k pulumi.StringInput) HttpSourceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *HttpSource {
		return vs[0].(map[string]*HttpSource)[vs[1].(string)]
	}).(HttpSourceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*HttpSourceInput)(nil)).Elem(), &HttpSource{})
	pulumi.RegisterInputType(reflect.TypeOf((*HttpSourceArrayInput)(nil)).Elem(), HttpSourceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HttpSourceMapInput)(nil)).Elem(), HttpSourceMap{})
	pulumi.RegisterOutputType(HttpSourceOutput{})
	pulumi.RegisterOutputType(HttpSourceArrayOutput{})
	pulumi.RegisterOutputType(HttpSourceMapOutput{})
}
