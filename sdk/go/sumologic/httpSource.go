// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a [Sumologic HTTP source](https://help.sumologic.com/Send_Data/Sources/02Sources_for_Hosted_Collectors/HTTP_Source), [Sumologic HTTP Traces source](https://help.sumologic.com/Traces/HTTP_Traces_Source) and [Sumologic Kinesis Log source](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS_Kinesis_Firehose_for_Logs_Source). To start using Traces contact your Sumo account representative to activate.
//
// __IMPORTANT:__ The endpoint is stored in plain-text in the state. This is a potential security issue.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
// 	"github.com/pulumi/pulumi-sumologic/sdk/go/sumologic"
// 	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
// )
//
// func main() {
// 	pulumi.Run(func(ctx *pulumi.Context) error {
// 		collector, err := sumologic.NewCollector(ctx, "collector", &sumologic.CollectorArgs{
// 			Description: pulumi.String("Just testing this"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sumologic.NewHttpSource(ctx, "httpSource", &sumologic.HttpSourceArgs{
// 			Category:    pulumi.String("my/source/category"),
// 			CollectorId: collector.ID(),
// 			Description: pulumi.String("My description"),
// 			Filters: HttpSourceFilterArray{
// 				&HttpSourceFilterArgs{
// 					FilterType: pulumi.String("Exclude"),
// 					Name:       pulumi.String("Test Exclude Debug"),
// 					Regexp:     pulumi.String(".*DEBUG.*"),
// 				},
// 			},
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sumologic.NewHttpSource(ctx, "httpTracesSource", &sumologic.HttpSourceArgs{
// 			Category:    pulumi.String("my/source/category"),
// 			CollectorId: collector.ID(),
// 			ContentType: pulumi.String("Zipkin"),
// 			Description: pulumi.String("My description"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		_, err = sumologic.NewHttpSource(ctx, "kinesisLog", &sumologic.HttpSourceArgs{
// 			Category:    pulumi.String("demo-category"),
// 			CollectorId: pulumi.Any(sumologic_collector.Test.Id),
// 			ContentType: pulumi.String("KinesisLog"),
// 			Description: pulumi.String("demo-desc"),
// 		})
// 		if err != nil {
// 			return err
// 		}
// 		return nil
// 	})
// }
// ```
// ## Argument reference
//
// In addition to the common properties, the following arguments are supported:
//
// - `messagePerRequest` - (Optional) When set to `true`, will create one log message per HTTP request.
// - `contentType`        - (Optional) When configuring a HTTP Traces Source, set this property to `Zipkin`. When configuring a Kinesis Logs Source, set this property to `KinesisLog`. This should only be used when creating a Traces or Kinesis Log source.
//
// ## Import
//
// HTTP sources can be imported using the collector and source IDs (`collector/source`), e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/httpSource:HttpSource test 123/456
// ```
//
//  HTTP sources can be imported using the collector name and source name (`collectorName/sourceName`), e.g.hcl
//
// ```sh
//  $ pulumi import sumologic:index/httpSource:HttpSource test my-test-collector/my-test-source
// ```
//
//  [1]https://help.sumologic.com/Send_Data/Sources/02Sources_for_Hosted_Collectors/HTTP_Source [2]https://help.sumologic.com/Traces/HTTP_Traces_Source [3]https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/AWS_Kinesis_Firehose_for_Logs_Source
type HttpSource struct {
	pulumi.CustomResourceState

	AutomaticDateParsing       pulumi.BoolPtrOutput                   `pulumi:"automaticDateParsing"`
	Category                   pulumi.StringPtrOutput                 `pulumi:"category"`
	CollectorId                pulumi.IntOutput                       `pulumi:"collectorId"`
	ContentType                pulumi.StringPtrOutput                 `pulumi:"contentType"`
	CutoffRelativeTime         pulumi.StringPtrOutput                 `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp            pulumi.IntPtrOutput                    `pulumi:"cutoffTimestamp"`
	DefaultDateFormats         HttpSourceDefaultDateFormatArrayOutput `pulumi:"defaultDateFormats"`
	Description                pulumi.StringPtrOutput                 `pulumi:"description"`
	Fields                     pulumi.StringMapOutput                 `pulumi:"fields"`
	Filters                    HttpSourceFilterArrayOutput            `pulumi:"filters"`
	ForceTimezone              pulumi.BoolPtrOutput                   `pulumi:"forceTimezone"`
	HostName                   pulumi.StringPtrOutput                 `pulumi:"hostName"`
	ManualPrefixRegexp         pulumi.StringPtrOutput                 `pulumi:"manualPrefixRegexp"`
	MessagePerRequest          pulumi.BoolPtrOutput                   `pulumi:"messagePerRequest"`
	MultilineProcessingEnabled pulumi.BoolPtrOutput                   `pulumi:"multilineProcessingEnabled"`
	Name                       pulumi.StringOutput                    `pulumi:"name"`
	Timezone                   pulumi.StringPtrOutput                 `pulumi:"timezone"`
	// The HTTP endpoint to use for sending data to this source.
	Url                 pulumi.StringOutput  `pulumi:"url"`
	UseAutolineMatching pulumi.BoolPtrOutput `pulumi:"useAutolineMatching"`
}

// NewHttpSource registers a new resource with the given unique name, arguments, and options.
func NewHttpSource(ctx *pulumi.Context,
	name string, args *HttpSourceArgs, opts ...pulumi.ResourceOption) (*HttpSource, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.CollectorId == nil {
		return nil, errors.New("invalid value for required argument 'CollectorId'")
	}
	var resource HttpSource
	err := ctx.RegisterResource("sumologic:index/httpSource:HttpSource", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetHttpSource gets an existing HttpSource resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetHttpSource(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *HttpSourceState, opts ...pulumi.ResourceOption) (*HttpSource, error) {
	var resource HttpSource
	err := ctx.ReadResource("sumologic:index/httpSource:HttpSource", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering HttpSource resources.
type httpSourceState struct {
	AutomaticDateParsing       *bool                         `pulumi:"automaticDateParsing"`
	Category                   *string                       `pulumi:"category"`
	CollectorId                *int                          `pulumi:"collectorId"`
	ContentType                *string                       `pulumi:"contentType"`
	CutoffRelativeTime         *string                       `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp            *int                          `pulumi:"cutoffTimestamp"`
	DefaultDateFormats         []HttpSourceDefaultDateFormat `pulumi:"defaultDateFormats"`
	Description                *string                       `pulumi:"description"`
	Fields                     map[string]string             `pulumi:"fields"`
	Filters                    []HttpSourceFilter            `pulumi:"filters"`
	ForceTimezone              *bool                         `pulumi:"forceTimezone"`
	HostName                   *string                       `pulumi:"hostName"`
	ManualPrefixRegexp         *string                       `pulumi:"manualPrefixRegexp"`
	MessagePerRequest          *bool                         `pulumi:"messagePerRequest"`
	MultilineProcessingEnabled *bool                         `pulumi:"multilineProcessingEnabled"`
	Name                       *string                       `pulumi:"name"`
	Timezone                   *string                       `pulumi:"timezone"`
	// The HTTP endpoint to use for sending data to this source.
	Url                 *string `pulumi:"url"`
	UseAutolineMatching *bool   `pulumi:"useAutolineMatching"`
}

type HttpSourceState struct {
	AutomaticDateParsing       pulumi.BoolPtrInput
	Category                   pulumi.StringPtrInput
	CollectorId                pulumi.IntPtrInput
	ContentType                pulumi.StringPtrInput
	CutoffRelativeTime         pulumi.StringPtrInput
	CutoffTimestamp            pulumi.IntPtrInput
	DefaultDateFormats         HttpSourceDefaultDateFormatArrayInput
	Description                pulumi.StringPtrInput
	Fields                     pulumi.StringMapInput
	Filters                    HttpSourceFilterArrayInput
	ForceTimezone              pulumi.BoolPtrInput
	HostName                   pulumi.StringPtrInput
	ManualPrefixRegexp         pulumi.StringPtrInput
	MessagePerRequest          pulumi.BoolPtrInput
	MultilineProcessingEnabled pulumi.BoolPtrInput
	Name                       pulumi.StringPtrInput
	Timezone                   pulumi.StringPtrInput
	// The HTTP endpoint to use for sending data to this source.
	Url                 pulumi.StringPtrInput
	UseAutolineMatching pulumi.BoolPtrInput
}

func (HttpSourceState) ElementType() reflect.Type {
	return reflect.TypeOf((*httpSourceState)(nil)).Elem()
}

type httpSourceArgs struct {
	AutomaticDateParsing       *bool                         `pulumi:"automaticDateParsing"`
	Category                   *string                       `pulumi:"category"`
	CollectorId                int                           `pulumi:"collectorId"`
	ContentType                *string                       `pulumi:"contentType"`
	CutoffRelativeTime         *string                       `pulumi:"cutoffRelativeTime"`
	CutoffTimestamp            *int                          `pulumi:"cutoffTimestamp"`
	DefaultDateFormats         []HttpSourceDefaultDateFormat `pulumi:"defaultDateFormats"`
	Description                *string                       `pulumi:"description"`
	Fields                     map[string]string             `pulumi:"fields"`
	Filters                    []HttpSourceFilter            `pulumi:"filters"`
	ForceTimezone              *bool                         `pulumi:"forceTimezone"`
	HostName                   *string                       `pulumi:"hostName"`
	ManualPrefixRegexp         *string                       `pulumi:"manualPrefixRegexp"`
	MessagePerRequest          *bool                         `pulumi:"messagePerRequest"`
	MultilineProcessingEnabled *bool                         `pulumi:"multilineProcessingEnabled"`
	Name                       *string                       `pulumi:"name"`
	Timezone                   *string                       `pulumi:"timezone"`
	UseAutolineMatching        *bool                         `pulumi:"useAutolineMatching"`
}

// The set of arguments for constructing a HttpSource resource.
type HttpSourceArgs struct {
	AutomaticDateParsing       pulumi.BoolPtrInput
	Category                   pulumi.StringPtrInput
	CollectorId                pulumi.IntInput
	ContentType                pulumi.StringPtrInput
	CutoffRelativeTime         pulumi.StringPtrInput
	CutoffTimestamp            pulumi.IntPtrInput
	DefaultDateFormats         HttpSourceDefaultDateFormatArrayInput
	Description                pulumi.StringPtrInput
	Fields                     pulumi.StringMapInput
	Filters                    HttpSourceFilterArrayInput
	ForceTimezone              pulumi.BoolPtrInput
	HostName                   pulumi.StringPtrInput
	ManualPrefixRegexp         pulumi.StringPtrInput
	MessagePerRequest          pulumi.BoolPtrInput
	MultilineProcessingEnabled pulumi.BoolPtrInput
	Name                       pulumi.StringPtrInput
	Timezone                   pulumi.StringPtrInput
	UseAutolineMatching        pulumi.BoolPtrInput
}

func (HttpSourceArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*httpSourceArgs)(nil)).Elem()
}

type HttpSourceInput interface {
	pulumi.Input

	ToHttpSourceOutput() HttpSourceOutput
	ToHttpSourceOutputWithContext(ctx context.Context) HttpSourceOutput
}

func (*HttpSource) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpSource)(nil))
}

func (i *HttpSource) ToHttpSourceOutput() HttpSourceOutput {
	return i.ToHttpSourceOutputWithContext(context.Background())
}

func (i *HttpSource) ToHttpSourceOutputWithContext(ctx context.Context) HttpSourceOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpSourceOutput)
}

func (i *HttpSource) ToHttpSourcePtrOutput() HttpSourcePtrOutput {
	return i.ToHttpSourcePtrOutputWithContext(context.Background())
}

func (i *HttpSource) ToHttpSourcePtrOutputWithContext(ctx context.Context) HttpSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpSourcePtrOutput)
}

type HttpSourcePtrInput interface {
	pulumi.Input

	ToHttpSourcePtrOutput() HttpSourcePtrOutput
	ToHttpSourcePtrOutputWithContext(ctx context.Context) HttpSourcePtrOutput
}

type httpSourcePtrType HttpSourceArgs

func (*httpSourcePtrType) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpSource)(nil))
}

func (i *httpSourcePtrType) ToHttpSourcePtrOutput() HttpSourcePtrOutput {
	return i.ToHttpSourcePtrOutputWithContext(context.Background())
}

func (i *httpSourcePtrType) ToHttpSourcePtrOutputWithContext(ctx context.Context) HttpSourcePtrOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpSourcePtrOutput)
}

// HttpSourceArrayInput is an input type that accepts HttpSourceArray and HttpSourceArrayOutput values.
// You can construct a concrete instance of `HttpSourceArrayInput` via:
//
//          HttpSourceArray{ HttpSourceArgs{...} }
type HttpSourceArrayInput interface {
	pulumi.Input

	ToHttpSourceArrayOutput() HttpSourceArrayOutput
	ToHttpSourceArrayOutputWithContext(context.Context) HttpSourceArrayOutput
}

type HttpSourceArray []HttpSourceInput

func (HttpSourceArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*HttpSource)(nil)).Elem()
}

func (i HttpSourceArray) ToHttpSourceArrayOutput() HttpSourceArrayOutput {
	return i.ToHttpSourceArrayOutputWithContext(context.Background())
}

func (i HttpSourceArray) ToHttpSourceArrayOutputWithContext(ctx context.Context) HttpSourceArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpSourceArrayOutput)
}

// HttpSourceMapInput is an input type that accepts HttpSourceMap and HttpSourceMapOutput values.
// You can construct a concrete instance of `HttpSourceMapInput` via:
//
//          HttpSourceMap{ "key": HttpSourceArgs{...} }
type HttpSourceMapInput interface {
	pulumi.Input

	ToHttpSourceMapOutput() HttpSourceMapOutput
	ToHttpSourceMapOutputWithContext(context.Context) HttpSourceMapOutput
}

type HttpSourceMap map[string]HttpSourceInput

func (HttpSourceMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*HttpSource)(nil)).Elem()
}

func (i HttpSourceMap) ToHttpSourceMapOutput() HttpSourceMapOutput {
	return i.ToHttpSourceMapOutputWithContext(context.Background())
}

func (i HttpSourceMap) ToHttpSourceMapOutputWithContext(ctx context.Context) HttpSourceMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(HttpSourceMapOutput)
}

type HttpSourceOutput struct{ *pulumi.OutputState }

func (HttpSourceOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*HttpSource)(nil))
}

func (o HttpSourceOutput) ToHttpSourceOutput() HttpSourceOutput {
	return o
}

func (o HttpSourceOutput) ToHttpSourceOutputWithContext(ctx context.Context) HttpSourceOutput {
	return o
}

func (o HttpSourceOutput) ToHttpSourcePtrOutput() HttpSourcePtrOutput {
	return o.ToHttpSourcePtrOutputWithContext(context.Background())
}

func (o HttpSourceOutput) ToHttpSourcePtrOutputWithContext(ctx context.Context) HttpSourcePtrOutput {
	return o.ApplyTWithContext(ctx, func(_ context.Context, v HttpSource) *HttpSource {
		return &v
	}).(HttpSourcePtrOutput)
}

type HttpSourcePtrOutput struct{ *pulumi.OutputState }

func (HttpSourcePtrOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**HttpSource)(nil))
}

func (o HttpSourcePtrOutput) ToHttpSourcePtrOutput() HttpSourcePtrOutput {
	return o
}

func (o HttpSourcePtrOutput) ToHttpSourcePtrOutputWithContext(ctx context.Context) HttpSourcePtrOutput {
	return o
}

func (o HttpSourcePtrOutput) Elem() HttpSourceOutput {
	return o.ApplyT(func(v *HttpSource) HttpSource {
		if v != nil {
			return *v
		}
		var ret HttpSource
		return ret
	}).(HttpSourceOutput)
}

type HttpSourceArrayOutput struct{ *pulumi.OutputState }

func (HttpSourceArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]HttpSource)(nil))
}

func (o HttpSourceArrayOutput) ToHttpSourceArrayOutput() HttpSourceArrayOutput {
	return o
}

func (o HttpSourceArrayOutput) ToHttpSourceArrayOutputWithContext(ctx context.Context) HttpSourceArrayOutput {
	return o
}

func (o HttpSourceArrayOutput) Index(i pulumi.IntInput) HttpSourceOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) HttpSource {
		return vs[0].([]HttpSource)[vs[1].(int)]
	}).(HttpSourceOutput)
}

type HttpSourceMapOutput struct{ *pulumi.OutputState }

func (HttpSourceMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]HttpSource)(nil))
}

func (o HttpSourceMapOutput) ToHttpSourceMapOutput() HttpSourceMapOutput {
	return o
}

func (o HttpSourceMapOutput) ToHttpSourceMapOutputWithContext(ctx context.Context) HttpSourceMapOutput {
	return o
}

func (o HttpSourceMapOutput) MapIndex(k pulumi.StringInput) HttpSourceOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) HttpSource {
		return vs[0].(map[string]HttpSource)[vs[1].(string)]
	}).(HttpSourceOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*HttpSourceInput)(nil)).Elem(), &HttpSource{})
	pulumi.RegisterInputType(reflect.TypeOf((*HttpSourcePtrInput)(nil)).Elem(), &HttpSource{})
	pulumi.RegisterInputType(reflect.TypeOf((*HttpSourceArrayInput)(nil)).Elem(), HttpSourceArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*HttpSourceMapInput)(nil)).Elem(), HttpSourceMap{})
	pulumi.RegisterOutputType(HttpSourceOutput{})
	pulumi.RegisterOutputType(HttpSourcePtrOutput{})
	pulumi.RegisterOutputType(HttpSourceArrayOutput{})
	pulumi.RegisterOutputType(HttpSourceMapOutput{})
}
