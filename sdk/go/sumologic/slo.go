// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package sumologic

import (
	"context"
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides the ability to create, read, delete, and update [SLOs](https://help.sumologic.com/Beta/SLO_Reliability_Management).
type Slo struct {
	pulumi.CustomResourceState

	// Name of the application.
	// Defaults to true.
	Application pulumi.StringOutput `pulumi:"application"`
	// The compliance settings for the SLO.
	Compliances SloComplianceArrayOutput `pulumi:"compliances"`
	CreatedAt   pulumi.StringOutput      `pulumi:"createdAt"`
	CreatedBy   pulumi.StringOutput      `pulumi:"createdBy"`
	// The description of the SLO.
	Description pulumi.StringPtrOutput `pulumi:"description"`
	// The service level indicator on which SLO is to be defined. more details on the difference
	// b/w them can be found on
	// the [slo help page](https://help.sumologic.com/Beta/SLO_Reliability_Management/Access_and_Create_SLOs)
	// - windowBasedEvaluation - Evaluate SLI using successful/total windows.
	// - requestBasedEvaluation - Evaluate SLI based on occurrence of successful
	//   events / total events over entire compliance period.
	Indicator  SloIndicatorOutput   `pulumi:"indicator"`
	IsLocked   pulumi.BoolPtrOutput `pulumi:"isLocked"`
	IsMutable  pulumi.BoolOutput    `pulumi:"isMutable"`
	IsSystem   pulumi.BoolOutput    `pulumi:"isSystem"`
	ModifiedAt pulumi.StringOutput  `pulumi:"modifiedAt"`
	ModifiedBy pulumi.StringOutput  `pulumi:"modifiedBy"`
	// The name of the SLO. The name must be alphanumeric.
	Name pulumi.StringOutput `pulumi:"name"`
	// The ID of the SLO Folder that contains this SLO. Defaults to the root folder.
	ParentId       pulumi.StringOutput    `pulumi:"parentId"`
	PostRequestMap pulumi.StringMapOutput `pulumi:"postRequestMap"`
	// Name of the service.
	Service pulumi.StringOutput `pulumi:"service"`
	// The type of SLO. Valid values are `Latency`, `Error`, `Throughput`, `Availability`
	// , `Other`. Defaults to `Latency`.
	SignalType pulumi.StringOutput `pulumi:"signalType"`
	Version    pulumi.IntOutput    `pulumi:"version"`
}

// NewSlo registers a new resource with the given unique name, arguments, and options.
func NewSlo(ctx *pulumi.Context,
	name string, args *SloArgs, opts ...pulumi.ResourceOption) (*Slo, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Compliances == nil {
		return nil, errors.New("invalid value for required argument 'Compliances'")
	}
	if args.Indicator == nil {
		return nil, errors.New("invalid value for required argument 'Indicator'")
	}
	if args.SignalType == nil {
		return nil, errors.New("invalid value for required argument 'SignalType'")
	}
	var resource Slo
	err := ctx.RegisterResource("sumologic:index/slo:Slo", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetSlo gets an existing Slo resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetSlo(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *SloState, opts ...pulumi.ResourceOption) (*Slo, error) {
	var resource Slo
	err := ctx.ReadResource("sumologic:index/slo:Slo", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering Slo resources.
type sloState struct {
	// Name of the application.
	// Defaults to true.
	Application *string `pulumi:"application"`
	// The compliance settings for the SLO.
	Compliances []SloCompliance `pulumi:"compliances"`
	CreatedAt   *string         `pulumi:"createdAt"`
	CreatedBy   *string         `pulumi:"createdBy"`
	// The description of the SLO.
	Description *string `pulumi:"description"`
	// The service level indicator on which SLO is to be defined. more details on the difference
	// b/w them can be found on
	// the [slo help page](https://help.sumologic.com/Beta/SLO_Reliability_Management/Access_and_Create_SLOs)
	// - windowBasedEvaluation - Evaluate SLI using successful/total windows.
	// - requestBasedEvaluation - Evaluate SLI based on occurrence of successful
	//   events / total events over entire compliance period.
	Indicator  *SloIndicator `pulumi:"indicator"`
	IsLocked   *bool         `pulumi:"isLocked"`
	IsMutable  *bool         `pulumi:"isMutable"`
	IsSystem   *bool         `pulumi:"isSystem"`
	ModifiedAt *string       `pulumi:"modifiedAt"`
	ModifiedBy *string       `pulumi:"modifiedBy"`
	// The name of the SLO. The name must be alphanumeric.
	Name *string `pulumi:"name"`
	// The ID of the SLO Folder that contains this SLO. Defaults to the root folder.
	ParentId       *string           `pulumi:"parentId"`
	PostRequestMap map[string]string `pulumi:"postRequestMap"`
	// Name of the service.
	Service *string `pulumi:"service"`
	// The type of SLO. Valid values are `Latency`, `Error`, `Throughput`, `Availability`
	// , `Other`. Defaults to `Latency`.
	SignalType *string `pulumi:"signalType"`
	Version    *int    `pulumi:"version"`
}

type SloState struct {
	// Name of the application.
	// Defaults to true.
	Application pulumi.StringPtrInput
	// The compliance settings for the SLO.
	Compliances SloComplianceArrayInput
	CreatedAt   pulumi.StringPtrInput
	CreatedBy   pulumi.StringPtrInput
	// The description of the SLO.
	Description pulumi.StringPtrInput
	// The service level indicator on which SLO is to be defined. more details on the difference
	// b/w them can be found on
	// the [slo help page](https://help.sumologic.com/Beta/SLO_Reliability_Management/Access_and_Create_SLOs)
	// - windowBasedEvaluation - Evaluate SLI using successful/total windows.
	// - requestBasedEvaluation - Evaluate SLI based on occurrence of successful
	//   events / total events over entire compliance period.
	Indicator  SloIndicatorPtrInput
	IsLocked   pulumi.BoolPtrInput
	IsMutable  pulumi.BoolPtrInput
	IsSystem   pulumi.BoolPtrInput
	ModifiedAt pulumi.StringPtrInput
	ModifiedBy pulumi.StringPtrInput
	// The name of the SLO. The name must be alphanumeric.
	Name pulumi.StringPtrInput
	// The ID of the SLO Folder that contains this SLO. Defaults to the root folder.
	ParentId       pulumi.StringPtrInput
	PostRequestMap pulumi.StringMapInput
	// Name of the service.
	Service pulumi.StringPtrInput
	// The type of SLO. Valid values are `Latency`, `Error`, `Throughput`, `Availability`
	// , `Other`. Defaults to `Latency`.
	SignalType pulumi.StringPtrInput
	Version    pulumi.IntPtrInput
}

func (SloState) ElementType() reflect.Type {
	return reflect.TypeOf((*sloState)(nil)).Elem()
}

type sloArgs struct {
	// Name of the application.
	// Defaults to true.
	Application *string `pulumi:"application"`
	// The compliance settings for the SLO.
	Compliances []SloCompliance `pulumi:"compliances"`
	CreatedAt   *string         `pulumi:"createdAt"`
	CreatedBy   *string         `pulumi:"createdBy"`
	// The description of the SLO.
	Description *string `pulumi:"description"`
	// The service level indicator on which SLO is to be defined. more details on the difference
	// b/w them can be found on
	// the [slo help page](https://help.sumologic.com/Beta/SLO_Reliability_Management/Access_and_Create_SLOs)
	// - windowBasedEvaluation - Evaluate SLI using successful/total windows.
	// - requestBasedEvaluation - Evaluate SLI based on occurrence of successful
	//   events / total events over entire compliance period.
	Indicator  SloIndicator `pulumi:"indicator"`
	IsLocked   *bool        `pulumi:"isLocked"`
	IsMutable  *bool        `pulumi:"isMutable"`
	IsSystem   *bool        `pulumi:"isSystem"`
	ModifiedAt *string      `pulumi:"modifiedAt"`
	ModifiedBy *string      `pulumi:"modifiedBy"`
	// The name of the SLO. The name must be alphanumeric.
	Name *string `pulumi:"name"`
	// The ID of the SLO Folder that contains this SLO. Defaults to the root folder.
	ParentId       *string           `pulumi:"parentId"`
	PostRequestMap map[string]string `pulumi:"postRequestMap"`
	// Name of the service.
	Service *string `pulumi:"service"`
	// The type of SLO. Valid values are `Latency`, `Error`, `Throughput`, `Availability`
	// , `Other`. Defaults to `Latency`.
	SignalType string `pulumi:"signalType"`
	Version    *int   `pulumi:"version"`
}

// The set of arguments for constructing a Slo resource.
type SloArgs struct {
	// Name of the application.
	// Defaults to true.
	Application pulumi.StringPtrInput
	// The compliance settings for the SLO.
	Compliances SloComplianceArrayInput
	CreatedAt   pulumi.StringPtrInput
	CreatedBy   pulumi.StringPtrInput
	// The description of the SLO.
	Description pulumi.StringPtrInput
	// The service level indicator on which SLO is to be defined. more details on the difference
	// b/w them can be found on
	// the [slo help page](https://help.sumologic.com/Beta/SLO_Reliability_Management/Access_and_Create_SLOs)
	// - windowBasedEvaluation - Evaluate SLI using successful/total windows.
	// - requestBasedEvaluation - Evaluate SLI based on occurrence of successful
	//   events / total events over entire compliance period.
	Indicator  SloIndicatorInput
	IsLocked   pulumi.BoolPtrInput
	IsMutable  pulumi.BoolPtrInput
	IsSystem   pulumi.BoolPtrInput
	ModifiedAt pulumi.StringPtrInput
	ModifiedBy pulumi.StringPtrInput
	// The name of the SLO. The name must be alphanumeric.
	Name pulumi.StringPtrInput
	// The ID of the SLO Folder that contains this SLO. Defaults to the root folder.
	ParentId       pulumi.StringPtrInput
	PostRequestMap pulumi.StringMapInput
	// Name of the service.
	Service pulumi.StringPtrInput
	// The type of SLO. Valid values are `Latency`, `Error`, `Throughput`, `Availability`
	// , `Other`. Defaults to `Latency`.
	SignalType pulumi.StringInput
	Version    pulumi.IntPtrInput
}

func (SloArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*sloArgs)(nil)).Elem()
}

type SloInput interface {
	pulumi.Input

	ToSloOutput() SloOutput
	ToSloOutputWithContext(ctx context.Context) SloOutput
}

func (*Slo) ElementType() reflect.Type {
	return reflect.TypeOf((**Slo)(nil)).Elem()
}

func (i *Slo) ToSloOutput() SloOutput {
	return i.ToSloOutputWithContext(context.Background())
}

func (i *Slo) ToSloOutputWithContext(ctx context.Context) SloOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloOutput)
}

// SloArrayInput is an input type that accepts SloArray and SloArrayOutput values.
// You can construct a concrete instance of `SloArrayInput` via:
//
//	SloArray{ SloArgs{...} }
type SloArrayInput interface {
	pulumi.Input

	ToSloArrayOutput() SloArrayOutput
	ToSloArrayOutputWithContext(context.Context) SloArrayOutput
}

type SloArray []SloInput

func (SloArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Slo)(nil)).Elem()
}

func (i SloArray) ToSloArrayOutput() SloArrayOutput {
	return i.ToSloArrayOutputWithContext(context.Background())
}

func (i SloArray) ToSloArrayOutputWithContext(ctx context.Context) SloArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloArrayOutput)
}

// SloMapInput is an input type that accepts SloMap and SloMapOutput values.
// You can construct a concrete instance of `SloMapInput` via:
//
//	SloMap{ "key": SloArgs{...} }
type SloMapInput interface {
	pulumi.Input

	ToSloMapOutput() SloMapOutput
	ToSloMapOutputWithContext(context.Context) SloMapOutput
}

type SloMap map[string]SloInput

func (SloMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Slo)(nil)).Elem()
}

func (i SloMap) ToSloMapOutput() SloMapOutput {
	return i.ToSloMapOutputWithContext(context.Background())
}

func (i SloMap) ToSloMapOutputWithContext(ctx context.Context) SloMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(SloMapOutput)
}

type SloOutput struct{ *pulumi.OutputState }

func (SloOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**Slo)(nil)).Elem()
}

func (o SloOutput) ToSloOutput() SloOutput {
	return o
}

func (o SloOutput) ToSloOutputWithContext(ctx context.Context) SloOutput {
	return o
}

// Name of the application.
// Defaults to true.
func (o SloOutput) Application() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.Application }).(pulumi.StringOutput)
}

// The compliance settings for the SLO.
func (o SloOutput) Compliances() SloComplianceArrayOutput {
	return o.ApplyT(func(v *Slo) SloComplianceArrayOutput { return v.Compliances }).(SloComplianceArrayOutput)
}

func (o SloOutput) CreatedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.CreatedAt }).(pulumi.StringOutput)
}

func (o SloOutput) CreatedBy() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.CreatedBy }).(pulumi.StringOutput)
}

// The description of the SLO.
func (o SloOutput) Description() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringPtrOutput { return v.Description }).(pulumi.StringPtrOutput)
}

// The service level indicator on which SLO is to be defined. more details on the difference
// b/w them can be found on
// the [slo help page](https://help.sumologic.com/Beta/SLO_Reliability_Management/Access_and_Create_SLOs)
//   - windowBasedEvaluation - Evaluate SLI using successful/total windows.
//   - requestBasedEvaluation - Evaluate SLI based on occurrence of successful
//     events / total events over entire compliance period.
func (o SloOutput) Indicator() SloIndicatorOutput {
	return o.ApplyT(func(v *Slo) SloIndicatorOutput { return v.Indicator }).(SloIndicatorOutput)
}

func (o SloOutput) IsLocked() pulumi.BoolPtrOutput {
	return o.ApplyT(func(v *Slo) pulumi.BoolPtrOutput { return v.IsLocked }).(pulumi.BoolPtrOutput)
}

func (o SloOutput) IsMutable() pulumi.BoolOutput {
	return o.ApplyT(func(v *Slo) pulumi.BoolOutput { return v.IsMutable }).(pulumi.BoolOutput)
}

func (o SloOutput) IsSystem() pulumi.BoolOutput {
	return o.ApplyT(func(v *Slo) pulumi.BoolOutput { return v.IsSystem }).(pulumi.BoolOutput)
}

func (o SloOutput) ModifiedAt() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.ModifiedAt }).(pulumi.StringOutput)
}

func (o SloOutput) ModifiedBy() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.ModifiedBy }).(pulumi.StringOutput)
}

// The name of the SLO. The name must be alphanumeric.
func (o SloOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// The ID of the SLO Folder that contains this SLO. Defaults to the root folder.
func (o SloOutput) ParentId() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.ParentId }).(pulumi.StringOutput)
}

func (o SloOutput) PostRequestMap() pulumi.StringMapOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringMapOutput { return v.PostRequestMap }).(pulumi.StringMapOutput)
}

// Name of the service.
func (o SloOutput) Service() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.Service }).(pulumi.StringOutput)
}

// The type of SLO. Valid values are `Latency`, `Error`, `Throughput`, `Availability`
// , `Other`. Defaults to `Latency`.
func (o SloOutput) SignalType() pulumi.StringOutput {
	return o.ApplyT(func(v *Slo) pulumi.StringOutput { return v.SignalType }).(pulumi.StringOutput)
}

func (o SloOutput) Version() pulumi.IntOutput {
	return o.ApplyT(func(v *Slo) pulumi.IntOutput { return v.Version }).(pulumi.IntOutput)
}

type SloArrayOutput struct{ *pulumi.OutputState }

func (SloArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*Slo)(nil)).Elem()
}

func (o SloArrayOutput) ToSloArrayOutput() SloArrayOutput {
	return o
}

func (o SloArrayOutput) ToSloArrayOutputWithContext(ctx context.Context) SloArrayOutput {
	return o
}

func (o SloArrayOutput) Index(i pulumi.IntInput) SloOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *Slo {
		return vs[0].([]*Slo)[vs[1].(int)]
	}).(SloOutput)
}

type SloMapOutput struct{ *pulumi.OutputState }

func (SloMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*Slo)(nil)).Elem()
}

func (o SloMapOutput) ToSloMapOutput() SloMapOutput {
	return o
}

func (o SloMapOutput) ToSloMapOutputWithContext(ctx context.Context) SloMapOutput {
	return o
}

func (o SloMapOutput) MapIndex(k pulumi.StringInput) SloOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *Slo {
		return vs[0].(map[string]*Slo)[vs[1].(string)]
	}).(SloOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*SloInput)(nil)).Elem(), &Slo{})
	pulumi.RegisterInputType(reflect.TypeOf((*SloArrayInput)(nil)).Elem(), SloArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*SloMapInput)(nil)).Elem(), SloMap{})
	pulumi.RegisterOutputType(SloOutput{})
	pulumi.RegisterOutputType(SloArrayOutput{})
	pulumi.RegisterOutputType(SloMapOutput{})
}
