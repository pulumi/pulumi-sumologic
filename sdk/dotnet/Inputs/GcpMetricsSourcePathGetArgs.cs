// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.SumoLogic.Inputs
{

    public sealed class GcpMetricsSourcePathGetArgs : global::Pulumi.ResourceArgs
    {
        [Input("bucketName")]
        public Input<string>? BucketName { get; set; }

        [Input("customServices")]
        private InputList<Inputs.GcpMetricsSourcePathCustomServiceGetArgs>? _customServices;

        /// <summary>
        /// Sumoloigc provides list of services that can be used in limit_to_services for which metrics would be collected. Custom Services allow you to define your own service w.r.t. metric collection. You can provide list of metric prefixes that should be collected as part of the custom service. This provides fine-grain control w.r.t. what all metrics are ingested by sumologic.
        /// </summary>
        public InputList<Inputs.GcpMetricsSourcePathCustomServiceGetArgs> CustomServices
        {
            get => _customServices ?? (_customServices = new InputList<Inputs.GcpMetricsSourcePathCustomServiceGetArgs>());
            set => _customServices = value;
        }

        [Input("limitToNamespaces")]
        private InputList<string>? _limitToNamespaces;
        public InputList<string> LimitToNamespaces
        {
            get => _limitToNamespaces ?? (_limitToNamespaces = new InputList<string>());
            set => _limitToNamespaces = value;
        }

        [Input("limitToRegions")]
        private InputList<string>? _limitToRegions;

        /// <summary>
        /// List of regions for which metrics would be collected (Empty to collect from all regions)
        /// </summary>
        public InputList<string> LimitToRegions
        {
            get => _limitToRegions ?? (_limitToRegions = new InputList<string>());
            set => _limitToRegions = value;
        }

        [Input("limitToServices")]
        private InputList<string>? _limitToServices;

        /// <summary>
        /// List of services from which metrics would be collected
        /// </summary>
        public InputList<string> LimitToServices
        {
            get => _limitToServices ?? (_limitToServices = new InputList<string>());
            set => _limitToServices = value;
        }

        [Input("pathExpression")]
        public Input<string>? PathExpression { get; set; }

        [Input("snsTopicOrSubscriptionArns")]
        private InputList<Inputs.GcpMetricsSourcePathSnsTopicOrSubscriptionArnGetArgs>? _snsTopicOrSubscriptionArns;
        public InputList<Inputs.GcpMetricsSourcePathSnsTopicOrSubscriptionArnGetArgs> SnsTopicOrSubscriptionArns
        {
            get => _snsTopicOrSubscriptionArns ?? (_snsTopicOrSubscriptionArns = new InputList<Inputs.GcpMetricsSourcePathSnsTopicOrSubscriptionArnGetArgs>());
            set => _snsTopicOrSubscriptionArns = value;
        }

        [Input("tagFilters")]
        private InputList<Inputs.GcpMetricsSourcePathTagFilterGetArgs>? _tagFilters;
        public InputList<Inputs.GcpMetricsSourcePathTagFilterGetArgs> TagFilters
        {
            get => _tagFilters ?? (_tagFilters = new InputList<Inputs.GcpMetricsSourcePathTagFilterGetArgs>());
            set => _tagFilters = value;
        }

        /// <summary>
        /// Type of polling source. This has to be `GcpMetricsPath`.
        /// </summary>
        [Input("type", required: true)]
        public Input<string> Type { get; set; } = null!;

        [Input("useVersionedApi")]
        public Input<bool>? UseVersionedApi { get; set; }

        public GcpMetricsSourcePathGetArgs()
        {
        }
        public static new GcpMetricsSourcePathGetArgs Empty => new GcpMetricsSourcePathGetArgs();
    }
}
