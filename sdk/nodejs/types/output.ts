// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import { input as inputs, output as outputs } from "../types";

export interface AwsInventorySourceAuthentication {
    accessKey?: string;
    authProviderX509CertUrl?: string;
    authUri?: string;
    clientEmail?: string;
    clientId?: string;
    clientX509CertUrl?: string;
    privateKey?: string;
    privateKeyId?: string;
    projectId?: string;
    region?: string;
    /**
     * Your AWS role ARN. More details [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Grant-Access-to-an-AWS-Product#iam-role).
     */
    roleArn?: string;
    secretKey?: string;
    tokenUri?: string;
    /**
     * type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
     */
    type: string;
}

export interface AwsInventorySourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface AwsInventorySourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface AwsInventorySourcePath {
    bucketName?: string;
    customServices?: outputs.AwsInventorySourcePathCustomService[];
    /**
     * List of namespaces. By default all namespaces are selected. You can also choose a subset from
     * + AWS/EC2
     * + AWS/AutoScaling
     * + AWS/EBS
     * + AWS/ELB
     * + AWS/ApplicationELB
     * + AWS/NetworkELB
     * + AWS/Lambda
     * + AWS/RDS
     * + AWS/Dynamodb
     * + AWS/ECS
     * + AWS/Elasticache
     * + AWS/Redshift
     * + AWS/Kinesis
     */
    limitToNamespaces?: string[];
    /**
     * List of Amazon regions.
     */
    limitToRegions?: string[];
    limitToServices?: string[];
    pathExpression?: string;
    snsTopicOrSubscriptionArns: outputs.AwsInventorySourcePathSnsTopicOrSubscriptionArn[];
    tagFilters?: outputs.AwsInventorySourcePathTagFilter[];
    /**
     * type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
     */
    type: string;
}

export interface AwsInventorySourcePathCustomService {
    prefixes?: string[];
    serviceName?: string;
}

export interface AwsInventorySourcePathSnsTopicOrSubscriptionArn {
    arn: string;
    isSuccess: boolean;
}

export interface AwsInventorySourcePathTagFilter {
    namespace?: string;
    tags?: string[];
    /**
     * type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
     */
    type?: string;
}

export interface AwsXraySourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`
     */
    accessKey?: string;
    authProviderX509CertUrl?: string;
    authUri?: string;
    clientEmail?: string;
    clientId?: string;
    clientX509CertUrl?: string;
    privateKey?: string;
    privateKeyId?: string;
    projectId?: string;
    region?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`
     */
    secretKey?: string;
    tokenUri?: string;
    /**
     * type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
     */
    type: string;
}

export interface AwsXraySourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface AwsXraySourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface AwsXraySourcePath {
    bucketName?: string;
    customServices?: outputs.AwsXraySourcePathCustomService[];
    limitToNamespaces?: string[];
    /**
     * List of Amazon regions.
     */
    limitToRegions?: string[];
    limitToServices?: string[];
    pathExpression?: string;
    snsTopicOrSubscriptionArns: outputs.AwsXraySourcePathSnsTopicOrSubscriptionArn[];
    tagFilters?: outputs.AwsXraySourcePathTagFilter[];
    /**
     * type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
     */
    type: string;
}

export interface AwsXraySourcePathCustomService {
    prefixes?: string[];
    serviceName?: string;
}

export interface AwsXraySourcePathSnsTopicOrSubscriptionArn {
    arn: string;
    isSuccess: boolean;
}

export interface AwsXraySourcePathTagFilter {
    namespace?: string;
    tags?: string[];
    /**
     * type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
     */
    type?: string;
}

export interface CloudSyslogSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface CloudSyslogSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface CloudfrontSourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`
     */
    accessKey?: string;
    authProviderX509CertUrl?: string;
    authUri?: string;
    clientEmail?: string;
    clientId?: string;
    clientX509CertUrl?: string;
    privateKey?: string;
    privateKeyId?: string;
    projectId?: string;
    /**
     * Your AWS Bucket region.
     */
    region?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`
     */
    secretKey?: string;
    tokenUri?: string;
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
     */
    type: string;
}

export interface CloudfrontSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface CloudfrontSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface CloudfrontSourcePath {
    /**
     * The name of the bucket. This is needed if using type `S3BucketPathExpression`.
     */
    bucketName?: string;
    customServices?: outputs.CloudfrontSourcePathCustomService[];
    limitToNamespaces?: string[];
    limitToRegions?: string[];
    limitToServices?: string[];
    /**
     * The path to the data. This is needed if using type `S3BucketPathExpression`.
     */
    pathExpression?: string;
    /**
     * This is a computed field for SNS topic/subscription ARN.
     */
    snsTopicOrSubscriptionArns: outputs.CloudfrontSourcePathSnsTopicOrSubscriptionArn[];
    tagFilters?: outputs.CloudfrontSourcePathTagFilter[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
     */
    type: string;
}

export interface CloudfrontSourcePathCustomService {
    prefixes?: string[];
    serviceName?: string;
}

export interface CloudfrontSourcePathSnsTopicOrSubscriptionArn {
    arn: string;
    isSuccess: boolean;
}

export interface CloudfrontSourcePathTagFilter {
    namespace?: string;
    tags?: string[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
     */
    type?: string;
}

export interface CloudtrailSourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`
     */
    accessKey?: string;
    authProviderX509CertUrl?: string;
    authUri?: string;
    clientEmail?: string;
    clientId?: string;
    clientX509CertUrl?: string;
    privateKey?: string;
    privateKeyId?: string;
    projectId?: string;
    /**
     * Your AWS Bucket region.
     */
    region?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`
     */
    secretKey?: string;
    tokenUri?: string;
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
     */
    type: string;
}

export interface CloudtrailSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface CloudtrailSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface CloudtrailSourcePath {
    /**
     * The name of the bucket.
     */
    bucketName?: string;
    customServices?: outputs.CloudtrailSourcePathCustomService[];
    limitToNamespaces?: string[];
    limitToRegions?: string[];
    limitToServices?: string[];
    /**
     * The path to the data.
     */
    pathExpression?: string;
    /**
     * This is a computed field for SNS topic/subscription ARN.
     */
    snsTopicOrSubscriptionArns: outputs.CloudtrailSourcePathSnsTopicOrSubscriptionArn[];
    tagFilters?: outputs.CloudtrailSourcePathTagFilter[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
     */
    type: string;
}

export interface CloudtrailSourcePathCustomService {
    prefixes?: string[];
    serviceName?: string;
}

export interface CloudtrailSourcePathSnsTopicOrSubscriptionArn {
    arn: string;
    isSuccess: boolean;
}

export interface CloudtrailSourcePathTagFilter {
    namespace?: string;
    tags?: string[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
     */
    type?: string;
}

export interface CloudwatchSourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`
     */
    accessKey?: string;
    authProviderX509CertUrl?: string;
    authUri?: string;
    clientEmail?: string;
    clientId?: string;
    clientX509CertUrl?: string;
    privateKey?: string;
    privateKeyId?: string;
    projectId?: string;
    /**
     * Your AWS Bucket region.
     */
    region?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`
     */
    secretKey?: string;
    tokenUri?: string;
    /**
     * This value has to be set to `TagFilters`
     */
    type: string;
}

export interface CloudwatchSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface CloudwatchSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface CloudwatchSourcePath {
    bucketName?: string;
    customServices?: outputs.CloudwatchSourcePathCustomService[];
    /**
     * List of namespaces. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace.
     */
    limitToNamespaces?: string[];
    /**
     * List of Amazon regions.
     */
    limitToRegions?: string[];
    limitToServices?: string[];
    pathExpression?: string;
    snsTopicOrSubscriptionArns: outputs.CloudwatchSourcePathSnsTopicOrSubscriptionArn[];
    /**
     * Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
     */
    tagFilters?: outputs.CloudwatchSourcePathTagFilter[];
    /**
     * This value has to be set to `TagFilters`
     */
    type: string;
}

export interface CloudwatchSourcePathCustomService {
    prefixes?: string[];
    serviceName?: string;
}

export interface CloudwatchSourcePathSnsTopicOrSubscriptionArn {
    arn: string;
    isSuccess: boolean;
}

export interface CloudwatchSourcePathTagFilter {
    /**
     * Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
     */
    namespace?: string;
    /**
     * List of key-value pairs of tag filters. Eg: `["k3=v3"]`
     */
    tags?: string[];
    /**
     * This value has to be set to `TagFilters`
     */
    type?: string;
}

export interface ContentPermissionPermission {
    /**
     * Content permission name. Valid values are `View`, `GrantView`,
     * `Edit`, `GrantEdit`, `Manage`, and `GrantManage`. You can read more about permission levels
     * [here](https://help.sumologic.com/Manage/Content_Sharing/Share-Content#available-permission-levels).
     */
    permissionName: string;
    /**
     * An identifier that belongs to the source type chosen above. For example,
     * if the `sourceType` is set to `user`, `sourceId` should be identifier of the user you want to share
     * content with (same goes for role and org source type).
     */
    sourceId: string;
    /**
     * Type of source for the permission. Valid values are `user`, `role`,
     * and `org`.
     */
    sourceType: string;
}

export interface CseAggregationRuleAggregationFunction {
    /**
     * One or more expressions to pass as arguments to the function
     */
    arguments: string[];
    /**
     * The function to aggregate with
     */
    function: string;
    /**
     * The name of the Rule
     */
    name: string;
}

export interface CseAggregationRuleEntitySelector {
    entityType: string;
    /**
     * The expression or field name to generate the Signal on.
     */
    expression: string;
}

export interface CseAggregationRuleSeverityMapping {
    /**
     * The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
     */
    default?: number;
    /**
     * The field to use in the "fieldValue"/"fieldValueMapping" cases.
     */
    field?: string;
    /**
     * The map of record values to severities to use in the "fieldValueMapping" case
     */
    mappings?: outputs.CseAggregationRuleSeverityMappingMapping[];
    /**
     * Must be set to "eq" currently
     */
    type: string;
}

export interface CseAggregationRuleSeverityMappingMapping {
    /**
     * The record value to map from
     */
    from: string;
    /**
     * The severity value to map to
     */
    to: number;
    /**
     * Must be set to "eq" currently
     */
    type: string;
}

export interface CseChainRuleEntitySelector {
    entityType: string;
    /**
     * The expression for which records to match on
     */
    expression: string;
}

export interface CseChainRuleExpressionsAndLimit {
    /**
     * The expression for which records to match on
     */
    expression: string;
    /**
     * How many times this expression must match for the Signal to fire
     */
    limit: number;
}

export interface CseLogMappingField {
    /**
     * List of alternate values.
     */
    alternateValues?: string[];
    /**
     * Case insensitive flag.
     */
    caseInsensitive?: boolean;
    /**
     * Default value of the field.
     */
    defaultValue?: string;
    /**
     * List of field join values.
     */
    fieldJoins?: string[];
    /**
     * Format of the field. (JSON, Windows, Syslog, CEF, LEEF )
     */
    format?: string;
    /**
     * List of format parameters.
     */
    formatParameters?: string[];
    /**
     * Join delimiter.
     */
    joinDelimiter?: string;
    /**
     * List of lookup key value pair for field. See lookupSchema for details.
     */
    lookups?: outputs.CseLogMappingFieldLookup[];
    /**
     * Name of the field.
     */
    name: string;
    /**
     * List of skipped values.
     */
    skippedValues?: string[];
    /**
     * Split delimiter to be used. (some example: ",", "-", "|")
     */
    splitDelimiter?: string;
    /**
     * The index value to select (starting at zero)
     */
    splitIndex?: number;
    /**
     * Time zone.
     */
    timeZone?: string;
    /**
     * Lookup value.
     */
    value?: string;
    /**
     * The value type.
     */
    valueType?: string;
}

export interface CseLogMappingFieldLookup {
    /**
     * Lookup key.
     */
    key: string;
    /**
     * Lookup value.
     */
    value: string;
}

export interface CseLogMappingStructuredInput {
    /**
     * Event id pattern.
     */
    eventIdPattern: string;
    /**
     * Log format. (JSON, Windows, Syslog, CEF, LEEF )
     */
    logFormat: string;
    /**
     * Product name.
     */
    product: string;
    /**
     * Vendor name.
     */
    vendor: string;
}

export interface CseLogMappingUnstructuredFields {
    /**
     * List of grok pattern names.
     */
    patternNames: string[];
}

export interface CseMatchListItem {
    /**
     * Match list item description.
     */
    description: string;
    /**
     * Match list item expiration. (Format: YYYY-MM-DDTHH:mm:ss)
     */
    expiration?: string;
    /**
     * The internal ID of the match list.
     */
    id: string;
    /**
     * Match list item value.
     */
    value: string;
}

export interface CseMatchRuleEntitySelector {
    entityType: string;
    /**
     * The expression for which records to match on
     */
    expression: string;
}

export interface CseMatchRuleSeverityMapping {
    /**
     * The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
     */
    default?: number;
    /**
     * The field to use in the "fieldValue"/"fieldValueMapping" cases.
     */
    field?: string;
    /**
     * The map of record values to severities to use in the "fieldValueMapping" case
     */
    mappings?: outputs.CseMatchRuleSeverityMappingMapping[];
    /**
     * Must be set to "eq" currently
     */
    type: string;
}

export interface CseMatchRuleSeverityMappingMapping {
    /**
     * The record value to map from
     */
    from: string;
    /**
     * The severity value to map to
     */
    to: number;
    /**
     * Must be set to "eq" currently
     */
    type: string;
}

export interface CseThresholdRuleEntitySelector {
    entityType: string;
    /**
     * The expression for which records to match on
     */
    expression: string;
}

export interface DashboardColoringRule {
    colorThresholds?: outputs.DashboardColoringRuleColorThreshold[];
    multipleSeriesAggregateFunction: string;
    scope: string;
    singleSeriesAggregateFunction: string;
}

export interface DashboardColoringRuleColorThreshold {
    color: string;
    max?: number;
    min?: number;
}

export interface DashboardLayout {
    grid?: outputs.DashboardLayoutGrid;
}

export interface DashboardLayoutGrid {
    layoutStructures: outputs.DashboardLayoutGridLayoutStructure[];
}

export interface DashboardLayoutGridLayoutStructure {
    key: string;
    structure: string;
}

export interface DashboardPanel {
    sumoSearchPanel?: outputs.DashboardPanelSumoSearchPanel;
    textPanel?: outputs.DashboardPanelTextPanel;
}

export interface DashboardPanelSumoSearchPanel {
    coloringRule?: outputs.DashboardPanelSumoSearchPanelColoringRule;
    /**
     * Description of the dashboard.
     */
    description?: string;
    id: string;
    keepVisualSettingsConsistentWithParent?: boolean;
    key: string;
    linkedDashboard?: outputs.DashboardPanelSumoSearchPanelLinkedDashboard;
    queries?: outputs.DashboardPanelSumoSearchPanelQuery[];
    /**
     * Time range of the dashboard. See time range schema
     * for details.
     */
    timeRange?: outputs.DashboardPanelSumoSearchPanelTimeRange;
    /**
     * Title of the dashboard.
     */
    title?: string;
    visualSettings?: string;
}

export interface DashboardPanelSumoSearchPanelColoringRule {
    colorThresholds?: outputs.DashboardPanelSumoSearchPanelColoringRuleColorThreshold[];
    multipleSeriesAggregateFunction: string;
    scope: string;
    singleSeriesAggregateFunction: string;
}

export interface DashboardPanelSumoSearchPanelColoringRuleColorThreshold {
    color: string;
    max?: number;
    min?: number;
}

export interface DashboardPanelSumoSearchPanelLinkedDashboard {
    id: string;
    includeTimeRange?: boolean;
    includeVariables?: boolean;
    relativePath?: string;
}

export interface DashboardPanelSumoSearchPanelQuery {
    metricsQueryData?: outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryData;
    metricsQueryMode?: string;
    queryKey: string;
    queryString: string;
    queryType: string;
}

export interface DashboardPanelSumoSearchPanelQueryMetricsQueryData {
    aggregationType?: string;
    filters: outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter[];
    groupBy?: string;
    metric: string;
    operators?: outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator[];
}

export interface DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter {
    key: string;
    negation?: boolean;
    value: string;
}

export interface DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator {
    operatorName: string;
    parameters: outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter[];
}

export interface DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter {
    key: string;
    value: string;
}

export interface DashboardPanelSumoSearchPanelTimeRange {
    beginBoundedTimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange;
    completeLiteralTimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange {
    from: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom;
    to?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom {
    epochTimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange;
    iso8601TimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange;
    literalTimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange;
    relativeTimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange {
    epochMillis: number;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange {
    iso8601Time: string;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange {
    rangeName: string;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange {
    relativeTime: string;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo {
    epochTimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange;
    iso8601TimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange;
    literalTimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange;
    relativeTimeRange?: outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange {
    epochMillis: number;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange {
    iso8601Time: string;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange {
    rangeName: string;
}

export interface DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange {
    relativeTime: string;
}

export interface DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange {
    rangeName: string;
}

export interface DashboardPanelTextPanel {
    id: string;
    keepVisualSettingsConsistentWithParent?: boolean;
    key: string;
    text?: string;
    /**
     * Title of the dashboard.
     */
    title?: string;
    visualSettings?: string;
}

export interface DashboardTimeRange {
    beginBoundedTimeRange?: outputs.DashboardTimeRangeBeginBoundedTimeRange;
    completeLiteralTimeRange?: outputs.DashboardTimeRangeCompleteLiteralTimeRange;
}

export interface DashboardTimeRangeBeginBoundedTimeRange {
    from: outputs.DashboardTimeRangeBeginBoundedTimeRangeFrom;
    to?: outputs.DashboardTimeRangeBeginBoundedTimeRangeTo;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeFrom {
    epochTimeRange?: outputs.DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange;
    iso8601TimeRange?: outputs.DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange;
    literalTimeRange?: outputs.DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange;
    relativeTimeRange?: outputs.DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange {
    epochMillis: number;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange {
    iso8601Time: string;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange {
    rangeName: string;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange {
    relativeTime: string;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeTo {
    epochTimeRange?: outputs.DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange;
    iso8601TimeRange?: outputs.DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange;
    literalTimeRange?: outputs.DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange;
    relativeTimeRange?: outputs.DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange {
    epochMillis: number;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange {
    iso8601Time: string;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange {
    rangeName: string;
}

export interface DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange {
    relativeTime: string;
}

export interface DashboardTimeRangeCompleteLiteralTimeRange {
    rangeName: string;
}

export interface DashboardTopologyLabelMap {
    datas: outputs.DashboardTopologyLabelMapData[];
}

export interface DashboardTopologyLabelMapData {
    label: string;
    values: string[];
}

export interface DashboardVariable {
    allowMultiSelect?: boolean;
    defaultValue?: string;
    displayName?: string;
    hideFromUi?: boolean;
    id: string;
    includeAllOption?: boolean;
    name: string;
    sourceDefinition: outputs.DashboardVariableSourceDefinition;
}

export interface DashboardVariableSourceDefinition {
    csvVariableSourceDefinition?: outputs.DashboardVariableSourceDefinitionCsvVariableSourceDefinition;
    logQueryVariableSourceDefinition?: outputs.DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition;
    metadataVariableSourceDefinition?: outputs.DashboardVariableSourceDefinitionMetadataVariableSourceDefinition;
}

export interface DashboardVariableSourceDefinitionCsvVariableSourceDefinition {
    values: string;
}

export interface DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition {
    field: string;
    query: string;
}

export interface DashboardVariableSourceDefinitionMetadataVariableSourceDefinition {
    filter: string;
    key: string;
}

export interface ElbSourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`.
     */
    accessKey?: string;
    authProviderX509CertUrl?: string;
    authUri?: string;
    clientEmail?: string;
    clientId?: string;
    clientX509CertUrl?: string;
    privateKey?: string;
    privateKeyId?: string;
    projectId?: string;
    /**
     * Your AWS Bucket region.
     */
    region?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`.
     */
    secretKey?: string;
    tokenUri?: string;
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
     */
    type: string;
}

export interface ElbSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface ElbSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface ElbSourcePath {
    /**
     * The name of the bucket.
     */
    bucketName?: string;
    customServices?: outputs.ElbSourcePathCustomService[];
    limitToNamespaces?: string[];
    limitToRegions?: string[];
    limitToServices?: string[];
    /**
     * The path to the data.
     */
    pathExpression?: string;
    /**
     * This is a computed field for SNS topic/subscription ARN.
     */
    snsTopicOrSubscriptionArns: outputs.ElbSourcePathSnsTopicOrSubscriptionArn[];
    tagFilters?: outputs.ElbSourcePathTagFilter[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
     */
    type: string;
}

export interface ElbSourcePathCustomService {
    prefixes?: string[];
    serviceName?: string;
}

export interface ElbSourcePathSnsTopicOrSubscriptionArn {
    arn: string;
    isSuccess: boolean;
}

export interface ElbSourcePathTagFilter {
    namespace?: string;
    tags?: string[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
     */
    type?: string;
}

export interface GcpMetricsSourceAuthentication {
    accessKey?: string;
    /**
     * As per the service_account.json downloaded from GCP
     */
    authProviderX509CertUrl?: string;
    /**
     * As per the service_account.json downloaded from GCP
     */
    authUri?: string;
    /**
     * As per the service_account.json downloaded from GCP
     */
    clientEmail?: string;
    /**
     * As per the service_account.json downloaded from GCP
     */
    clientId?: string;
    /**
     * As per the service_account.json downloaded from GCP
     */
    clientX509CertUrl?: string;
    /**
     * As per the service_account.json downloaded from GCP
     */
    privateKey?: string;
    /**
     * As per the service_account.json downloaded from GCP
     */
    privateKeyId?: string;
    /**
     * As per the service_account.json downloaded from GCP
     */
    projectId?: string;
    region?: string;
    roleArn?: string;
    secretKey?: string;
    /**
     * As per the service_account.json downloaded from GCP
     */
    tokenUri?: string;
    /**
     * Type of polling source. This has to be `GcpMetricsPath`.
     */
    type: string;
}

export interface GcpMetricsSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface GcpMetricsSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface GcpMetricsSourcePath {
    bucketName?: string;
    /**
     * Sumoloigc provides list of services that can be used in limitToServices for which metrics would be collected. Custom Services allow you to define your own service w.r.t. metric collection. You can provide list of metric prefixes that should be collected as part of the custom service. This provides fine-grain control w.r.t. what all metrics are ingested by sumologic.
     */
    customServices?: outputs.GcpMetricsSourcePathCustomService[];
    limitToNamespaces?: string[];
    /**
     * List of regions for which metrics would be collected (Empty to collect from all regions)
     */
    limitToRegions?: string[];
    /**
     * List of services from which metrics would be collected
     */
    limitToServices?: string[];
    pathExpression?: string;
    snsTopicOrSubscriptionArns: outputs.GcpMetricsSourcePathSnsTopicOrSubscriptionArn[];
    tagFilters?: outputs.GcpMetricsSourcePathTagFilter[];
    /**
     * Type of polling source. This has to be `GcpMetricsPath`.
     */
    type: string;
}

export interface GcpMetricsSourcePathCustomService {
    /**
     * List of metric type prefixes. Eg: `["compute.googleapis.com/instance/","compute.googleapis.com/guest/"]`
     */
    prefixes?: string[];
    /**
     * Name of the custom service you want to define.
     */
    serviceName?: string;
}

export interface GcpMetricsSourcePathSnsTopicOrSubscriptionArn {
    arn: string;
    isSuccess: boolean;
}

export interface GcpMetricsSourcePathTagFilter {
    namespace?: string;
    tags?: string[];
    /**
     * Type of polling source. This has to be `GcpMetricsPath`.
     */
    type?: string;
}

export interface GcpSourceAuthentication {
    type?: string;
}

export interface GcpSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface GcpSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface GcpSourcePath {
    type?: string;
}

export interface HierarchyFilter {
    /**
     * Filtering key.
     */
    key: string;
    /**
     * Value required for the filtering key.
     */
    value: string;
}

export interface HierarchyLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Next level without a condition.
     */
    nextLevel?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition {
    /**
     * Condition to be checked against for level.entityType value, for now full string match.
     */
    condition: string;
    level: outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel;
}

export interface HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel {
    /**
     * Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
     */
    entityType: string;
    /**
     * Zero or more next levels with conditions.
     */
    nextLevelsWithConditions?: string[];
}

export interface HttpSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface HttpSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface KineisLogSourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`
     */
    accessKey?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`
     */
    secretKey?: string;
    /**
     * Must be either `KinesisLogPath` or `NoPathExpression`
     */
    type: string;
}

export interface KineisLogSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface KineisLogSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface KineisLogSourcePath {
    /**
     * The name of the bucket. This is needed if using type `KinesisLogPath`.
     */
    bucketName?: string;
    /**
     * The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must includes `http-endpoint-failed/`.
     */
    pathExpression?: string;
    /**
     * The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
     */
    scanInterval?: number;
    /**
     * Must be either `KinesisLogPath` or `NoPathExpression`
     */
    type: string;
}

export interface KinesisMetricsSourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`
     */
    accessKey?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`
     */
    secretKey?: string;
    /**
     * This value has to be set to `TagFilters`
     */
    type: string;
}

export interface KinesisMetricsSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface KinesisMetricsSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface KinesisMetricsSourcePath {
    /**
     * Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
     */
    tagFilters?: outputs.KinesisMetricsSourcePathTagFilter[];
    /**
     * This value has to be set to `TagFilters`
     */
    type: string;
}

export interface KinesisMetricsSourcePathTagFilter {
    /**
     * Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
     */
    namespace?: string;
    /**
     * List of key-value pairs of tag filters. Eg: `["k3=v3"]`
     */
    tags?: string[];
    /**
     * This value has to be set to `TagFilters`
     */
    type?: string;
}

export interface LookupTableField {
    fieldName: string;
    fieldType: string;
}

export interface MetadataSourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`
     */
    accessKey?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`
     */
    secretKey?: string;
    /**
     * type of polling source. Only allowed value is `AwsMetadataPath`.
     */
    type: string;
}

export interface MetadataSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface MetadataSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface MetadataSourcePath {
    /**
     * List of namespaces. For `AwsMetadataPath` the only valid namespace is `AWS/EC2`.
     */
    limitToNamespaces?: string[];
    /**
     * List of Amazon regions.
     */
    limitToRegions?: string[];
    /**
     * Leave this field blank to collect all tags configured for the EC2 instance. To collect a subset of tags, follow the instructions in [Define EC2 tag filters][2]
     */
    tagFilters?: string[];
    /**
     * type of polling source. Only allowed value is `AwsMetadataPath`.
     */
    type: string;
}

export interface MonitorNotification {
    notification: outputs.MonitorNotificationNotification;
    runForTriggerTypes: string[];
}

export interface MonitorNotificationNotification {
    /**
     * @deprecated The field `action_type` is deprecated and will be removed in a future release of the provider - please use `connection_type` instead.
     */
    actionType: string;
    connectionId?: string;
    connectionType: string;
    messageBody?: string;
    payloadOverride?: string;
    recipients?: string[];
    subject?: string;
    timeZone?: string;
}

export interface MonitorQuery {
    query: string;
    rowId: string;
}

export interface MonitorTrigger {
    detectionMethod?: string;
    occurrenceType?: string;
    threshold?: number;
    thresholdType?: string;
    timeRange?: string;
    triggerSource?: string;
    triggerType?: string;
}

export interface MonitorTriggerConditions {
    logsMissingDataCondition?: outputs.MonitorTriggerConditionsLogsMissingDataCondition;
    logsOutlierCondition?: outputs.MonitorTriggerConditionsLogsOutlierCondition;
    logsStaticCondition?: outputs.MonitorTriggerConditionsLogsStaticCondition;
    metricsMissingDataCondition?: outputs.MonitorTriggerConditionsMetricsMissingDataCondition;
    metricsOutlierCondition?: outputs.MonitorTriggerConditionsMetricsOutlierCondition;
    metricsStaticCondition?: outputs.MonitorTriggerConditionsMetricsStaticCondition;
}

export interface MonitorTriggerConditionsLogsMissingDataCondition {
    timeRange: string;
}

export interface MonitorTriggerConditionsLogsOutlierCondition {
    critical?: outputs.MonitorTriggerConditionsLogsOutlierConditionCritical;
    direction?: string;
    field?: string;
    warning?: outputs.MonitorTriggerConditionsLogsOutlierConditionWarning;
}

export interface MonitorTriggerConditionsLogsOutlierConditionCritical {
    consecutive?: number;
    threshold?: number;
    window?: number;
}

export interface MonitorTriggerConditionsLogsOutlierConditionWarning {
    consecutive?: number;
    threshold?: number;
    window?: number;
}

export interface MonitorTriggerConditionsLogsStaticCondition {
    critical?: outputs.MonitorTriggerConditionsLogsStaticConditionCritical;
    field?: string;
    warning?: outputs.MonitorTriggerConditionsLogsStaticConditionWarning;
}

export interface MonitorTriggerConditionsLogsStaticConditionCritical {
    alert: outputs.MonitorTriggerConditionsLogsStaticConditionCriticalAlert;
    resolution: outputs.MonitorTriggerConditionsLogsStaticConditionCriticalResolution;
    timeRange: string;
}

export interface MonitorTriggerConditionsLogsStaticConditionCriticalAlert {
    threshold?: number;
    thresholdType?: string;
}

export interface MonitorTriggerConditionsLogsStaticConditionCriticalResolution {
    threshold?: number;
    thresholdType?: string;
}

export interface MonitorTriggerConditionsLogsStaticConditionWarning {
    alert: outputs.MonitorTriggerConditionsLogsStaticConditionWarningAlert;
    resolution: outputs.MonitorTriggerConditionsLogsStaticConditionWarningResolution;
    timeRange: string;
}

export interface MonitorTriggerConditionsLogsStaticConditionWarningAlert {
    threshold?: number;
    thresholdType?: string;
}

export interface MonitorTriggerConditionsLogsStaticConditionWarningResolution {
    threshold?: number;
    thresholdType?: string;
}

export interface MonitorTriggerConditionsMetricsMissingDataCondition {
    timeRange: string;
    triggerSource: string;
}

export interface MonitorTriggerConditionsMetricsOutlierCondition {
    critical?: outputs.MonitorTriggerConditionsMetricsOutlierConditionCritical;
    direction?: string;
    warning?: outputs.MonitorTriggerConditionsMetricsOutlierConditionWarning;
}

export interface MonitorTriggerConditionsMetricsOutlierConditionCritical {
    baselineWindow?: string;
    threshold?: number;
}

export interface MonitorTriggerConditionsMetricsOutlierConditionWarning {
    baselineWindow?: string;
    threshold?: number;
}

export interface MonitorTriggerConditionsMetricsStaticCondition {
    critical?: outputs.MonitorTriggerConditionsMetricsStaticConditionCritical;
    warning?: outputs.MonitorTriggerConditionsMetricsStaticConditionWarning;
}

export interface MonitorTriggerConditionsMetricsStaticConditionCritical {
    alert: outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalAlert;
    occurrenceType: string;
    resolution: outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalResolution;
    timeRange: string;
}

export interface MonitorTriggerConditionsMetricsStaticConditionCriticalAlert {
    threshold?: number;
    thresholdType?: string;
}

export interface MonitorTriggerConditionsMetricsStaticConditionCriticalResolution {
    occurrenceType?: string;
    threshold?: number;
    thresholdType?: string;
}

export interface MonitorTriggerConditionsMetricsStaticConditionWarning {
    alert: outputs.MonitorTriggerConditionsMetricsStaticConditionWarningAlert;
    occurrenceType: string;
    resolution: outputs.MonitorTriggerConditionsMetricsStaticConditionWarningResolution;
    timeRange: string;
}

export interface MonitorTriggerConditionsMetricsStaticConditionWarningAlert {
    threshold?: number;
    thresholdType?: string;
}

export interface MonitorTriggerConditionsMetricsStaticConditionWarningResolution {
    occurrenceType?: string;
    threshold?: number;
    thresholdType?: string;
}

export interface PoliciesUserConcurrentSessionsLimit {
    /**
     * Whether the [User Concurrent Sessions Limit Policy](https://help.sumologic.com/Manage/Security/Set_a_Limit_for_User_Concurrent_Sessions) is enabled.
     */
    enabled: boolean;
    /**
     * Maximum number of concurrent sessions a user may have. Defaults to `100`.
     */
    maxConcurrentSessions?: number;
}

export interface PollingSourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`
     */
    accessKey?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`
     */
    secretKey?: string;
    /**
     * This value has to be set to `TagFilters`
     */
    type: string;
}

export interface PollingSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface PollingSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface PollingSourcePath {
    /**
     * The name of the bucket. This is needed if using type `S3BucketPathExpression`.
     */
    bucketName?: string;
    /**
     * List of namespaces to limit metrics collection. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace. This is a valid parameter if using type `CloudWatchPath`.
     */
    limitToNamespaces?: string[];
    /**
     * List of Amazon regions to limit metricscollection. This is a valid parameter if  using type `CloudWatchPath`.
     */
    limitToRegions?: string[];
    /**
     * The path to the data. This is needed if using type `S3BucketPathExpression`.
     */
    pathExpression?: string;
    /**
     * Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. This is a valid parameter if using type `CloudWatchPath` More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
     */
    tagFilters?: outputs.PollingSourcePathTagFilter[];
    /**
     * This value has to be set to `TagFilters`
     */
    type: string;
}

export interface PollingSourcePathTagFilter {
    /**
     * Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
     */
    namespace?: string;
    /**
     * List of key-value pairs of tag filters. Eg: `["k3=v3"]`
     */
    tags?: string[];
    /**
     * This value has to be set to `TagFilters`
     */
    type?: string;
}

export interface S3AuditSourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`.
     */
    accessKey?: string;
    authProviderX509CertUrl?: string;
    authUri?: string;
    clientEmail?: string;
    clientId?: string;
    clientX509CertUrl?: string;
    privateKey?: string;
    privateKeyId?: string;
    projectId?: string;
    /**
     * Your AWS Bucket region.
     */
    region?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`.
     */
    secretKey?: string;
    tokenUri?: string;
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
     */
    type: string;
}

export interface S3AuditSourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface S3AuditSourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface S3AuditSourcePath {
    /**
     * The name of the bucket.
     */
    bucketName?: string;
    customServices?: outputs.S3AuditSourcePathCustomService[];
    limitToNamespaces?: string[];
    limitToRegions?: string[];
    limitToServices?: string[];
    /**
     * The path to the data.
     */
    pathExpression?: string;
    /**
     * This is a computed field for SNS topic/subscription ARN.
     */
    snsTopicOrSubscriptionArns: outputs.S3AuditSourcePathSnsTopicOrSubscriptionArn[];
    tagFilters?: outputs.S3AuditSourcePathTagFilter[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
     */
    type: string;
}

export interface S3AuditSourcePathCustomService {
    prefixes?: string[];
    serviceName?: string;
}

export interface S3AuditSourcePathSnsTopicOrSubscriptionArn {
    arn: string;
    isSuccess: boolean;
}

export interface S3AuditSourcePathTagFilter {
    namespace?: string;
    tags?: string[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
     */
    type?: string;
}

export interface S3SourceAuthentication {
    /**
     * Your AWS access key if using type `S3BucketAuthentication`.
     */
    accessKey?: string;
    authProviderX509CertUrl?: string;
    authUri?: string;
    clientEmail?: string;
    clientId?: string;
    clientX509CertUrl?: string;
    privateKey?: string;
    privateKeyId?: string;
    projectId?: string;
    /**
     * Your AWS Bucket region.
     */
    region?: string;
    /**
     * Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
     */
    roleArn?: string;
    /**
     * Your AWS secret key if using type `S3BucketAuthentication`.
     */
    secretKey?: string;
    tokenUri?: string;
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
     */
    type: string;
}

export interface S3SourceDefaultDateFormat {
    format: string;
    locator?: string;
}

export interface S3SourceFilter {
    filterType: string;
    mask?: string;
    name: string;
    regexp: string;
}

export interface S3SourcePath {
    /**
     * The name of the bucket.
     */
    bucketName?: string;
    customServices?: outputs.S3SourcePathCustomService[];
    limitToNamespaces?: string[];
    limitToRegions?: string[];
    limitToServices?: string[];
    /**
     * The path to the data.
     */
    pathExpression?: string;
    /**
     * This is a computed field for SNS topic/subscription ARN.
     */
    snsTopicOrSubscriptionArns: outputs.S3SourcePathSnsTopicOrSubscriptionArn[];
    tagFilters?: outputs.S3SourcePathTagFilter[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
     */
    type: string;
}

export interface S3SourcePathCustomService {
    prefixes?: string[];
    serviceName?: string;
}

export interface S3SourcePathSnsTopicOrSubscriptionArn {
    arn: string;
    isSuccess: boolean;
}

export interface S3SourcePathTagFilter {
    namespace?: string;
    tags?: string[];
    /**
     * type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
     */
    type?: string;
}

export interface SamlConfigurationOnDemandProvisioningEnabled {
    /**
     * First name attribute of the new user account. Defaults to "".
     */
    firstNameAttribute?: string;
    /**
     * Last name attribute of the new user account. Defaults to "".
     */
    lastNameAttribute?: string;
    /**
     * List of Sumo Logic RBAC roles to be assigned when user accounts are provisioned.
     */
    onDemandProvisioningRoles: string[];
}

