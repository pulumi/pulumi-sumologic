# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities

__all__ = [
    'AwsInventorySourceAuthenticationArgs',
    'AwsInventorySourceAuthenticationArgsDict',
    'AwsInventorySourceDefaultDateFormatArgs',
    'AwsInventorySourceDefaultDateFormatArgsDict',
    'AwsInventorySourceFilterArgs',
    'AwsInventorySourceFilterArgsDict',
    'AwsInventorySourcePathArgs',
    'AwsInventorySourcePathArgsDict',
    'AwsInventorySourcePathCustomServiceArgs',
    'AwsInventorySourcePathCustomServiceArgsDict',
    'AwsInventorySourcePathSnsTopicOrSubscriptionArnArgs',
    'AwsInventorySourcePathSnsTopicOrSubscriptionArnArgsDict',
    'AwsInventorySourcePathTagFilterArgs',
    'AwsInventorySourcePathTagFilterArgsDict',
    'AwsXraySourceAuthenticationArgs',
    'AwsXraySourceAuthenticationArgsDict',
    'AwsXraySourceDefaultDateFormatArgs',
    'AwsXraySourceDefaultDateFormatArgsDict',
    'AwsXraySourceFilterArgs',
    'AwsXraySourceFilterArgsDict',
    'AwsXraySourcePathArgs',
    'AwsXraySourcePathArgsDict',
    'AwsXraySourcePathCustomServiceArgs',
    'AwsXraySourcePathCustomServiceArgsDict',
    'AwsXraySourcePathSnsTopicOrSubscriptionArnArgs',
    'AwsXraySourcePathSnsTopicOrSubscriptionArnArgsDict',
    'AwsXraySourcePathTagFilterArgs',
    'AwsXraySourcePathTagFilterArgsDict',
    'AzureEventHubLogSourceAuthenticationArgs',
    'AzureEventHubLogSourceAuthenticationArgsDict',
    'AzureEventHubLogSourceDefaultDateFormatArgs',
    'AzureEventHubLogSourceDefaultDateFormatArgsDict',
    'AzureEventHubLogSourceFilterArgs',
    'AzureEventHubLogSourceFilterArgsDict',
    'AzureEventHubLogSourcePathArgs',
    'AzureEventHubLogSourcePathArgsDict',
    'AzureEventHubLogSourcePathCustomServiceArgs',
    'AzureEventHubLogSourcePathCustomServiceArgsDict',
    'AzureEventHubLogSourcePathSnsTopicOrSubscriptionArnArgs',
    'AzureEventHubLogSourcePathSnsTopicOrSubscriptionArnArgsDict',
    'AzureEventHubLogSourcePathTagFilterArgs',
    'AzureEventHubLogSourcePathTagFilterArgsDict',
    'CloudSyslogSourceDefaultDateFormatArgs',
    'CloudSyslogSourceDefaultDateFormatArgsDict',
    'CloudSyslogSourceFilterArgs',
    'CloudSyslogSourceFilterArgsDict',
    'CloudfrontSourceAuthenticationArgs',
    'CloudfrontSourceAuthenticationArgsDict',
    'CloudfrontSourceDefaultDateFormatArgs',
    'CloudfrontSourceDefaultDateFormatArgsDict',
    'CloudfrontSourceFilterArgs',
    'CloudfrontSourceFilterArgsDict',
    'CloudfrontSourcePathArgs',
    'CloudfrontSourcePathArgsDict',
    'CloudfrontSourcePathCustomServiceArgs',
    'CloudfrontSourcePathCustomServiceArgsDict',
    'CloudfrontSourcePathSnsTopicOrSubscriptionArnArgs',
    'CloudfrontSourcePathSnsTopicOrSubscriptionArnArgsDict',
    'CloudfrontSourcePathTagFilterArgs',
    'CloudfrontSourcePathTagFilterArgsDict',
    'CloudtrailSourceAuthenticationArgs',
    'CloudtrailSourceAuthenticationArgsDict',
    'CloudtrailSourceDefaultDateFormatArgs',
    'CloudtrailSourceDefaultDateFormatArgsDict',
    'CloudtrailSourceFilterArgs',
    'CloudtrailSourceFilterArgsDict',
    'CloudtrailSourcePathArgs',
    'CloudtrailSourcePathArgsDict',
    'CloudtrailSourcePathCustomServiceArgs',
    'CloudtrailSourcePathCustomServiceArgsDict',
    'CloudtrailSourcePathSnsTopicOrSubscriptionArnArgs',
    'CloudtrailSourcePathSnsTopicOrSubscriptionArnArgsDict',
    'CloudtrailSourcePathTagFilterArgs',
    'CloudtrailSourcePathTagFilterArgsDict',
    'CloudwatchSourceAuthenticationArgs',
    'CloudwatchSourceAuthenticationArgsDict',
    'CloudwatchSourceDefaultDateFormatArgs',
    'CloudwatchSourceDefaultDateFormatArgsDict',
    'CloudwatchSourceFilterArgs',
    'CloudwatchSourceFilterArgsDict',
    'CloudwatchSourcePathArgs',
    'CloudwatchSourcePathArgsDict',
    'CloudwatchSourcePathCustomServiceArgs',
    'CloudwatchSourcePathCustomServiceArgsDict',
    'CloudwatchSourcePathSnsTopicOrSubscriptionArnArgs',
    'CloudwatchSourcePathSnsTopicOrSubscriptionArnArgsDict',
    'CloudwatchSourcePathTagFilterArgs',
    'CloudwatchSourcePathTagFilterArgsDict',
    'ContentPermissionPermissionArgs',
    'ContentPermissionPermissionArgsDict',
    'CseAggregationRuleAggregationFunctionArgs',
    'CseAggregationRuleAggregationFunctionArgsDict',
    'CseAggregationRuleEntitySelectorArgs',
    'CseAggregationRuleEntitySelectorArgsDict',
    'CseAggregationRuleSeverityMappingArgs',
    'CseAggregationRuleSeverityMappingArgsDict',
    'CseAggregationRuleSeverityMappingMappingArgs',
    'CseAggregationRuleSeverityMappingMappingArgsDict',
    'CseChainRuleEntitySelectorArgs',
    'CseChainRuleEntitySelectorArgsDict',
    'CseChainRuleExpressionsAndLimitArgs',
    'CseChainRuleExpressionsAndLimitArgsDict',
    'CseCustomInsightDynamicSeverityArgs',
    'CseCustomInsightDynamicSeverityArgsDict',
    'CseEntityNormalizationConfigurationDomainMappingArgs',
    'CseEntityNormalizationConfigurationDomainMappingArgsDict',
    'CseFirstSeenRuleEntitySelectorArgs',
    'CseFirstSeenRuleEntitySelectorArgsDict',
    'CseLogMappingFieldArgs',
    'CseLogMappingFieldArgsDict',
    'CseLogMappingFieldLookupArgs',
    'CseLogMappingFieldLookupArgsDict',
    'CseLogMappingStructuredInputArgs',
    'CseLogMappingStructuredInputArgsDict',
    'CseLogMappingUnstructuredFieldsArgs',
    'CseLogMappingUnstructuredFieldsArgsDict',
    'CseMatchListItemArgs',
    'CseMatchListItemArgsDict',
    'CseMatchRuleEntitySelectorArgs',
    'CseMatchRuleEntitySelectorArgsDict',
    'CseMatchRuleSeverityMappingArgs',
    'CseMatchRuleSeverityMappingArgsDict',
    'CseMatchRuleSeverityMappingMappingArgs',
    'CseMatchRuleSeverityMappingMappingArgsDict',
    'CseOutlierRuleAggregationFunctionsArgs',
    'CseOutlierRuleAggregationFunctionsArgsDict',
    'CseOutlierRuleEntitySelectorArgs',
    'CseOutlierRuleEntitySelectorArgsDict',
    'CseTagSchemaValueOptionArgs',
    'CseTagSchemaValueOptionArgsDict',
    'CseThresholdRuleEntitySelectorArgs',
    'CseThresholdRuleEntitySelectorArgsDict',
    'DashboardColoringRuleArgs',
    'DashboardColoringRuleArgsDict',
    'DashboardColoringRuleColorThresholdArgs',
    'DashboardColoringRuleColorThresholdArgsDict',
    'DashboardLayoutArgs',
    'DashboardLayoutArgsDict',
    'DashboardLayoutGridArgs',
    'DashboardLayoutGridArgsDict',
    'DashboardLayoutGridLayoutStructureArgs',
    'DashboardLayoutGridLayoutStructureArgsDict',
    'DashboardPanelArgs',
    'DashboardPanelArgsDict',
    'DashboardPanelServiceMapPanelArgs',
    'DashboardPanelServiceMapPanelArgsDict',
    'DashboardPanelSumoSearchPanelArgs',
    'DashboardPanelSumoSearchPanelArgsDict',
    'DashboardPanelSumoSearchPanelColoringRuleArgs',
    'DashboardPanelSumoSearchPanelColoringRuleArgsDict',
    'DashboardPanelSumoSearchPanelColoringRuleColorThresholdArgs',
    'DashboardPanelSumoSearchPanelColoringRuleColorThresholdArgsDict',
    'DashboardPanelSumoSearchPanelLinkedDashboardArgs',
    'DashboardPanelSumoSearchPanelLinkedDashboardArgsDict',
    'DashboardPanelSumoSearchPanelQueryArgs',
    'DashboardPanelSumoSearchPanelQueryArgsDict',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataArgs',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataArgsDict',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilterArgs',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilterArgsDict',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorArgs',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorArgsDict',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameterArgs',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameterArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict',
    'DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRangeArgs',
    'DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRangeArgsDict',
    'DashboardPanelTextPanelArgs',
    'DashboardPanelTextPanelArgsDict',
    'DashboardPanelTracesListPanelArgs',
    'DashboardPanelTracesListPanelArgsDict',
    'DashboardPanelTracesListPanelQueryArgs',
    'DashboardPanelTracesListPanelQueryArgsDict',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataArgs',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataArgsDict',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataFilterArgs',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataFilterArgsDict',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorArgs',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorArgsDict',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameterArgs',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameterArgsDict',
    'DashboardPanelTracesListPanelTimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict',
    'DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRangeArgs',
    'DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRangeArgsDict',
    'DashboardTimeRangeArgs',
    'DashboardTimeRangeArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeFromArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeFromArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeToArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeToArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict',
    'DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs',
    'DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict',
    'DashboardTimeRangeCompleteLiteralTimeRangeArgs',
    'DashboardTimeRangeCompleteLiteralTimeRangeArgsDict',
    'DashboardTopologyLabelMapArgs',
    'DashboardTopologyLabelMapArgsDict',
    'DashboardTopologyLabelMapDataArgs',
    'DashboardTopologyLabelMapDataArgsDict',
    'DashboardVariableArgs',
    'DashboardVariableArgsDict',
    'DashboardVariableSourceDefinitionArgs',
    'DashboardVariableSourceDefinitionArgsDict',
    'DashboardVariableSourceDefinitionCsvVariableSourceDefinitionArgs',
    'DashboardVariableSourceDefinitionCsvVariableSourceDefinitionArgsDict',
    'DashboardVariableSourceDefinitionLogQueryVariableSourceDefinitionArgs',
    'DashboardVariableSourceDefinitionLogQueryVariableSourceDefinitionArgsDict',
    'DashboardVariableSourceDefinitionMetadataVariableSourceDefinitionArgs',
    'DashboardVariableSourceDefinitionMetadataVariableSourceDefinitionArgsDict',
    'DataForwardingDestinationAuthenticationArgs',
    'DataForwardingDestinationAuthenticationArgsDict',
    'ElbSourceAuthenticationArgs',
    'ElbSourceAuthenticationArgsDict',
    'ElbSourceDefaultDateFormatArgs',
    'ElbSourceDefaultDateFormatArgsDict',
    'ElbSourceFilterArgs',
    'ElbSourceFilterArgsDict',
    'ElbSourcePathArgs',
    'ElbSourcePathArgsDict',
    'ElbSourcePathCustomServiceArgs',
    'ElbSourcePathCustomServiceArgsDict',
    'ElbSourcePathSnsTopicOrSubscriptionArnArgs',
    'ElbSourcePathSnsTopicOrSubscriptionArnArgsDict',
    'ElbSourcePathTagFilterArgs',
    'ElbSourcePathTagFilterArgsDict',
    'GcpMetricsSourceAuthenticationArgs',
    'GcpMetricsSourceAuthenticationArgsDict',
    'GcpMetricsSourceDefaultDateFormatArgs',
    'GcpMetricsSourceDefaultDateFormatArgsDict',
    'GcpMetricsSourceFilterArgs',
    'GcpMetricsSourceFilterArgsDict',
    'GcpMetricsSourcePathArgs',
    'GcpMetricsSourcePathArgsDict',
    'GcpMetricsSourcePathCustomServiceArgs',
    'GcpMetricsSourcePathCustomServiceArgsDict',
    'GcpMetricsSourcePathSnsTopicOrSubscriptionArnArgs',
    'GcpMetricsSourcePathSnsTopicOrSubscriptionArnArgsDict',
    'GcpMetricsSourcePathTagFilterArgs',
    'GcpMetricsSourcePathTagFilterArgsDict',
    'GcpSourceAuthenticationArgs',
    'GcpSourceAuthenticationArgsDict',
    'GcpSourceDefaultDateFormatArgs',
    'GcpSourceDefaultDateFormatArgsDict',
    'GcpSourceFilterArgs',
    'GcpSourceFilterArgsDict',
    'GcpSourcePathArgs',
    'GcpSourcePathArgsDict',
    'HierarchyFilterArgs',
    'HierarchyFilterArgsDict',
    'HierarchyLevelArgs',
    'HierarchyLevelArgsDict',
    'HierarchyLevelNextLevelArgs',
    'HierarchyLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict',
    'HttpSourceDefaultDateFormatArgs',
    'HttpSourceDefaultDateFormatArgsDict',
    'HttpSourceFilterArgs',
    'HttpSourceFilterArgsDict',
    'KineisLogSourceAuthenticationArgs',
    'KineisLogSourceAuthenticationArgsDict',
    'KineisLogSourceDefaultDateFormatArgs',
    'KineisLogSourceDefaultDateFormatArgsDict',
    'KineisLogSourceFilterArgs',
    'KineisLogSourceFilterArgsDict',
    'KineisLogSourcePathArgs',
    'KineisLogSourcePathArgsDict',
    'KinesisLogSourceAuthenticationArgs',
    'KinesisLogSourceAuthenticationArgsDict',
    'KinesisLogSourceDefaultDateFormatArgs',
    'KinesisLogSourceDefaultDateFormatArgsDict',
    'KinesisLogSourceFilterArgs',
    'KinesisLogSourceFilterArgsDict',
    'KinesisLogSourcePathArgs',
    'KinesisLogSourcePathArgsDict',
    'KinesisMetricsSourceAuthenticationArgs',
    'KinesisMetricsSourceAuthenticationArgsDict',
    'KinesisMetricsSourceDefaultDateFormatArgs',
    'KinesisMetricsSourceDefaultDateFormatArgsDict',
    'KinesisMetricsSourceFilterArgs',
    'KinesisMetricsSourceFilterArgsDict',
    'KinesisMetricsSourcePathArgs',
    'KinesisMetricsSourcePathArgsDict',
    'KinesisMetricsSourcePathTagFilterArgs',
    'KinesisMetricsSourcePathTagFilterArgsDict',
    'LocalFileSourceDefaultDateFormatArgs',
    'LocalFileSourceDefaultDateFormatArgsDict',
    'LocalFileSourceFilterArgs',
    'LocalFileSourceFilterArgsDict',
    'LogSearchQueryParameterArgs',
    'LogSearchQueryParameterArgsDict',
    'LogSearchScheduleArgs',
    'LogSearchScheduleArgsDict',
    'LogSearchScheduleNotificationArgs',
    'LogSearchScheduleNotificationArgsDict',
    'LogSearchScheduleNotificationAlertSearchNotificationArgs',
    'LogSearchScheduleNotificationAlertSearchNotificationArgsDict',
    'LogSearchScheduleNotificationCseSignalNotificationArgs',
    'LogSearchScheduleNotificationCseSignalNotificationArgsDict',
    'LogSearchScheduleNotificationEmailSearchNotificationArgs',
    'LogSearchScheduleNotificationEmailSearchNotificationArgsDict',
    'LogSearchScheduleNotificationSaveToLookupNotificationArgs',
    'LogSearchScheduleNotificationSaveToLookupNotificationArgsDict',
    'LogSearchScheduleNotificationSaveToViewNotificationArgs',
    'LogSearchScheduleNotificationSaveToViewNotificationArgsDict',
    'LogSearchScheduleNotificationServiceNowSearchNotificationArgs',
    'LogSearchScheduleNotificationServiceNowSearchNotificationArgsDict',
    'LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgs',
    'LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgsDict',
    'LogSearchScheduleNotificationWebhookSearchNotificationArgs',
    'LogSearchScheduleNotificationWebhookSearchNotificationArgsDict',
    'LogSearchScheduleParameterArgs',
    'LogSearchScheduleParameterArgsDict',
    'LogSearchScheduleParseableTimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict',
    'LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgs',
    'LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgsDict',
    'LogSearchScheduleThresholdArgs',
    'LogSearchScheduleThresholdArgsDict',
    'LogSearchTimeRangeArgs',
    'LogSearchTimeRangeArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeToArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeToArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict',
    'LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs',
    'LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict',
    'LogSearchTimeRangeCompleteLiteralTimeRangeArgs',
    'LogSearchTimeRangeCompleteLiteralTimeRangeArgsDict',
    'LookupTableFieldArgs',
    'LookupTableFieldArgsDict',
    'MetadataSourceAuthenticationArgs',
    'MetadataSourceAuthenticationArgsDict',
    'MetadataSourceDefaultDateFormatArgs',
    'MetadataSourceDefaultDateFormatArgsDict',
    'MetadataSourceFilterArgs',
    'MetadataSourceFilterArgsDict',
    'MetadataSourcePathArgs',
    'MetadataSourcePathArgsDict',
    'MetricsSearchMetricsQueryArgs',
    'MetricsSearchMetricsQueryArgsDict',
    'MetricsSearchTimeRangeArgs',
    'MetricsSearchTimeRangeArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict',
    'MetricsSearchTimeRangeCompleteLiteralTimeRangeArgs',
    'MetricsSearchTimeRangeCompleteLiteralTimeRangeArgsDict',
    'MonitorFolderObjPermissionArgs',
    'MonitorFolderObjPermissionArgsDict',
    'MonitorNotificationArgs',
    'MonitorNotificationArgsDict',
    'MonitorNotificationNotificationArgs',
    'MonitorNotificationNotificationArgsDict',
    'MonitorObjPermissionArgs',
    'MonitorObjPermissionArgsDict',
    'MonitorQueryArgs',
    'MonitorQueryArgsDict',
    'MonitorTriggerArgs',
    'MonitorTriggerArgsDict',
    'MonitorTriggerConditionsArgs',
    'MonitorTriggerConditionsArgsDict',
    'MonitorTriggerConditionsLogsAnomalyConditionArgs',
    'MonitorTriggerConditionsLogsAnomalyConditionArgsDict',
    'MonitorTriggerConditionsLogsAnomalyConditionCriticalArgs',
    'MonitorTriggerConditionsLogsAnomalyConditionCriticalArgsDict',
    'MonitorTriggerConditionsLogsMissingDataConditionArgs',
    'MonitorTriggerConditionsLogsMissingDataConditionArgsDict',
    'MonitorTriggerConditionsLogsOutlierConditionArgs',
    'MonitorTriggerConditionsLogsOutlierConditionArgsDict',
    'MonitorTriggerConditionsLogsOutlierConditionCriticalArgs',
    'MonitorTriggerConditionsLogsOutlierConditionCriticalArgsDict',
    'MonitorTriggerConditionsLogsOutlierConditionWarningArgs',
    'MonitorTriggerConditionsLogsOutlierConditionWarningArgsDict',
    'MonitorTriggerConditionsLogsStaticConditionArgs',
    'MonitorTriggerConditionsLogsStaticConditionArgsDict',
    'MonitorTriggerConditionsLogsStaticConditionCriticalArgs',
    'MonitorTriggerConditionsLogsStaticConditionCriticalArgsDict',
    'MonitorTriggerConditionsLogsStaticConditionCriticalAlertArgs',
    'MonitorTriggerConditionsLogsStaticConditionCriticalAlertArgsDict',
    'MonitorTriggerConditionsLogsStaticConditionCriticalResolutionArgs',
    'MonitorTriggerConditionsLogsStaticConditionCriticalResolutionArgsDict',
    'MonitorTriggerConditionsLogsStaticConditionWarningArgs',
    'MonitorTriggerConditionsLogsStaticConditionWarningArgsDict',
    'MonitorTriggerConditionsLogsStaticConditionWarningAlertArgs',
    'MonitorTriggerConditionsLogsStaticConditionWarningAlertArgsDict',
    'MonitorTriggerConditionsLogsStaticConditionWarningResolutionArgs',
    'MonitorTriggerConditionsLogsStaticConditionWarningResolutionArgsDict',
    'MonitorTriggerConditionsMetricsMissingDataConditionArgs',
    'MonitorTriggerConditionsMetricsMissingDataConditionArgsDict',
    'MonitorTriggerConditionsMetricsOutlierConditionArgs',
    'MonitorTriggerConditionsMetricsOutlierConditionArgsDict',
    'MonitorTriggerConditionsMetricsOutlierConditionCriticalArgs',
    'MonitorTriggerConditionsMetricsOutlierConditionCriticalArgsDict',
    'MonitorTriggerConditionsMetricsOutlierConditionWarningArgs',
    'MonitorTriggerConditionsMetricsOutlierConditionWarningArgsDict',
    'MonitorTriggerConditionsMetricsStaticConditionArgs',
    'MonitorTriggerConditionsMetricsStaticConditionArgsDict',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalArgs',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalArgsDict',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalAlertArgs',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalAlertArgsDict',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalResolutionArgs',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalResolutionArgsDict',
    'MonitorTriggerConditionsMetricsStaticConditionWarningArgs',
    'MonitorTriggerConditionsMetricsStaticConditionWarningArgsDict',
    'MonitorTriggerConditionsMetricsStaticConditionWarningAlertArgs',
    'MonitorTriggerConditionsMetricsStaticConditionWarningAlertArgsDict',
    'MonitorTriggerConditionsMetricsStaticConditionWarningResolutionArgs',
    'MonitorTriggerConditionsMetricsStaticConditionWarningResolutionArgsDict',
    'MonitorTriggerConditionsSloBurnRateConditionArgs',
    'MonitorTriggerConditionsSloBurnRateConditionArgsDict',
    'MonitorTriggerConditionsSloBurnRateConditionCriticalArgs',
    'MonitorTriggerConditionsSloBurnRateConditionCriticalArgsDict',
    'MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgs',
    'MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgsDict',
    'MonitorTriggerConditionsSloBurnRateConditionWarningArgs',
    'MonitorTriggerConditionsSloBurnRateConditionWarningArgsDict',
    'MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgs',
    'MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgsDict',
    'MonitorTriggerConditionsSloSliConditionArgs',
    'MonitorTriggerConditionsSloSliConditionArgsDict',
    'MonitorTriggerConditionsSloSliConditionCriticalArgs',
    'MonitorTriggerConditionsSloSliConditionCriticalArgsDict',
    'MonitorTriggerConditionsSloSliConditionWarningArgs',
    'MonitorTriggerConditionsSloSliConditionWarningArgsDict',
    'MutingScheduleMonitorArgs',
    'MutingScheduleMonitorArgsDict',
    'MutingScheduleNotificationGroupArgs',
    'MutingScheduleNotificationGroupArgsDict',
    'MutingScheduleScheduleArgs',
    'MutingScheduleScheduleArgsDict',
    'PoliciesUserConcurrentSessionsLimitArgs',
    'PoliciesUserConcurrentSessionsLimitArgsDict',
    'PollingSourceAuthenticationArgs',
    'PollingSourceAuthenticationArgsDict',
    'PollingSourceDefaultDateFormatArgs',
    'PollingSourceDefaultDateFormatArgsDict',
    'PollingSourceFilterArgs',
    'PollingSourceFilterArgsDict',
    'PollingSourcePathArgs',
    'PollingSourcePathArgsDict',
    'PollingSourcePathTagFilterArgs',
    'PollingSourcePathTagFilterArgsDict',
    'RoleV2SelectedViewArgs',
    'RoleV2SelectedViewArgsDict',
    'RumSourceDefaultDateFormatArgs',
    'RumSourceDefaultDateFormatArgsDict',
    'RumSourceFilterArgs',
    'RumSourceFilterArgsDict',
    'RumSourcePathArgs',
    'RumSourcePathArgsDict',
    'S3ArchiveSourceAuthenticationArgs',
    'S3ArchiveSourceAuthenticationArgsDict',
    'S3ArchiveSourceDefaultDateFormatArgs',
    'S3ArchiveSourceDefaultDateFormatArgsDict',
    'S3ArchiveSourceFilterArgs',
    'S3ArchiveSourceFilterArgsDict',
    'S3ArchiveSourcePathArgs',
    'S3ArchiveSourcePathArgsDict',
    'S3ArchiveSourcePathCustomServiceArgs',
    'S3ArchiveSourcePathCustomServiceArgsDict',
    'S3ArchiveSourcePathSnsTopicOrSubscriptionArnArgs',
    'S3ArchiveSourcePathSnsTopicOrSubscriptionArnArgsDict',
    'S3ArchiveSourcePathTagFilterArgs',
    'S3ArchiveSourcePathTagFilterArgsDict',
    'S3AuditSourceAuthenticationArgs',
    'S3AuditSourceAuthenticationArgsDict',
    'S3AuditSourceDefaultDateFormatArgs',
    'S3AuditSourceDefaultDateFormatArgsDict',
    'S3AuditSourceFilterArgs',
    'S3AuditSourceFilterArgsDict',
    'S3AuditSourcePathArgs',
    'S3AuditSourcePathArgsDict',
    'S3AuditSourcePathCustomServiceArgs',
    'S3AuditSourcePathCustomServiceArgsDict',
    'S3AuditSourcePathSnsTopicOrSubscriptionArnArgs',
    'S3AuditSourcePathSnsTopicOrSubscriptionArnArgsDict',
    'S3AuditSourcePathTagFilterArgs',
    'S3AuditSourcePathTagFilterArgsDict',
    'S3SourceAuthenticationArgs',
    'S3SourceAuthenticationArgsDict',
    'S3SourceDefaultDateFormatArgs',
    'S3SourceDefaultDateFormatArgsDict',
    'S3SourceFilterArgs',
    'S3SourceFilterArgsDict',
    'S3SourcePathArgs',
    'S3SourcePathArgsDict',
    'S3SourcePathCustomServiceArgs',
    'S3SourcePathCustomServiceArgsDict',
    'S3SourcePathSnsTopicOrSubscriptionArnArgs',
    'S3SourcePathSnsTopicOrSubscriptionArnArgsDict',
    'S3SourcePathTagFilterArgs',
    'S3SourcePathTagFilterArgsDict',
    'SamlConfigurationOnDemandProvisioningEnabledArgs',
    'SamlConfigurationOnDemandProvisioningEnabledArgsDict',
    'SloComplianceArgs',
    'SloComplianceArgsDict',
    'SloIndicatorArgs',
    'SloIndicatorArgsDict',
    'SloIndicatorMonitorBasedEvaluationArgs',
    'SloIndicatorMonitorBasedEvaluationArgsDict',
    'SloIndicatorMonitorBasedEvaluationMonitorTriggersArgs',
    'SloIndicatorMonitorBasedEvaluationMonitorTriggersArgsDict',
    'SloIndicatorRequestBasedEvaluationArgs',
    'SloIndicatorRequestBasedEvaluationArgsDict',
    'SloIndicatorRequestBasedEvaluationQueryArgs',
    'SloIndicatorRequestBasedEvaluationQueryArgsDict',
    'SloIndicatorRequestBasedEvaluationQueryQueryGroupArgs',
    'SloIndicatorRequestBasedEvaluationQueryQueryGroupArgsDict',
    'SloIndicatorWindowBasedEvaluationArgs',
    'SloIndicatorWindowBasedEvaluationArgsDict',
    'SloIndicatorWindowBasedEvaluationQueryArgs',
    'SloIndicatorWindowBasedEvaluationQueryArgsDict',
    'SloIndicatorWindowBasedEvaluationQueryQueryGroupArgs',
    'SloIndicatorWindowBasedEvaluationQueryQueryGroupArgsDict',
]

MYPY = False

if not MYPY:
    class AwsInventorySourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be `AWSRoleBasedAuthentication`
        """
        access_key: NotRequired[pulumi.Input[str]]
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN. More details [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Grant-Access-to-an-AWS-Product#iam-role).
        """
        secret_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    AwsInventorySourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsInventorySourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] role_arn: Your AWS role ARN. More details [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Grant-Access-to-an-AWS-Product#iam-role).
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN. More details [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Grant-Access-to-an-AWS-Product#iam-role).
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class AwsInventorySourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    AwsInventorySourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsInventorySourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class AwsInventorySourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    AwsInventorySourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsInventorySourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class AwsInventorySourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of namespaces. By default all namespaces are selected. You can also choose a subset from
        + AWS/EC2
        + AWS/AutoScaling
        + AWS/EBS
        + AWS/ELB
        + AWS/ApplicationELB
        + AWS/NetworkELB
        + AWS/Lambda
        + AWS/RDS
        + AWS/Dynamodb
        + AWS/ECS
        + AWS/Elasticache
        + AWS/Redshift
        + AWS/Kinesis
        """
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Amazon regions.
        """
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        path_expression: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    AwsInventorySourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsInventorySourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_namespaces: List of namespaces. By default all namespaces are selected. You can also choose a subset from
               + AWS/EC2
               + AWS/AutoScaling
               + AWS/EBS
               + AWS/ELB
               + AWS/ApplicationELB
               + AWS/NetworkELB
               + AWS/Lambda
               + AWS/RDS
               + AWS/Dynamodb
               + AWS/ECS
               + AWS/Elasticache
               + AWS/Redshift
               + AWS/Kinesis
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_regions: List of Amazon regions.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of namespaces. By default all namespaces are selected. You can also choose a subset from
        + AWS/EC2
        + AWS/AutoScaling
        + AWS/EBS
        + AWS/ELB
        + AWS/ApplicationELB
        + AWS/NetworkELB
        + AWS/Lambda
        + AWS/RDS
        + AWS/Dynamodb
        + AWS/ECS
        + AWS/Elasticache
        + AWS/Redshift
        + AWS/Kinesis
        """
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AwsInventorySourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class AwsInventorySourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    AwsInventorySourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsInventorySourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class AwsInventorySourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    AwsInventorySourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsInventorySourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class AwsInventorySourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    AwsInventorySourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsInventorySourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AwsXraySourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    AwsXraySourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsXraySourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class AwsXraySourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    AwsXraySourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsXraySourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class AwsXraySourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    AwsXraySourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsXraySourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class AwsXraySourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Amazon regions.
        """
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        path_expression: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    AwsXraySourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsXraySourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_regions: List of Amazon regions.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AwsXraySourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class AwsXraySourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    AwsXraySourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsXraySourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class AwsXraySourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    AwsXraySourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsXraySourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class AwsXraySourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    AwsXraySourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AwsXraySourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AzureEventHubLogSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be `AzureEventHubAuthentication`.
        """
        access_key: NotRequired[pulumi.Input[str]]
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        secret_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        """
        Your shared access policy key.
        """
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        """
        Your shared access policy name.
        """
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    AzureEventHubLogSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureEventHubLogSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be `AzureEventHubAuthentication`.
        :param pulumi.Input[str] region: The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        :param pulumi.Input[str] shared_access_policy_key: Your shared access policy key.
        :param pulumi.Input[str] shared_access_policy_name: Your shared access policy name.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be `AzureEventHubAuthentication`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your shared access policy key.
        """
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        """
        Your shared access policy name.
        """
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class AzureEventHubLogSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    AzureEventHubLogSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureEventHubLogSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class AzureEventHubLogSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    AzureEventHubLogSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureEventHubLogSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class AzureEventHubLogSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be `AzureEventHubPath`.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        consumer_group: NotRequired[pulumi.Input[str]]
        """
        The consumer group of the event hub.
        """
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        """
        The name of the event hub.
        """
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        """
        The namespace of the event hub.
        """
        path_expression: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        """
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    AzureEventHubLogSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureEventHubLogSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: Must be `AzureEventHubPath`.
        :param pulumi.Input[str] consumer_group: The consumer group of the event hub.
        :param pulumi.Input[str] event_hub_name: The name of the event hub.
        :param pulumi.Input[str] namespace: The namespace of the event hub.
        :param pulumi.Input[str] region: The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be `AzureEventHubPath`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        """
        The consumer group of the event hub.
        """
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the event hub.
        """
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace of the event hub.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AzureEventHubLogSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class AzureEventHubLogSourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    AzureEventHubLogSourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureEventHubLogSourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class AzureEventHubLogSourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    AzureEventHubLogSourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureEventHubLogSourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class AzureEventHubLogSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        """
        The namespace of the event hub.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    AzureEventHubLogSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AzureEventHubLogSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespace: The namespace of the event hub.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The namespace of the event hub.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CloudSyslogSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    CloudSyslogSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudSyslogSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class CloudSyslogSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    CloudSyslogSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudSyslogSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class CloudfrontSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    CloudfrontSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudfrontSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class CloudfrontSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    CloudfrontSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudfrontSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class CloudfrontSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    CloudfrontSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudfrontSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class CloudfrontSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        """
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        path_expression: NotRequired[pulumi.Input[str]]
        """
        The path to the data. This is needed if using type `S3BucketPathExpression`.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    CloudfrontSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudfrontSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        :param pulumi.Input[str] bucket_name: The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        :param pulumi.Input[str] path_expression: The path to the data. This is needed if using type `S3BucketPathExpression`.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathSnsTopicOrSubscriptionArnArgs']]] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the data. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudfrontSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class CloudfrontSourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    CloudfrontSourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudfrontSourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class CloudfrontSourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    CloudfrontSourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudfrontSourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class CloudfrontSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    CloudfrontSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudfrontSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CloudtrailSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    CloudtrailSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudtrailSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class CloudtrailSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    CloudtrailSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudtrailSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class CloudtrailSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    CloudtrailSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudtrailSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class CloudtrailSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the bucket.
        """
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        path_expression: NotRequired[pulumi.Input[str]]
        """
        The path to the data.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    CloudtrailSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudtrailSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        :param pulumi.Input[str] bucket_name: The name of the bucket.
        :param pulumi.Input[str] path_expression: The path to the data.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathSnsTopicOrSubscriptionArnArgs']]] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudtrailSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class CloudtrailSourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    CloudtrailSourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudtrailSourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class CloudtrailSourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    CloudtrailSourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudtrailSourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class CloudtrailSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    CloudtrailSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudtrailSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CloudwatchSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    CloudwatchSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwatchSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class CloudwatchSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    CloudwatchSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwatchSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class CloudwatchSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    CloudwatchSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwatchSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class CloudwatchSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. This has to be `CloudWatchPath` for CloudWatch source.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of namespaces. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace.
        """
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Amazon regions.
        """
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        path_expression: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathTagFilterArgsDict']]]]
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    CloudwatchSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwatchSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. This has to be `CloudWatchPath` for CloudWatch source.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_namespaces: List of namespaces. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_regions: List of Amazon regions.
        :param pulumi.Input[str] namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathTagFilterArgs']]] tag_filters: Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. This has to be `CloudWatchPath` for CloudWatch source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of namespaces. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace.
        """
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathTagFilterArgs']]]]:
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CloudwatchSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class CloudwatchSourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    CloudwatchSourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwatchSourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class CloudwatchSourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    CloudwatchSourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwatchSourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class CloudwatchSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        This value has to be set to `TagFilters`
        """
elif False:
    CloudwatchSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CloudwatchSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        :param pulumi.Input[str] type: This value has to be set to `TagFilters`
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ContentPermissionPermissionArgsDict(TypedDict):
        permission_name: pulumi.Input[str]
        """
        Content permission name. Valid values are `View`, `GrantView`,
        `Edit`, `GrantEdit`, `Manage`, and `GrantManage`. You can read more about permission levels
        [here](https://help.sumologic.com/Manage/Content_Sharing/Share-Content#available-permission-levels).
        """
        source_id: pulumi.Input[str]
        """
        An identifier that belongs to the source type chosen above. For example,
        if the `sourceType` is set to `user`, `sourceId` should be identifier of the user you want to share
        content with (same goes for role and org source type).
        """
        source_type: pulumi.Input[str]
        """
        Type of source for the permission. Valid values are `user`, `role`,
        and `org`.
        """
elif False:
    ContentPermissionPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ContentPermissionPermissionArgs:
    def __init__(__self__, *,
                 permission_name: pulumi.Input[str],
                 source_id: pulumi.Input[str],
                 source_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] permission_name: Content permission name. Valid values are `View`, `GrantView`,
               `Edit`, `GrantEdit`, `Manage`, and `GrantManage`. You can read more about permission levels
               [here](https://help.sumologic.com/Manage/Content_Sharing/Share-Content#available-permission-levels).
        :param pulumi.Input[str] source_id: An identifier that belongs to the source type chosen above. For example,
               if the `sourceType` is set to `user`, `sourceId` should be identifier of the user you want to share
               content with (same goes for role and org source type).
        :param pulumi.Input[str] source_type: Type of source for the permission. Valid values are `user`, `role`,
               and `org`.
        """
        pulumi.set(__self__, "permission_name", permission_name)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="permissionName")
    def permission_name(self) -> pulumi.Input[str]:
        """
        Content permission name. Valid values are `View`, `GrantView`,
        `Edit`, `GrantEdit`, `Manage`, and `GrantManage`. You can read more about permission levels
        [here](https://help.sumologic.com/Manage/Content_Sharing/Share-Content#available-permission-levels).
        """
        return pulumi.get(self, "permission_name")

    @permission_name.setter
    def permission_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission_name", value)

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> pulumi.Input[str]:
        """
        An identifier that belongs to the source type chosen above. For example,
        if the `sourceType` is set to `user`, `sourceId` should be identifier of the user you want to share
        content with (same goes for role and org source type).
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_id", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> pulumi.Input[str]:
        """
        Type of source for the permission. Valid values are `user`, `role`,
        and `org`.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_type", value)


if not MYPY:
    class CseAggregationRuleAggregationFunctionArgsDict(TypedDict):
        arguments: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        One or more expressions to pass as arguments to the function
        """
        function: pulumi.Input[str]
        """
        The function to aggregate with
        """
        name: pulumi.Input[str]
        """
        The name to use to reference the result in the trigger_expression
        """
elif False:
    CseAggregationRuleAggregationFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseAggregationRuleAggregationFunctionArgs:
    def __init__(__self__, *,
                 arguments: pulumi.Input[Sequence[pulumi.Input[str]]],
                 function: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] arguments: One or more expressions to pass as arguments to the function
        :param pulumi.Input[str] function: The function to aggregate with
        :param pulumi.Input[str] name: The name to use to reference the result in the trigger_expression
        """
        pulumi.set(__self__, "arguments", arguments)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arguments(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        One or more expressions to pass as arguments to the function
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def function(self) -> pulumi.Input[str]:
        """
        The function to aggregate with
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: pulumi.Input[str]):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name to use to reference the result in the trigger_expression
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CseAggregationRuleEntitySelectorArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        expression: pulumi.Input[str]
        """
        The expression or field name to generate the Signal on.
        """
elif False:
    CseAggregationRuleEntitySelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseAggregationRuleEntitySelectorArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: The expression or field name to generate the Signal on.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        The expression or field name to generate the Signal on.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class CseAggregationRuleSeverityMappingArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        """
        default: NotRequired[pulumi.Input[int]]
        """
        The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        """
        field: NotRequired[pulumi.Input[str]]
        """
        The field to use in the "fieldValue"/"fieldValueMapping" cases.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['CseAggregationRuleSeverityMappingMappingArgsDict']]]]
        """
        The map of record values to severities to use in the "fieldValueMapping" case
        """
elif False:
    CseAggregationRuleSeverityMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseAggregationRuleSeverityMappingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 default: Optional[pulumi.Input[int]] = None,
                 field: Optional[pulumi.Input[str]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['CseAggregationRuleSeverityMappingMappingArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        :param pulumi.Input[int] default: The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        :param pulumi.Input[str] field: The field to use in the "fieldValue"/"fieldValueMapping" cases.
        :param pulumi.Input[Sequence[pulumi.Input['CseAggregationRuleSeverityMappingMappingArgs']]] mappings: The map of record values to severities to use in the "fieldValueMapping" case
        """
        pulumi.set(__self__, "type", type)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[int]]:
        """
        The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        The field to use in the "fieldValue"/"fieldValueMapping" cases.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CseAggregationRuleSeverityMappingMappingArgs']]]]:
        """
        The map of record values to severities to use in the "fieldValueMapping" case
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CseAggregationRuleSeverityMappingMappingArgs']]]]):
        pulumi.set(self, "mappings", value)


if not MYPY:
    class CseAggregationRuleSeverityMappingMappingArgsDict(TypedDict):
        from_: pulumi.Input[str]
        """
        The record value to map from
        """
        to: pulumi.Input[int]
        """
        The severity value to map to
        """
        type: pulumi.Input[str]
        """
        Must be set to "eq" currently
        """
elif False:
    CseAggregationRuleSeverityMappingMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseAggregationRuleSeverityMappingMappingArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 to: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_: The record value to map from
        :param pulumi.Input[int] to: The severity value to map to
        :param pulumi.Input[str] type: Must be set to "eq" currently
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        The record value to map from
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[int]:
        """
        The severity value to map to
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[int]):
        pulumi.set(self, "to", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be set to "eq" currently
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CseChainRuleEntitySelectorArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        expression: pulumi.Input[str]
        """
        The expression or field name to generate the Signal on.
        """
elif False:
    CseChainRuleEntitySelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseChainRuleEntitySelectorArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: The expression or field name to generate the Signal on.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        The expression or field name to generate the Signal on.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class CseChainRuleExpressionsAndLimitArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        The expression for which records to match on
        """
        limit: pulumi.Input[int]
        """
        How many times this expression must match for the Signal to fire
        """
elif False:
    CseChainRuleExpressionsAndLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseChainRuleExpressionsAndLimitArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 limit: pulumi.Input[int]):
        """
        :param pulumi.Input[str] expression: The expression for which records to match on
        :param pulumi.Input[int] limit: How many times this expression must match for the Signal to fire
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        The expression for which records to match on
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def limit(self) -> pulumi.Input[int]:
        """
        How many times this expression must match for the Signal to fire
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: pulumi.Input[int]):
        pulumi.set(self, "limit", value)


if not MYPY:
    class CseCustomInsightDynamicSeverityArgsDict(TypedDict):
        insight_severity: pulumi.Input[str]
        """
        The severity of the generated Insight (CRITICAL, HIGH, MEDIUM, or LOW)
        """
        minimum_signal_severity: pulumi.Input[int]
        """
        minimum Signal severity as the threshold for an Insight severity level
        """
elif False:
    CseCustomInsightDynamicSeverityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseCustomInsightDynamicSeverityArgs:
    def __init__(__self__, *,
                 insight_severity: pulumi.Input[str],
                 minimum_signal_severity: pulumi.Input[int]):
        """
        :param pulumi.Input[str] insight_severity: The severity of the generated Insight (CRITICAL, HIGH, MEDIUM, or LOW)
        :param pulumi.Input[int] minimum_signal_severity: minimum Signal severity as the threshold for an Insight severity level
        """
        pulumi.set(__self__, "insight_severity", insight_severity)
        pulumi.set(__self__, "minimum_signal_severity", minimum_signal_severity)

    @property
    @pulumi.getter(name="insightSeverity")
    def insight_severity(self) -> pulumi.Input[str]:
        """
        The severity of the generated Insight (CRITICAL, HIGH, MEDIUM, or LOW)
        """
        return pulumi.get(self, "insight_severity")

    @insight_severity.setter
    def insight_severity(self, value: pulumi.Input[str]):
        pulumi.set(self, "insight_severity", value)

    @property
    @pulumi.getter(name="minimumSignalSeverity")
    def minimum_signal_severity(self) -> pulumi.Input[int]:
        """
        minimum Signal severity as the threshold for an Insight severity level
        """
        return pulumi.get(self, "minimum_signal_severity")

    @minimum_signal_severity.setter
    def minimum_signal_severity(self, value: pulumi.Input[int]):
        pulumi.set(self, "minimum_signal_severity", value)


if not MYPY:
    class CseEntityNormalizationConfigurationDomainMappingArgsDict(TypedDict):
        normalized_domain: pulumi.Input[str]
        """
        The normalized domain.
        """
        raw_domain: pulumi.Input[str]
        """
        The raw domain to be normalized.
        """
elif False:
    CseEntityNormalizationConfigurationDomainMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseEntityNormalizationConfigurationDomainMappingArgs:
    def __init__(__self__, *,
                 normalized_domain: pulumi.Input[str],
                 raw_domain: pulumi.Input[str]):
        """
        :param pulumi.Input[str] normalized_domain: The normalized domain.
        :param pulumi.Input[str] raw_domain: The raw domain to be normalized.
        """
        pulumi.set(__self__, "normalized_domain", normalized_domain)
        pulumi.set(__self__, "raw_domain", raw_domain)

    @property
    @pulumi.getter(name="normalizedDomain")
    def normalized_domain(self) -> pulumi.Input[str]:
        """
        The normalized domain.
        """
        return pulumi.get(self, "normalized_domain")

    @normalized_domain.setter
    def normalized_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "normalized_domain", value)

    @property
    @pulumi.getter(name="rawDomain")
    def raw_domain(self) -> pulumi.Input[str]:
        """
        The raw domain to be normalized.
        """
        return pulumi.get(self, "raw_domain")

    @raw_domain.setter
    def raw_domain(self, value: pulumi.Input[str]):
        pulumi.set(self, "raw_domain", value)


if not MYPY:
    class CseFirstSeenRuleEntitySelectorArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        expression: pulumi.Input[str]
        """
        The expression or field name to generate the Signal on
        """
elif False:
    CseFirstSeenRuleEntitySelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseFirstSeenRuleEntitySelectorArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: The expression or field name to generate the Signal on
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        The expression or field name to generate the Signal on
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class CseLogMappingFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the log mapping.
        """
        alternate_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of alternate values.
        """
        case_insensitive: NotRequired[pulumi.Input[bool]]
        """
        Case insensitive flag.
        """
        default_value: NotRequired[pulumi.Input[str]]
        """
        Default value of the field.
        """
        field_joins: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of field join values.
        """
        format: NotRequired[pulumi.Input[str]]
        """
        Format of the field. (JSON, Windows, Syslog, CEF, LEEF )
        """
        format_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of format parameters.
        """
        join_delimiter: NotRequired[pulumi.Input[str]]
        """
        Join delimiter.
        """
        lookups: NotRequired[pulumi.Input[Sequence[pulumi.Input['CseLogMappingFieldLookupArgsDict']]]]
        """
        List of lookup key value pair for field. See lookup_schema for details.
        """
        skipped_values: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of skipped values.
        """
        split_delimiter: NotRequired[pulumi.Input[str]]
        """
        Split delimiter to be used. (some example: ",", "-", "|")
        """
        split_index: NotRequired[pulumi.Input[int]]
        """
        The index value to select (starting at zero)
        """
        time_zone: NotRequired[pulumi.Input[str]]
        """
        Time zone.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        Lookup value.
        """
        value_type: NotRequired[pulumi.Input[str]]
        """
        The value type.
        """
elif False:
    CseLogMappingFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseLogMappingFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alternate_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 case_insensitive: Optional[pulumi.Input[bool]] = None,
                 default_value: Optional[pulumi.Input[str]] = None,
                 field_joins: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 format: Optional[pulumi.Input[str]] = None,
                 format_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 join_delimiter: Optional[pulumi.Input[str]] = None,
                 lookups: Optional[pulumi.Input[Sequence[pulumi.Input['CseLogMappingFieldLookupArgs']]]] = None,
                 skipped_values: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 split_delimiter: Optional[pulumi.Input[str]] = None,
                 split_index: Optional[pulumi.Input[int]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None,
                 value_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the log mapping.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] alternate_values: List of alternate values.
        :param pulumi.Input[bool] case_insensitive: Case insensitive flag.
        :param pulumi.Input[str] default_value: Default value of the field.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] field_joins: List of field join values.
        :param pulumi.Input[str] format: Format of the field. (JSON, Windows, Syslog, CEF, LEEF )
        :param pulumi.Input[Sequence[pulumi.Input[str]]] format_parameters: List of format parameters.
        :param pulumi.Input[str] join_delimiter: Join delimiter.
        :param pulumi.Input[Sequence[pulumi.Input['CseLogMappingFieldLookupArgs']]] lookups: List of lookup key value pair for field. See lookup_schema for details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] skipped_values: List of skipped values.
        :param pulumi.Input[str] split_delimiter: Split delimiter to be used. (some example: ",", "-", "|")
        :param pulumi.Input[int] split_index: The index value to select (starting at zero)
        :param pulumi.Input[str] time_zone: Time zone.
        :param pulumi.Input[str] value: Lookup value.
        :param pulumi.Input[str] value_type: The value type.
        """
        pulumi.set(__self__, "name", name)
        if alternate_values is not None:
            pulumi.set(__self__, "alternate_values", alternate_values)
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if field_joins is not None:
            pulumi.set(__self__, "field_joins", field_joins)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_parameters is not None:
            pulumi.set(__self__, "format_parameters", format_parameters)
        if join_delimiter is not None:
            pulumi.set(__self__, "join_delimiter", join_delimiter)
        if lookups is not None:
            pulumi.set(__self__, "lookups", lookups)
        if skipped_values is not None:
            pulumi.set(__self__, "skipped_values", skipped_values)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if split_index is not None:
            pulumi.set(__self__, "split_index", split_index)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the log mapping.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="alternateValues")
    def alternate_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of alternate values.
        """
        return pulumi.get(self, "alternate_values")

    @alternate_values.setter
    def alternate_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "alternate_values", value)

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[pulumi.Input[bool]]:
        """
        Case insensitive flag.
        """
        return pulumi.get(self, "case_insensitive")

    @case_insensitive.setter
    def case_insensitive(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "case_insensitive", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[str]]:
        """
        Default value of the field.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter(name="fieldJoins")
    def field_joins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of field join values.
        """
        return pulumi.get(self, "field_joins")

    @field_joins.setter
    def field_joins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "field_joins", value)

    @property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[str]]:
        """
        Format of the field. (JSON, Windows, Syslog, CEF, LEEF )
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter(name="formatParameters")
    def format_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of format parameters.
        """
        return pulumi.get(self, "format_parameters")

    @format_parameters.setter
    def format_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "format_parameters", value)

    @property
    @pulumi.getter(name="joinDelimiter")
    def join_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        Join delimiter.
        """
        return pulumi.get(self, "join_delimiter")

    @join_delimiter.setter
    def join_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "join_delimiter", value)

    @property
    @pulumi.getter
    def lookups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CseLogMappingFieldLookupArgs']]]]:
        """
        List of lookup key value pair for field. See lookup_schema for details.
        """
        return pulumi.get(self, "lookups")

    @lookups.setter
    def lookups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CseLogMappingFieldLookupArgs']]]]):
        pulumi.set(self, "lookups", value)

    @property
    @pulumi.getter(name="skippedValues")
    def skipped_values(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of skipped values.
        """
        return pulumi.get(self, "skipped_values")

    @skipped_values.setter
    def skipped_values(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "skipped_values", value)

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        Split delimiter to be used. (some example: ",", "-", "|")
        """
        return pulumi.get(self, "split_delimiter")

    @split_delimiter.setter
    def split_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "split_delimiter", value)

    @property
    @pulumi.getter(name="splitIndex")
    def split_index(self) -> Optional[pulumi.Input[int]]:
        """
        The index value to select (starting at zero)
        """
        return pulumi.get(self, "split_index")

    @split_index.setter
    def split_index(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "split_index", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        """
        Time zone.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Lookup value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[pulumi.Input[str]]:
        """
        The value type.
        """
        return pulumi.get(self, "value_type")

    @value_type.setter
    def value_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value_type", value)


if not MYPY:
    class CseLogMappingFieldLookupArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Lookup key.
        """
        value: pulumi.Input[str]
        """
        Lookup value.
        """
elif False:
    CseLogMappingFieldLookupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseLogMappingFieldLookupArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Lookup key.
        :param pulumi.Input[str] value: Lookup value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Lookup key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Lookup value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CseLogMappingStructuredInputArgsDict(TypedDict):
        event_id_pattern: pulumi.Input[str]
        """
        Event id pattern.
        """
        log_format: pulumi.Input[str]
        """
        Log format. (JSON, Windows, Syslog, CEF, LEEF )
        """
        product: pulumi.Input[str]
        """
        Product name.
        """
        vendor: pulumi.Input[str]
        """
        Vendor name.
        """
elif False:
    CseLogMappingStructuredInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseLogMappingStructuredInputArgs:
    def __init__(__self__, *,
                 event_id_pattern: pulumi.Input[str],
                 log_format: pulumi.Input[str],
                 product: pulumi.Input[str],
                 vendor: pulumi.Input[str]):
        """
        :param pulumi.Input[str] event_id_pattern: Event id pattern.
        :param pulumi.Input[str] log_format: Log format. (JSON, Windows, Syslog, CEF, LEEF )
        :param pulumi.Input[str] product: Product name.
        :param pulumi.Input[str] vendor: Vendor name.
        """
        pulumi.set(__self__, "event_id_pattern", event_id_pattern)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="eventIdPattern")
    def event_id_pattern(self) -> pulumi.Input[str]:
        """
        Event id pattern.
        """
        return pulumi.get(self, "event_id_pattern")

    @event_id_pattern.setter
    def event_id_pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_id_pattern", value)

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> pulumi.Input[str]:
        """
        Log format. (JSON, Windows, Syslog, CEF, LEEF )
        """
        return pulumi.get(self, "log_format")

    @log_format.setter
    def log_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "log_format", value)

    @property
    @pulumi.getter
    def product(self) -> pulumi.Input[str]:
        """
        Product name.
        """
        return pulumi.get(self, "product")

    @product.setter
    def product(self, value: pulumi.Input[str]):
        pulumi.set(self, "product", value)

    @property
    @pulumi.getter
    def vendor(self) -> pulumi.Input[str]:
        """
        Vendor name.
        """
        return pulumi.get(self, "vendor")

    @vendor.setter
    def vendor(self, value: pulumi.Input[str]):
        pulumi.set(self, "vendor", value)


if not MYPY:
    class CseLogMappingUnstructuredFieldsArgsDict(TypedDict):
        pattern_names: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of grok pattern names.


        The following attributes are exported:
        """
elif False:
    CseLogMappingUnstructuredFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseLogMappingUnstructuredFieldsArgs:
    def __init__(__self__, *,
                 pattern_names: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pattern_names: List of grok pattern names.
               
               
               The following attributes are exported:
        """
        pulumi.set(__self__, "pattern_names", pattern_names)

    @property
    @pulumi.getter(name="patternNames")
    def pattern_names(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of grok pattern names.


        The following attributes are exported:
        """
        return pulumi.get(self, "pattern_names")

    @pattern_names.setter
    def pattern_names(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pattern_names", value)


if not MYPY:
    class CseMatchListItemArgsDict(TypedDict):
        description: pulumi.Input[str]
        """
        Match list description.
        """
        value: pulumi.Input[str]
        """
        Match list item value.
        """
        expiration: NotRequired[pulumi.Input[str]]
        """
        Match list item expiration. (Format: YYYY-MM-DDTHH:mm:ss)

        The following attributes are exported:
        """
        id: NotRequired[pulumi.Input[str]]
        """
        The internal ID of the match list.
        """
elif False:
    CseMatchListItemArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseMatchListItemArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[str],
                 value: pulumi.Input[str],
                 expiration: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Match list description.
        :param pulumi.Input[str] value: Match list item value.
        :param pulumi.Input[str] expiration: Match list item expiration. (Format: YYYY-MM-DDTHH:mm:ss)
               
               The following attributes are exported:
        :param pulumi.Input[str] id: The internal ID of the match list.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def description(self) -> pulumi.Input[str]:
        """
        Match list description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[str]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Match list item value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[str]]:
        """
        Match list item expiration. (Format: YYYY-MM-DDTHH:mm:ss)

        The following attributes are exported:
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The internal ID of the match list.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class CseMatchRuleEntitySelectorArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        expression: pulumi.Input[str]
        """
        The expression or field name to generate the Signal on.
        """
elif False:
    CseMatchRuleEntitySelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseMatchRuleEntitySelectorArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: The expression or field name to generate the Signal on.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        The expression or field name to generate the Signal on.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class CseMatchRuleSeverityMappingArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        """
        default: NotRequired[pulumi.Input[int]]
        """
        The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        """
        field: NotRequired[pulumi.Input[str]]
        """
        The field to use in the "fieldValue"/"fieldValueMapping" cases.
        """
        mappings: NotRequired[pulumi.Input[Sequence[pulumi.Input['CseMatchRuleSeverityMappingMappingArgsDict']]]]
        """
        The map of record values to severities to use in the "fieldValueMapping" case
        """
elif False:
    CseMatchRuleSeverityMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseMatchRuleSeverityMappingArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 default: Optional[pulumi.Input[int]] = None,
                 field: Optional[pulumi.Input[str]] = None,
                 mappings: Optional[pulumi.Input[Sequence[pulumi.Input['CseMatchRuleSeverityMappingMappingArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        :param pulumi.Input[int] default: The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        :param pulumi.Input[str] field: The field to use in the "fieldValue"/"fieldValueMapping" cases.
        :param pulumi.Input[Sequence[pulumi.Input['CseMatchRuleSeverityMappingMappingArgs']]] mappings: The map of record values to severities to use in the "fieldValueMapping" case
        """
        pulumi.set(__self__, "type", type)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[int]]:
        """
        The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "default", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        The field to use in the "fieldValue"/"fieldValueMapping" cases.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def mappings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CseMatchRuleSeverityMappingMappingArgs']]]]:
        """
        The map of record values to severities to use in the "fieldValueMapping" case
        """
        return pulumi.get(self, "mappings")

    @mappings.setter
    def mappings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CseMatchRuleSeverityMappingMappingArgs']]]]):
        pulumi.set(self, "mappings", value)


if not MYPY:
    class CseMatchRuleSeverityMappingMappingArgsDict(TypedDict):
        from_: pulumi.Input[str]
        """
        The record value to map from
        """
        to: pulumi.Input[int]
        """
        The severity value to map to
        """
        type: pulumi.Input[str]
        """
        Must be set to "eq" currently
        """
elif False:
    CseMatchRuleSeverityMappingMappingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseMatchRuleSeverityMappingMappingArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input[str],
                 to: pulumi.Input[int],
                 type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] from_: The record value to map from
        :param pulumi.Input[int] to: The severity value to map to
        :param pulumi.Input[str] type: Must be set to "eq" currently
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input[str]:
        """
        The record value to map from
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input[str]):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> pulumi.Input[int]:
        """
        The severity value to map to
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: pulumi.Input[int]):
        pulumi.set(self, "to", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be set to "eq" currently
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CseOutlierRuleAggregationFunctionsArgsDict(TypedDict):
        arguments: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        One or more expressions to pass as arguments to the function
        """
        function: pulumi.Input[str]
        """
        The function to aggregate with
        """
        name: pulumi.Input[str]
        """
        The name of the Rule
        """
elif False:
    CseOutlierRuleAggregationFunctionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseOutlierRuleAggregationFunctionsArgs:
    def __init__(__self__, *,
                 arguments: pulumi.Input[Sequence[pulumi.Input[str]]],
                 function: pulumi.Input[str],
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] arguments: One or more expressions to pass as arguments to the function
        :param pulumi.Input[str] function: The function to aggregate with
        :param pulumi.Input[str] name: The name of the Rule
        """
        pulumi.set(__self__, "arguments", arguments)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arguments(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        One or more expressions to pass as arguments to the function
        """
        return pulumi.get(self, "arguments")

    @arguments.setter
    def arguments(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "arguments", value)

    @property
    @pulumi.getter
    def function(self) -> pulumi.Input[str]:
        """
        The function to aggregate with
        """
        return pulumi.get(self, "function")

    @function.setter
    def function(self, value: pulumi.Input[str]):
        pulumi.set(self, "function", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Rule
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CseOutlierRuleEntitySelectorArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        expression: pulumi.Input[str]
        """
        The expression or field name to generate the Signal on
        """
elif False:
    CseOutlierRuleEntitySelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseOutlierRuleEntitySelectorArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: The expression or field name to generate the Signal on
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        The expression or field name to generate the Signal on
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class CseTagSchemaValueOptionArgsDict(TypedDict):
        value: pulumi.Input[str]
        """
        Value option value.
        """
        label: NotRequired[pulumi.Input[str]]
        """
        Value option label.
        """
        link: NotRequired[pulumi.Input[str]]
        """
        Value option link.



        The following attributes are exported:
        """
elif False:
    CseTagSchemaValueOptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseTagSchemaValueOptionArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[str],
                 label: Optional[pulumi.Input[str]] = None,
                 link: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] value: Value option value.
        :param pulumi.Input[str] label: Value option label.
        :param pulumi.Input[str] link: Value option link.
               
               
               
               The following attributes are exported:
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value option value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def label(self) -> Optional[pulumi.Input[str]]:
        """
        Value option label.
        """
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def link(self) -> Optional[pulumi.Input[str]]:
        """
        Value option link.



        The following attributes are exported:
        """
        return pulumi.get(self, "link")

    @link.setter
    def link(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "link", value)


if not MYPY:
    class CseThresholdRuleEntitySelectorArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        expression: pulumi.Input[str]
        """
        The expression or field name to generate the Signal on.
        """
elif False:
    CseThresholdRuleEntitySelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CseThresholdRuleEntitySelectorArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 expression: pulumi.Input[str]):
        """
        :param pulumi.Input[str] expression: The expression or field name to generate the Signal on.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        The expression or field name to generate the Signal on.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)


if not MYPY:
    class DashboardColoringRuleArgsDict(TypedDict):
        multiple_series_aggregate_function: pulumi.Input[str]
        scope: pulumi.Input[str]
        single_series_aggregate_function: pulumi.Input[str]
        color_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardColoringRuleColorThresholdArgsDict']]]]
elif False:
    DashboardColoringRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardColoringRuleArgs:
    def __init__(__self__, *,
                 multiple_series_aggregate_function: pulumi.Input[str],
                 scope: pulumi.Input[str],
                 single_series_aggregate_function: pulumi.Input[str],
                 color_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardColoringRuleColorThresholdArgs']]]] = None):
        pulumi.set(__self__, "multiple_series_aggregate_function", multiple_series_aggregate_function)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "single_series_aggregate_function", single_series_aggregate_function)
        if color_thresholds is not None:
            pulumi.set(__self__, "color_thresholds", color_thresholds)

    @property
    @pulumi.getter(name="multipleSeriesAggregateFunction")
    def multiple_series_aggregate_function(self) -> pulumi.Input[str]:
        return pulumi.get(self, "multiple_series_aggregate_function")

    @multiple_series_aggregate_function.setter
    def multiple_series_aggregate_function(self, value: pulumi.Input[str]):
        pulumi.set(self, "multiple_series_aggregate_function", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="singleSeriesAggregateFunction")
    def single_series_aggregate_function(self) -> pulumi.Input[str]:
        return pulumi.get(self, "single_series_aggregate_function")

    @single_series_aggregate_function.setter
    def single_series_aggregate_function(self, value: pulumi.Input[str]):
        pulumi.set(self, "single_series_aggregate_function", value)

    @property
    @pulumi.getter(name="colorThresholds")
    def color_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardColoringRuleColorThresholdArgs']]]]:
        return pulumi.get(self, "color_thresholds")

    @color_thresholds.setter
    def color_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardColoringRuleColorThresholdArgs']]]]):
        pulumi.set(self, "color_thresholds", value)


if not MYPY:
    class DashboardColoringRuleColorThresholdArgsDict(TypedDict):
        color: pulumi.Input[str]
        max: NotRequired[pulumi.Input[float]]
        min: NotRequired[pulumi.Input[float]]
elif False:
    DashboardColoringRuleColorThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardColoringRuleColorThresholdArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 max: Optional[pulumi.Input[float]] = None,
                 min: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "color", color)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class DashboardLayoutArgsDict(TypedDict):
        grid: NotRequired[pulumi.Input['DashboardLayoutGridArgsDict']]
elif False:
    DashboardLayoutArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardLayoutArgs:
    def __init__(__self__, *,
                 grid: Optional[pulumi.Input['DashboardLayoutGridArgs']] = None):
        if grid is not None:
            pulumi.set(__self__, "grid", grid)

    @property
    @pulumi.getter
    def grid(self) -> Optional[pulumi.Input['DashboardLayoutGridArgs']]:
        return pulumi.get(self, "grid")

    @grid.setter
    def grid(self, value: Optional[pulumi.Input['DashboardLayoutGridArgs']]):
        pulumi.set(self, "grid", value)


if not MYPY:
    class DashboardLayoutGridArgsDict(TypedDict):
        layout_structures: pulumi.Input[Sequence[pulumi.Input['DashboardLayoutGridLayoutStructureArgsDict']]]
elif False:
    DashboardLayoutGridArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardLayoutGridArgs:
    def __init__(__self__, *,
                 layout_structures: pulumi.Input[Sequence[pulumi.Input['DashboardLayoutGridLayoutStructureArgs']]]):
        pulumi.set(__self__, "layout_structures", layout_structures)

    @property
    @pulumi.getter(name="layoutStructures")
    def layout_structures(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardLayoutGridLayoutStructureArgs']]]:
        return pulumi.get(self, "layout_structures")

    @layout_structures.setter
    def layout_structures(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardLayoutGridLayoutStructureArgs']]]):
        pulumi.set(self, "layout_structures", value)


if not MYPY:
    class DashboardLayoutGridLayoutStructureArgsDict(TypedDict):
        key: pulumi.Input[str]
        structure: pulumi.Input[str]
elif False:
    DashboardLayoutGridLayoutStructureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardLayoutGridLayoutStructureArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 structure: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def structure(self) -> pulumi.Input[str]:
        return pulumi.get(self, "structure")

    @structure.setter
    def structure(self, value: pulumi.Input[str]):
        pulumi.set(self, "structure", value)


if not MYPY:
    class DashboardPanelArgsDict(TypedDict):
        service_map_panel: NotRequired[pulumi.Input['DashboardPanelServiceMapPanelArgsDict']]
        sumo_search_panel: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelArgsDict']]
        text_panel: NotRequired[pulumi.Input['DashboardPanelTextPanelArgsDict']]
        traces_list_panel: NotRequired[pulumi.Input['DashboardPanelTracesListPanelArgsDict']]
elif False:
    DashboardPanelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelArgs:
    def __init__(__self__, *,
                 service_map_panel: Optional[pulumi.Input['DashboardPanelServiceMapPanelArgs']] = None,
                 sumo_search_panel: Optional[pulumi.Input['DashboardPanelSumoSearchPanelArgs']] = None,
                 text_panel: Optional[pulumi.Input['DashboardPanelTextPanelArgs']] = None,
                 traces_list_panel: Optional[pulumi.Input['DashboardPanelTracesListPanelArgs']] = None):
        if service_map_panel is not None:
            pulumi.set(__self__, "service_map_panel", service_map_panel)
        if sumo_search_panel is not None:
            pulumi.set(__self__, "sumo_search_panel", sumo_search_panel)
        if text_panel is not None:
            pulumi.set(__self__, "text_panel", text_panel)
        if traces_list_panel is not None:
            pulumi.set(__self__, "traces_list_panel", traces_list_panel)

    @property
    @pulumi.getter(name="serviceMapPanel")
    def service_map_panel(self) -> Optional[pulumi.Input['DashboardPanelServiceMapPanelArgs']]:
        return pulumi.get(self, "service_map_panel")

    @service_map_panel.setter
    def service_map_panel(self, value: Optional[pulumi.Input['DashboardPanelServiceMapPanelArgs']]):
        pulumi.set(self, "service_map_panel", value)

    @property
    @pulumi.getter(name="sumoSearchPanel")
    def sumo_search_panel(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelArgs']]:
        return pulumi.get(self, "sumo_search_panel")

    @sumo_search_panel.setter
    def sumo_search_panel(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelArgs']]):
        pulumi.set(self, "sumo_search_panel", value)

    @property
    @pulumi.getter(name="textPanel")
    def text_panel(self) -> Optional[pulumi.Input['DashboardPanelTextPanelArgs']]:
        return pulumi.get(self, "text_panel")

    @text_panel.setter
    def text_panel(self, value: Optional[pulumi.Input['DashboardPanelTextPanelArgs']]):
        pulumi.set(self, "text_panel", value)

    @property
    @pulumi.getter(name="tracesListPanel")
    def traces_list_panel(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelArgs']]:
        return pulumi.get(self, "traces_list_panel")

    @traces_list_panel.setter
    def traces_list_panel(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelArgs']]):
        pulumi.set(self, "traces_list_panel", value)


if not MYPY:
    class DashboardPanelServiceMapPanelArgsDict(TypedDict):
        key: pulumi.Input[str]
        application: NotRequired[pulumi.Input[str]]
        environment: NotRequired[pulumi.Input[str]]
        id: NotRequired[pulumi.Input[str]]
        keep_visual_settings_consistent_with_parent: NotRequired[pulumi.Input[bool]]
        service: NotRequired[pulumi.Input[str]]
        show_remote_services: NotRequired[pulumi.Input[bool]]
        title: NotRequired[pulumi.Input[str]]
        """
        Title of the dashboard.
        """
        visual_settings: NotRequired[pulumi.Input[str]]
elif False:
    DashboardPanelServiceMapPanelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelServiceMapPanelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 application: Optional[pulumi.Input[str]] = None,
                 environment: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 keep_visual_settings_consistent_with_parent: Optional[pulumi.Input[bool]] = None,
                 service: Optional[pulumi.Input[str]] = None,
                 show_remote_services: Optional[pulumi.Input[bool]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 visual_settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if application is not None:
            pulumi.set(__self__, "application", application)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if show_remote_services is not None:
            pulumi.set(__self__, "show_remote_services", show_remote_services)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def application(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "application")

    @application.setter
    def application(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application", value)

    @property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @keep_visual_settings_consistent_with_parent.setter
    def keep_visual_settings_consistent_with_parent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_visual_settings_consistent_with_parent", value)

    @property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service", value)

    @property
    @pulumi.getter(name="showRemoteServices")
    def show_remote_services(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "show_remote_services")

    @show_remote_services.setter
    def show_remote_services(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "show_remote_services", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "visual_settings")

    @visual_settings.setter
    def visual_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visual_settings", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelArgsDict(TypedDict):
        key: pulumi.Input[str]
        coloring_rule: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelColoringRuleArgsDict']]
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the dashboard.
        """
        id: NotRequired[pulumi.Input[str]]
        keep_visual_settings_consistent_with_parent: NotRequired[pulumi.Input[bool]]
        linked_dashboard: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelLinkedDashboardArgsDict']]
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryArgsDict']]]]
        time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeArgsDict']]
        """
        Time range of the dashboard. See time range schema
        for details.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Title of the dashboard.
        """
        visual_settings: NotRequired[pulumi.Input[str]]
elif False:
    DashboardPanelSumoSearchPanelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 coloring_rule: Optional[pulumi.Input['DashboardPanelSumoSearchPanelColoringRuleArgs']] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 keep_visual_settings_consistent_with_parent: Optional[pulumi.Input[bool]] = None,
                 linked_dashboard: Optional[pulumi.Input['DashboardPanelSumoSearchPanelLinkedDashboardArgs']] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryArgs']]]] = None,
                 time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 visual_settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] description: Description of the dashboard.
        :param pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeArgs'] time_range: Time range of the dashboard. See time range schema
               for details.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if coloring_rule is not None:
            pulumi.set(__self__, "coloring_rule", coloring_rule)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if linked_dashboard is not None:
            pulumi.set(__self__, "linked_dashboard", linked_dashboard)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter(name="coloringRule")
    def coloring_rule(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelColoringRuleArgs']]:
        return pulumi.get(self, "coloring_rule")

    @coloring_rule.setter
    def coloring_rule(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelColoringRuleArgs']]):
        pulumi.set(self, "coloring_rule", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the dashboard.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @keep_visual_settings_consistent_with_parent.setter
    def keep_visual_settings_consistent_with_parent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_visual_settings_consistent_with_parent", value)

    @property
    @pulumi.getter(name="linkedDashboard")
    def linked_dashboard(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelLinkedDashboardArgs']]:
        return pulumi.get(self, "linked_dashboard")

    @linked_dashboard.setter
    def linked_dashboard(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelLinkedDashboardArgs']]):
        pulumi.set(self, "linked_dashboard", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeArgs']]:
        """
        Time range of the dashboard. See time range schema
        for details.
        """
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeArgs']]):
        pulumi.set(self, "time_range", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "visual_settings")

    @visual_settings.setter
    def visual_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visual_settings", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelColoringRuleArgsDict(TypedDict):
        multiple_series_aggregate_function: pulumi.Input[str]
        scope: pulumi.Input[str]
        single_series_aggregate_function: pulumi.Input[str]
        color_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelColoringRuleColorThresholdArgsDict']]]]
elif False:
    DashboardPanelSumoSearchPanelColoringRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelColoringRuleArgs:
    def __init__(__self__, *,
                 multiple_series_aggregate_function: pulumi.Input[str],
                 scope: pulumi.Input[str],
                 single_series_aggregate_function: pulumi.Input[str],
                 color_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelColoringRuleColorThresholdArgs']]]] = None):
        pulumi.set(__self__, "multiple_series_aggregate_function", multiple_series_aggregate_function)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "single_series_aggregate_function", single_series_aggregate_function)
        if color_thresholds is not None:
            pulumi.set(__self__, "color_thresholds", color_thresholds)

    @property
    @pulumi.getter(name="multipleSeriesAggregateFunction")
    def multiple_series_aggregate_function(self) -> pulumi.Input[str]:
        return pulumi.get(self, "multiple_series_aggregate_function")

    @multiple_series_aggregate_function.setter
    def multiple_series_aggregate_function(self, value: pulumi.Input[str]):
        pulumi.set(self, "multiple_series_aggregate_function", value)

    @property
    @pulumi.getter
    def scope(self) -> pulumi.Input[str]:
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: pulumi.Input[str]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter(name="singleSeriesAggregateFunction")
    def single_series_aggregate_function(self) -> pulumi.Input[str]:
        return pulumi.get(self, "single_series_aggregate_function")

    @single_series_aggregate_function.setter
    def single_series_aggregate_function(self, value: pulumi.Input[str]):
        pulumi.set(self, "single_series_aggregate_function", value)

    @property
    @pulumi.getter(name="colorThresholds")
    def color_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelColoringRuleColorThresholdArgs']]]]:
        return pulumi.get(self, "color_thresholds")

    @color_thresholds.setter
    def color_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelColoringRuleColorThresholdArgs']]]]):
        pulumi.set(self, "color_thresholds", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelColoringRuleColorThresholdArgsDict(TypedDict):
        color: pulumi.Input[str]
        max: NotRequired[pulumi.Input[float]]
        min: NotRequired[pulumi.Input[float]]
elif False:
    DashboardPanelSumoSearchPanelColoringRuleColorThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelColoringRuleColorThresholdArgs:
    def __init__(__self__, *,
                 color: pulumi.Input[str],
                 max: Optional[pulumi.Input[float]] = None,
                 min: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "color", color)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def color(self) -> pulumi.Input[str]:
        return pulumi.get(self, "color")

    @color.setter
    def color(self, value: pulumi.Input[str]):
        pulumi.set(self, "color", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelLinkedDashboardArgsDict(TypedDict):
        id: pulumi.Input[str]
        include_time_range: NotRequired[pulumi.Input[bool]]
        include_variables: NotRequired[pulumi.Input[bool]]
        relative_path: NotRequired[pulumi.Input[str]]
elif False:
    DashboardPanelSumoSearchPanelLinkedDashboardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelLinkedDashboardArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[str],
                 include_time_range: Optional[pulumi.Input[bool]] = None,
                 include_variables: Optional[pulumi.Input[bool]] = None,
                 relative_path: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "id", id)
        if include_time_range is not None:
            pulumi.set(__self__, "include_time_range", include_time_range)
        if include_variables is not None:
            pulumi.set(__self__, "include_variables", include_variables)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)

    @property
    @pulumi.getter
    def id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[str]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="includeTimeRange")
    def include_time_range(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_time_range")

    @include_time_range.setter
    def include_time_range(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_time_range", value)

    @property
    @pulumi.getter(name="includeVariables")
    def include_variables(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_variables")

    @include_variables.setter
    def include_variables(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_variables", value)

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "relative_path")

    @relative_path.setter
    def relative_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "relative_path", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelQueryArgsDict(TypedDict):
        query_key: pulumi.Input[str]
        query_string: pulumi.Input[str]
        query_type: pulumi.Input[str]
        metrics_query_data: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataArgsDict']]
        metrics_query_mode: NotRequired[pulumi.Input[str]]
        output_cardinality_limit: NotRequired[pulumi.Input[int]]
        parse_mode: NotRequired[pulumi.Input[str]]
        time_source: NotRequired[pulumi.Input[str]]
        transient: NotRequired[pulumi.Input[bool]]
elif False:
    DashboardPanelSumoSearchPanelQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelQueryArgs:
    def __init__(__self__, *,
                 query_key: pulumi.Input[str],
                 query_string: pulumi.Input[str],
                 query_type: pulumi.Input[str],
                 metrics_query_data: Optional[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataArgs']] = None,
                 metrics_query_mode: Optional[pulumi.Input[str]] = None,
                 output_cardinality_limit: Optional[pulumi.Input[int]] = None,
                 parse_mode: Optional[pulumi.Input[str]] = None,
                 time_source: Optional[pulumi.Input[str]] = None,
                 transient: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "query_key", query_key)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "query_type", query_type)
        if metrics_query_data is not None:
            pulumi.set(__self__, "metrics_query_data", metrics_query_data)
        if metrics_query_mode is not None:
            pulumi.set(__self__, "metrics_query_mode", metrics_query_mode)
        if output_cardinality_limit is not None:
            pulumi.set(__self__, "output_cardinality_limit", output_cardinality_limit)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if time_source is not None:
            pulumi.set(__self__, "time_source", time_source)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)

    @property
    @pulumi.getter(name="queryKey")
    def query_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_key")

    @query_key.setter
    def query_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_key", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_type", value)

    @property
    @pulumi.getter(name="metricsQueryData")
    def metrics_query_data(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataArgs']]:
        return pulumi.get(self, "metrics_query_data")

    @metrics_query_data.setter
    def metrics_query_data(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataArgs']]):
        pulumi.set(self, "metrics_query_data", value)

    @property
    @pulumi.getter(name="metricsQueryMode")
    def metrics_query_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metrics_query_mode")

    @metrics_query_mode.setter
    def metrics_query_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metrics_query_mode", value)

    @property
    @pulumi.getter(name="outputCardinalityLimit")
    def output_cardinality_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "output_cardinality_limit")

    @output_cardinality_limit.setter
    def output_cardinality_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "output_cardinality_limit", value)

    @property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parse_mode")

    @parse_mode.setter
    def parse_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parse_mode", value)

    @property
    @pulumi.getter(name="timeSource")
    def time_source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_source")

    @time_source.setter
    def time_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_source", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "transient", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelQueryMetricsQueryDataArgsDict(TypedDict):
        filters: pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilterArgsDict']]]
        metric: pulumi.Input[str]
        aggregation_type: NotRequired[pulumi.Input[str]]
        group_by: NotRequired[pulumi.Input[str]]
        operators: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorArgsDict']]]]
elif False:
    DashboardPanelSumoSearchPanelQueryMetricsQueryDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilterArgs']]],
                 metric: pulumi.Input[str],
                 aggregation_type: Optional[pulumi.Input[str]] = None,
                 group_by: Optional[pulumi.Input[str]] = None,
                 operators: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorArgs']]]] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "metric", metric)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if group_by is not None:
            pulumi.set(__self__, "group_by", group_by)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilterArgs']]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilterArgs']]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregation_type", value)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_by")

    @group_by.setter
    def group_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_by", value)

    @property
    @pulumi.getter
    def operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorArgs']]]]:
        return pulumi.get(self, "operators")

    @operators.setter
    def operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorArgs']]]]):
        pulumi.set(self, "operators", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilterArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
        negation: NotRequired[pulumi.Input[bool]]
elif False:
    DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 negation: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if negation is not None:
            pulumi.set(__self__, "negation", negation)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def negation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "negation")

    @negation.setter
    def negation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negation", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorArgsDict(TypedDict):
        operator_name: pulumi.Input[str]
        parameters: pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameterArgsDict']]]
elif False:
    DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorArgs:
    def __init__(__self__, *,
                 operator_name: pulumi.Input[str],
                 parameters: pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameterArgs']]]):
        pulumi.set(__self__, "operator_name", operator_name)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="operatorName")
    def operator_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operator_name")

    @operator_name.setter
    def operator_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameterArgs']]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameterArgs']]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameterArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeArgsDict(TypedDict):
        begin_bounded_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeArgsDict']]
        complete_literal_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRangeArgsDict']]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeArgs:
    def __init__(__self__, *,
                 begin_bounded_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeArgs']] = None,
                 complete_literal_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRangeArgs']] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeArgs']]:
        return pulumi.get(self, "begin_bounded_time_range")

    @begin_bounded_time_range.setter
    def begin_bounded_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeArgs']]):
        pulumi.set(self, "begin_bounded_time_range", value)

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRangeArgs']]:
        return pulumi.get(self, "complete_literal_time_range")

    @complete_literal_time_range.setter
    def complete_literal_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRangeArgs']]):
        pulumi.set(self, "complete_literal_time_range", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeArgsDict(TypedDict):
        from_: pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromArgsDict']
        to: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToArgsDict']]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromArgs'],
                 to: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToArgs']] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromArgs']:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromArgs']):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToArgs']]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict']]
        iso8601_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict']]
        literal_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict']]
        relative_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict']]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]:
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]:
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]:
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]:
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict']]
        iso8601_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict']]
        literal_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict']]
        relative_time_range: NotRequired[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict']]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]:
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]:
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]:
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]:
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class DashboardPanelTextPanelArgsDict(TypedDict):
        key: pulumi.Input[str]
        id: NotRequired[pulumi.Input[str]]
        keep_visual_settings_consistent_with_parent: NotRequired[pulumi.Input[bool]]
        text: NotRequired[pulumi.Input[str]]
        title: NotRequired[pulumi.Input[str]]
        """
        Title of the dashboard.
        """
        visual_settings: NotRequired[pulumi.Input[str]]
elif False:
    DashboardPanelTextPanelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTextPanelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 keep_visual_settings_consistent_with_parent: Optional[pulumi.Input[bool]] = None,
                 text: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 visual_settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @keep_visual_settings_consistent_with_parent.setter
    def keep_visual_settings_consistent_with_parent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_visual_settings_consistent_with_parent", value)

    @property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "text", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "visual_settings")

    @visual_settings.setter
    def visual_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visual_settings", value)


if not MYPY:
    class DashboardPanelTracesListPanelArgsDict(TypedDict):
        key: pulumi.Input[str]
        id: NotRequired[pulumi.Input[str]]
        keep_visual_settings_consistent_with_parent: NotRequired[pulumi.Input[bool]]
        queries: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryArgsDict']]]]
        time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeArgsDict']]
        """
        Time range of the dashboard. See time range schema
        for details.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Title of the dashboard.
        """
        visual_settings: NotRequired[pulumi.Input[str]]
elif False:
    DashboardPanelTracesListPanelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None,
                 keep_visual_settings_consistent_with_parent: Optional[pulumi.Input[bool]] = None,
                 queries: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryArgs']]]] = None,
                 time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeArgs']] = None,
                 title: Optional[pulumi.Input[str]] = None,
                 visual_settings: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['DashboardPanelTracesListPanelTimeRangeArgs'] time_range: Time range of the dashboard. See time range schema
               for details.
        :param pulumi.Input[str] title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @keep_visual_settings_consistent_with_parent.setter
    def keep_visual_settings_consistent_with_parent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "keep_visual_settings_consistent_with_parent", value)

    @property
    @pulumi.getter
    def queries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryArgs']]]]:
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryArgs']]]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeArgs']]:
        """
        Time range of the dashboard. See time range schema
        for details.
        """
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeArgs']]):
        pulumi.set(self, "time_range", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "visual_settings")

    @visual_settings.setter
    def visual_settings(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "visual_settings", value)


if not MYPY:
    class DashboardPanelTracesListPanelQueryArgsDict(TypedDict):
        query_key: pulumi.Input[str]
        query_string: pulumi.Input[str]
        query_type: pulumi.Input[str]
        metrics_query_data: NotRequired[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataArgsDict']]
        metrics_query_mode: NotRequired[pulumi.Input[str]]
        output_cardinality_limit: NotRequired[pulumi.Input[int]]
        parse_mode: NotRequired[pulumi.Input[str]]
        time_source: NotRequired[pulumi.Input[str]]
        transient: NotRequired[pulumi.Input[bool]]
elif False:
    DashboardPanelTracesListPanelQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelQueryArgs:
    def __init__(__self__, *,
                 query_key: pulumi.Input[str],
                 query_string: pulumi.Input[str],
                 query_type: pulumi.Input[str],
                 metrics_query_data: Optional[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataArgs']] = None,
                 metrics_query_mode: Optional[pulumi.Input[str]] = None,
                 output_cardinality_limit: Optional[pulumi.Input[int]] = None,
                 parse_mode: Optional[pulumi.Input[str]] = None,
                 time_source: Optional[pulumi.Input[str]] = None,
                 transient: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "query_key", query_key)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "query_type", query_type)
        if metrics_query_data is not None:
            pulumi.set(__self__, "metrics_query_data", metrics_query_data)
        if metrics_query_mode is not None:
            pulumi.set(__self__, "metrics_query_mode", metrics_query_mode)
        if output_cardinality_limit is not None:
            pulumi.set(__self__, "output_cardinality_limit", output_cardinality_limit)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if time_source is not None:
            pulumi.set(__self__, "time_source", time_source)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)

    @property
    @pulumi.getter(name="queryKey")
    def query_key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_key")

    @query_key.setter
    def query_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_key", value)

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_string")

    @query_string.setter
    def query_string(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_string", value)

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_type", value)

    @property
    @pulumi.getter(name="metricsQueryData")
    def metrics_query_data(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataArgs']]:
        return pulumi.get(self, "metrics_query_data")

    @metrics_query_data.setter
    def metrics_query_data(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataArgs']]):
        pulumi.set(self, "metrics_query_data", value)

    @property
    @pulumi.getter(name="metricsQueryMode")
    def metrics_query_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "metrics_query_mode")

    @metrics_query_mode.setter
    def metrics_query_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metrics_query_mode", value)

    @property
    @pulumi.getter(name="outputCardinalityLimit")
    def output_cardinality_limit(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "output_cardinality_limit")

    @output_cardinality_limit.setter
    def output_cardinality_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "output_cardinality_limit", value)

    @property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "parse_mode")

    @parse_mode.setter
    def parse_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parse_mode", value)

    @property
    @pulumi.getter(name="timeSource")
    def time_source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_source")

    @time_source.setter
    def time_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_source", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "transient", value)


if not MYPY:
    class DashboardPanelTracesListPanelQueryMetricsQueryDataArgsDict(TypedDict):
        filters: pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataFilterArgsDict']]]
        metric: pulumi.Input[str]
        aggregation_type: NotRequired[pulumi.Input[str]]
        group_by: NotRequired[pulumi.Input[str]]
        operators: NotRequired[pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorArgsDict']]]]
elif False:
    DashboardPanelTracesListPanelQueryMetricsQueryDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelQueryMetricsQueryDataArgs:
    def __init__(__self__, *,
                 filters: pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataFilterArgs']]],
                 metric: pulumi.Input[str],
                 aggregation_type: Optional[pulumi.Input[str]] = None,
                 group_by: Optional[pulumi.Input[str]] = None,
                 operators: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorArgs']]]] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "metric", metric)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if group_by is not None:
            pulumi.set(__self__, "group_by", group_by)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)

    @property
    @pulumi.getter
    def filters(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataFilterArgs']]]:
        return pulumi.get(self, "filters")

    @filters.setter
    def filters(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataFilterArgs']]]):
        pulumi.set(self, "filters", value)

    @property
    @pulumi.getter
    def metric(self) -> pulumi.Input[str]:
        return pulumi.get(self, "metric")

    @metric.setter
    def metric(self, value: pulumi.Input[str]):
        pulumi.set(self, "metric", value)

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "aggregation_type")

    @aggregation_type.setter
    def aggregation_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregation_type", value)

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "group_by")

    @group_by.setter
    def group_by(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_by", value)

    @property
    @pulumi.getter
    def operators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorArgs']]]]:
        return pulumi.get(self, "operators")

    @operators.setter
    def operators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorArgs']]]]):
        pulumi.set(self, "operators", value)


if not MYPY:
    class DashboardPanelTracesListPanelQueryMetricsQueryDataFilterArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
        negation: NotRequired[pulumi.Input[bool]]
elif False:
    DashboardPanelTracesListPanelQueryMetricsQueryDataFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelQueryMetricsQueryDataFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 negation: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if negation is not None:
            pulumi.set(__self__, "negation", negation)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def negation(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "negation")

    @negation.setter
    def negation(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "negation", value)


if not MYPY:
    class DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorArgsDict(TypedDict):
        operator_name: pulumi.Input[str]
        parameters: pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameterArgsDict']]]
elif False:
    DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorArgs:
    def __init__(__self__, *,
                 operator_name: pulumi.Input[str],
                 parameters: pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameterArgs']]]):
        pulumi.set(__self__, "operator_name", operator_name)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="operatorName")
    def operator_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "operator_name")

    @operator_name.setter
    def operator_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator_name", value)

    @property
    @pulumi.getter
    def parameters(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameterArgs']]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameterArgs']]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameterArgsDict(TypedDict):
        key: pulumi.Input[str]
        value: pulumi.Input[str]
elif False:
    DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeArgsDict(TypedDict):
        begin_bounded_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeArgsDict']]
        complete_literal_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRangeArgsDict']]
elif False:
    DashboardPanelTracesListPanelTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeArgs:
    def __init__(__self__, *,
                 begin_bounded_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeArgs']] = None,
                 complete_literal_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRangeArgs']] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeArgs']]:
        return pulumi.get(self, "begin_bounded_time_range")

    @begin_bounded_time_range.setter
    def begin_bounded_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeArgs']]):
        pulumi.set(self, "begin_bounded_time_range", value)

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRangeArgs']]:
        return pulumi.get(self, "complete_literal_time_range")

    @complete_literal_time_range.setter
    def complete_literal_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRangeArgs']]):
        pulumi.set(self, "complete_literal_time_range", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeArgsDict(TypedDict):
        from_: pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromArgsDict']
        to: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToArgsDict']]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromArgs'],
                 to: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToArgs']] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromArgs']:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromArgs']):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToArgs']]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict']]
        iso8601_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict']]
        literal_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict']]
        relative_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict']]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]:
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]:
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]:
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]:
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict']]
        iso8601_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict']]
        literal_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict']]
        relative_time_range: NotRequired[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict']]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]:
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]:
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]:
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]:
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
elif False:
    DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class DashboardTimeRangeArgsDict(TypedDict):
        begin_bounded_time_range: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeArgsDict']]
        complete_literal_time_range: NotRequired[pulumi.Input['DashboardTimeRangeCompleteLiteralTimeRangeArgsDict']]
elif False:
    DashboardTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeArgs:
    def __init__(__self__, *,
                 begin_bounded_time_range: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeArgs']] = None,
                 complete_literal_time_range: Optional[pulumi.Input['DashboardTimeRangeCompleteLiteralTimeRangeArgs']] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeArgs']]:
        return pulumi.get(self, "begin_bounded_time_range")

    @begin_bounded_time_range.setter
    def begin_bounded_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeArgs']]):
        pulumi.set(self, "begin_bounded_time_range", value)

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeCompleteLiteralTimeRangeArgs']]:
        return pulumi.get(self, "complete_literal_time_range")

    @complete_literal_time_range.setter
    def complete_literal_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeCompleteLiteralTimeRangeArgs']]):
        pulumi.set(self, "complete_literal_time_range", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeArgsDict(TypedDict):
        from_: pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromArgsDict']
        to: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToArgsDict']]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromArgs'],
                 to: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToArgs']] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromArgs']:
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromArgs']):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToArgs']]:
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeFromArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict']]
        iso8601_time_range: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict']]
        literal_time_range: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict']]
        relative_time_range: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict']]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeFromArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]:
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]:
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]:
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]:
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeToArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict']]
        iso8601_time_range: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict']]
        literal_time_range: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict']]
        relative_time_range: NotRequired[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict']]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeToArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]:
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]:
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]:
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]:
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
elif False:
    DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class DashboardTimeRangeCompleteLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    DashboardTimeRangeCompleteLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTimeRangeCompleteLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class DashboardTopologyLabelMapArgsDict(TypedDict):
        datas: pulumi.Input[Sequence[pulumi.Input['DashboardTopologyLabelMapDataArgsDict']]]
elif False:
    DashboardTopologyLabelMapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTopologyLabelMapArgs:
    def __init__(__self__, *,
                 datas: pulumi.Input[Sequence[pulumi.Input['DashboardTopologyLabelMapDataArgs']]]):
        pulumi.set(__self__, "datas", datas)

    @property
    @pulumi.getter
    def datas(self) -> pulumi.Input[Sequence[pulumi.Input['DashboardTopologyLabelMapDataArgs']]]:
        return pulumi.get(self, "datas")

    @datas.setter
    def datas(self, value: pulumi.Input[Sequence[pulumi.Input['DashboardTopologyLabelMapDataArgs']]]):
        pulumi.set(self, "datas", value)


if not MYPY:
    class DashboardTopologyLabelMapDataArgsDict(TypedDict):
        label: pulumi.Input[str]
        values: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    DashboardTopologyLabelMapDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardTopologyLabelMapDataArgs:
    def __init__(__self__, *,
                 label: pulumi.Input[str],
                 values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def label(self) -> pulumi.Input[str]:
        return pulumi.get(self, "label")

    @label.setter
    def label(self, value: pulumi.Input[str]):
        pulumi.set(self, "label", value)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardVariableArgsDict(TypedDict):
        name: pulumi.Input[str]
        source_definition: pulumi.Input['DashboardVariableSourceDefinitionArgsDict']
        allow_multi_select: NotRequired[pulumi.Input[bool]]
        default_value: NotRequired[pulumi.Input[str]]
        display_name: NotRequired[pulumi.Input[str]]
        hide_from_ui: NotRequired[pulumi.Input[bool]]
        id: NotRequired[pulumi.Input[str]]
        include_all_option: NotRequired[pulumi.Input[bool]]
elif False:
    DashboardVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardVariableArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 source_definition: pulumi.Input['DashboardVariableSourceDefinitionArgs'],
                 allow_multi_select: Optional[pulumi.Input[bool]] = None,
                 default_value: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 hide_from_ui: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 include_all_option: Optional[pulumi.Input[bool]] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_definition", source_definition)
        if allow_multi_select is not None:
            pulumi.set(__self__, "allow_multi_select", allow_multi_select)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if hide_from_ui is not None:
            pulumi.set(__self__, "hide_from_ui", hide_from_ui)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if include_all_option is not None:
            pulumi.set(__self__, "include_all_option", include_all_option)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sourceDefinition")
    def source_definition(self) -> pulumi.Input['DashboardVariableSourceDefinitionArgs']:
        return pulumi.get(self, "source_definition")

    @source_definition.setter
    def source_definition(self, value: pulumi.Input['DashboardVariableSourceDefinitionArgs']):
        pulumi.set(self, "source_definition", value)

    @property
    @pulumi.getter(name="allowMultiSelect")
    def allow_multi_select(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "allow_multi_select")

    @allow_multi_select.setter
    def allow_multi_select(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_multi_select", value)

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_value", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="hideFromUi")
    def hide_from_ui(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "hide_from_ui")

    @hide_from_ui.setter
    def hide_from_ui(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "hide_from_ui", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="includeAllOption")
    def include_all_option(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "include_all_option")

    @include_all_option.setter
    def include_all_option(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_all_option", value)


if not MYPY:
    class DashboardVariableSourceDefinitionArgsDict(TypedDict):
        csv_variable_source_definition: NotRequired[pulumi.Input['DashboardVariableSourceDefinitionCsvVariableSourceDefinitionArgsDict']]
        log_query_variable_source_definition: NotRequired[pulumi.Input['DashboardVariableSourceDefinitionLogQueryVariableSourceDefinitionArgsDict']]
        metadata_variable_source_definition: NotRequired[pulumi.Input['DashboardVariableSourceDefinitionMetadataVariableSourceDefinitionArgsDict']]
elif False:
    DashboardVariableSourceDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardVariableSourceDefinitionArgs:
    def __init__(__self__, *,
                 csv_variable_source_definition: Optional[pulumi.Input['DashboardVariableSourceDefinitionCsvVariableSourceDefinitionArgs']] = None,
                 log_query_variable_source_definition: Optional[pulumi.Input['DashboardVariableSourceDefinitionLogQueryVariableSourceDefinitionArgs']] = None,
                 metadata_variable_source_definition: Optional[pulumi.Input['DashboardVariableSourceDefinitionMetadataVariableSourceDefinitionArgs']] = None):
        if csv_variable_source_definition is not None:
            pulumi.set(__self__, "csv_variable_source_definition", csv_variable_source_definition)
        if log_query_variable_source_definition is not None:
            pulumi.set(__self__, "log_query_variable_source_definition", log_query_variable_source_definition)
        if metadata_variable_source_definition is not None:
            pulumi.set(__self__, "metadata_variable_source_definition", metadata_variable_source_definition)

    @property
    @pulumi.getter(name="csvVariableSourceDefinition")
    def csv_variable_source_definition(self) -> Optional[pulumi.Input['DashboardVariableSourceDefinitionCsvVariableSourceDefinitionArgs']]:
        return pulumi.get(self, "csv_variable_source_definition")

    @csv_variable_source_definition.setter
    def csv_variable_source_definition(self, value: Optional[pulumi.Input['DashboardVariableSourceDefinitionCsvVariableSourceDefinitionArgs']]):
        pulumi.set(self, "csv_variable_source_definition", value)

    @property
    @pulumi.getter(name="logQueryVariableSourceDefinition")
    def log_query_variable_source_definition(self) -> Optional[pulumi.Input['DashboardVariableSourceDefinitionLogQueryVariableSourceDefinitionArgs']]:
        return pulumi.get(self, "log_query_variable_source_definition")

    @log_query_variable_source_definition.setter
    def log_query_variable_source_definition(self, value: Optional[pulumi.Input['DashboardVariableSourceDefinitionLogQueryVariableSourceDefinitionArgs']]):
        pulumi.set(self, "log_query_variable_source_definition", value)

    @property
    @pulumi.getter(name="metadataVariableSourceDefinition")
    def metadata_variable_source_definition(self) -> Optional[pulumi.Input['DashboardVariableSourceDefinitionMetadataVariableSourceDefinitionArgs']]:
        return pulumi.get(self, "metadata_variable_source_definition")

    @metadata_variable_source_definition.setter
    def metadata_variable_source_definition(self, value: Optional[pulumi.Input['DashboardVariableSourceDefinitionMetadataVariableSourceDefinitionArgs']]):
        pulumi.set(self, "metadata_variable_source_definition", value)


if not MYPY:
    class DashboardVariableSourceDefinitionCsvVariableSourceDefinitionArgsDict(TypedDict):
        values: pulumi.Input[str]
elif False:
    DashboardVariableSourceDefinitionCsvVariableSourceDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardVariableSourceDefinitionCsvVariableSourceDefinitionArgs:
    def __init__(__self__, *,
                 values: pulumi.Input[str]):
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> pulumi.Input[str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: pulumi.Input[str]):
        pulumi.set(self, "values", value)


if not MYPY:
    class DashboardVariableSourceDefinitionLogQueryVariableSourceDefinitionArgsDict(TypedDict):
        field: pulumi.Input[str]
        query: pulumi.Input[str]
elif False:
    DashboardVariableSourceDefinitionLogQueryVariableSourceDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardVariableSourceDefinitionLogQueryVariableSourceDefinitionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 query: pulumi.Input[str]):
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)


if not MYPY:
    class DashboardVariableSourceDefinitionMetadataVariableSourceDefinitionArgsDict(TypedDict):
        filter: pulumi.Input[str]
        key: pulumi.Input[str]
elif False:
    DashboardVariableSourceDefinitionMetadataVariableSourceDefinitionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DashboardVariableSourceDefinitionMetadataVariableSourceDefinitionArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input[str],
                 key: pulumi.Input[str]):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class DataForwardingDestinationAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        AWS IAM authentication method used for access. Possible values are: 1. `AccessKey` 2. `RoleBased`
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        The AWS Access ID to access the S3 bucket.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        The AWS Role ARN to access the S3 bucket.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        The AWS Secret Key to access the S3 bucket.
        """
elif False:
    DataForwardingDestinationAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataForwardingDestinationAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: AWS IAM authentication method used for access. Possible values are: 1. `AccessKey` 2. `RoleBased`
        :param pulumi.Input[str] access_key: The AWS Access ID to access the S3 bucket.
        :param pulumi.Input[str] role_arn: The AWS Role ARN to access the S3 bucket.
        :param pulumi.Input[str] secret_key: The AWS Secret Key to access the S3 bucket.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        AWS IAM authentication method used for access. Possible values are: 1. `AccessKey` 2. `RoleBased`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Access ID to access the S3 bucket.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Role ARN to access the S3 bucket.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        The AWS Secret Key to access the S3 bucket.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class ElbSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    ElbSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class ElbSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    ElbSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class ElbSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    ElbSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class ElbSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the bucket.
        """
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        path_expression: NotRequired[pulumi.Input[str]]
        """
        The path to the data.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    ElbSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        :param pulumi.Input[str] bucket_name: The name of the bucket.
        :param pulumi.Input[str] path_expression: The path to the data.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[Sequence[pulumi.Input['ElbSourcePathSnsTopicOrSubscriptionArnArgs']]] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ElbSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class ElbSourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    ElbSourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbSourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class ElbSourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    ElbSourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbSourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class ElbSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    ElbSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ElbSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GcpMetricsSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be `service_account`.
        """
        access_key: NotRequired[pulumi.Input[str]]
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        """
        As per the service_account.json downloaded from GCP
        """
        auth_uri: NotRequired[pulumi.Input[str]]
        """
        As per the service_account.json downloaded from GCP
        """
        client_email: NotRequired[pulumi.Input[str]]
        """
        As per the service_account.json downloaded from GCP
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        As per the service_account.json downloaded from GCP
        """
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        """
        As per the service_account.json downloaded from GCP
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        As per the service_account.json downloaded from GCP
        """
        private_key_id: NotRequired[pulumi.Input[str]]
        """
        As per the service_account.json downloaded from GCP
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        As per the service_account.json downloaded from GCP
        """
        region: NotRequired[pulumi.Input[str]]
        role_arn: NotRequired[pulumi.Input[str]]
        secret_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
        """
        As per the service_account.json downloaded from GCP
        """
elif False:
    GcpMetricsSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpMetricsSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be `service_account`.
        :param pulumi.Input[str] auth_provider_x509_cert_url: As per the service_account.json downloaded from GCP
        :param pulumi.Input[str] auth_uri: As per the service_account.json downloaded from GCP
        :param pulumi.Input[str] client_email: As per the service_account.json downloaded from GCP
        :param pulumi.Input[str] client_id: As per the service_account.json downloaded from GCP
        :param pulumi.Input[str] client_x509_cert_url: As per the service_account.json downloaded from GCP
        :param pulumi.Input[str] private_key: As per the service_account.json downloaded from GCP
        :param pulumi.Input[str] private_key_id: As per the service_account.json downloaded from GCP
        :param pulumi.Input[str] project_id: As per the service_account.json downloaded from GCP
        :param pulumi.Input[str] token_uri: As per the service_account.json downloaded from GCP
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be `service_account`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class GcpMetricsSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    GcpMetricsSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpMetricsSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class GcpMetricsSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    GcpMetricsSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpMetricsSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class GcpMetricsSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Type of polling source. This has to be `GcpMetricsPath`.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathCustomServiceArgsDict']]]]
        """
        Sumoloigc provides list of services that can be used in limit_to_services for which metrics would be collected. Custom Services allow you to define your own service w.r.t. metric collection. You can provide list of metric prefixes that should be collected as part of the custom service. This provides fine-grain control w.r.t. what all metrics are ingested by sumologic.
        """
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of regions for which metrics would be collected (Empty to collect from all regions)
        """
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of services from which metrics would be collected
        """
        namespace: NotRequired[pulumi.Input[str]]
        path_expression: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    GcpMetricsSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpMetricsSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: Type of polling source. This has to be `GcpMetricsPath`.
        :param pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathCustomServiceArgs']]] custom_services: Sumoloigc provides list of services that can be used in limit_to_services for which metrics would be collected. Custom Services allow you to define your own service w.r.t. metric collection. You can provide list of metric prefixes that should be collected as part of the custom service. This provides fine-grain control w.r.t. what all metrics are ingested by sumologic.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_regions: List of regions for which metrics would be collected (Empty to collect from all regions)
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_services: List of services from which metrics would be collected
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of polling source. This has to be `GcpMetricsPath`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathCustomServiceArgs']]]]:
        """
        Sumoloigc provides list of services that can be used in limit_to_services for which metrics would be collected. Custom Services allow you to define your own service w.r.t. metric collection. You can provide list of metric prefixes that should be collected as part of the custom service. This provides fine-grain control w.r.t. what all metrics are ingested by sumologic.
        """
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of regions for which metrics would be collected (Empty to collect from all regions)
        """
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of services from which metrics would be collected
        """
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GcpMetricsSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class GcpMetricsSourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of metric type prefixes. Eg: `["compute.googleapis.com/instance/","compute.googleapis.com/guest/"]`
        """
        service_name: NotRequired[pulumi.Input[str]]
        """
        Name of the custom service you want to define.
        """
elif False:
    GcpMetricsSourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpMetricsSourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] prefixes: List of metric type prefixes. Eg: `["compute.googleapis.com/instance/","compute.googleapis.com/guest/"]`
        :param pulumi.Input[str] service_name: Name of the custom service you want to define.
        """
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of metric type prefixes. Eg: `["compute.googleapis.com/instance/","compute.googleapis.com/guest/"]`
        """
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the custom service you want to define.
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class GcpMetricsSourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    GcpMetricsSourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpMetricsSourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class GcpMetricsSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    GcpMetricsSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpMetricsSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GcpSourceAuthenticationArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
elif False:
    GcpSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GcpSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    GcpSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class GcpSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    GcpSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class GcpSourcePathArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
elif False:
    GcpSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GcpSourcePathArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class HierarchyFilterArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        Filtering key.
        """
        value: pulumi.Input[str]
        """
        Value required for the filtering key.
        """
elif False:
    HierarchyFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyFilterArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: Filtering key.
        :param pulumi.Input[str] value: Value required for the filtering key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Filtering key.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value required for the filtering key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class HierarchyLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict']
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs'] level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']:
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_level: NotRequired[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict']]
        """
        Next level without a condition.

        The following attributes are exported:
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict']]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_level: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']] = None,
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs'] next_level: Next level without a condition.
               
               The following attributes are exported:
        :param pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @next_level.setter
    def next_level(self, value: Optional[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs']]):
        pulumi.set(self, "next_level", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs']]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict(TypedDict):
        condition: pulumi.Input[str]
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict']
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[str],
                 level: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        """
        :param pulumi.Input[str] condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> pulumi.Input[str]:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[str]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def level(self) -> pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']:
        return pulumi.get(self, "level")

    @level.setter
    def level(self, value: pulumi.Input['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs']):
        pulumi.set(self, "level", value)


if not MYPY:
    class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict(TypedDict):
        entity_type: pulumi.Input[str]
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        next_levels_with_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Zero or more next levels with conditions.
        """
elif False:
    HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[str],
                 next_levels_with_conditions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[str]:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "entity_type", value)

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")

    @next_levels_with_conditions.setter
    def next_levels_with_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "next_levels_with_conditions", value)


if not MYPY:
    class HttpSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    HttpSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class HttpSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    HttpSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HttpSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class KineisLogSourceAuthenticationArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication` or `NoAuthentication`
        """
elif False:
    KineisLogSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KineisLogSourceAuthenticationArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication` or `NoAuthentication`
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication` or `NoAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class KineisLogSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    KineisLogSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KineisLogSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class KineisLogSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    KineisLogSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KineisLogSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class KineisLogSourcePathArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the bucket. This is needed if using type `KinesisLogPath`.
        """
        path_expression: NotRequired[pulumi.Input[str]]
        """
        The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must include `http-endpoint-failed/`.
        """
        scan_interval: NotRequired[pulumi.Input[int]]
        """
        The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Must be either `KinesisLogPath` or `NoPathExpression`
        """
elif False:
    KineisLogSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KineisLogSourcePathArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 scan_interval: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: The name of the bucket. This is needed if using type `KinesisLogPath`.
        :param pulumi.Input[str] path_expression: The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must include `http-endpoint-failed/`.
        :param pulumi.Input[int] scan_interval: The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        :param pulumi.Input[str] type: Must be either `KinesisLogPath` or `NoPathExpression`
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if scan_interval is not None:
            pulumi.set(__self__, "scan_interval", scan_interval)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the bucket. This is needed if using type `KinesisLogPath`.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must include `http-endpoint-failed/`.
        """
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter(name="scanInterval")
    def scan_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        """
        return pulumi.get(self, "scan_interval")

    @scan_interval.setter
    def scan_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_interval", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Must be either `KinesisLogPath` or `NoPathExpression`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class KinesisLogSourceAuthenticationArgsDict(TypedDict):
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication` or `NoAuthentication`
        """
elif False:
    KinesisLogSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KinesisLogSourceAuthenticationArgs:
    def __init__(__self__, *,
                 access_key: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication` or `NoAuthentication`
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication` or `NoAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class KinesisLogSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    KinesisLogSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KinesisLogSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class KinesisLogSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    KinesisLogSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KinesisLogSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class KinesisLogSourcePathArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the bucket. This is needed if using type `KinesisLogPath`.
        """
        path_expression: NotRequired[pulumi.Input[str]]
        """
        The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must include `http-endpoint-failed/`.
        """
        scan_interval: NotRequired[pulumi.Input[int]]
        """
        The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        Must be either `KinesisLogPath` or `NoPathExpression`
        """
elif False:
    KinesisLogSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KinesisLogSourcePathArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 scan_interval: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: The name of the bucket. This is needed if using type `KinesisLogPath`.
        :param pulumi.Input[str] path_expression: The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must include `http-endpoint-failed/`.
        :param pulumi.Input[int] scan_interval: The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        :param pulumi.Input[str] type: Must be either `KinesisLogPath` or `NoPathExpression`
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if scan_interval is not None:
            pulumi.set(__self__, "scan_interval", scan_interval)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the bucket. This is needed if using type `KinesisLogPath`.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must include `http-endpoint-failed/`.
        """
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter(name="scanInterval")
    def scan_interval(self) -> Optional[pulumi.Input[int]]:
        """
        The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        """
        return pulumi.get(self, "scan_interval")

    @scan_interval.setter
    def scan_interval(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scan_interval", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Must be either `KinesisLogPath` or `NoPathExpression`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class KinesisMetricsSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
elif False:
    KinesisMetricsSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KinesisMetricsSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class KinesisMetricsSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    KinesisMetricsSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KinesisMetricsSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class KinesisMetricsSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    KinesisMetricsSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KinesisMetricsSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class KinesisMetricsSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be `KinesisMetricPath`
        """
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['KinesisMetricsSourcePathTagFilterArgsDict']]]]
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
elif False:
    KinesisMetricsSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KinesisMetricsSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['KinesisMetricsSourcePathTagFilterArgs']]]] = None):
        """
        :param pulumi.Input[str] type: Must be `KinesisMetricPath`
        :param pulumi.Input[Sequence[pulumi.Input['KinesisMetricsSourcePathTagFilterArgs']]] tag_filters: Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        pulumi.set(__self__, "type", type)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be `KinesisMetricPath`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KinesisMetricsSourcePathTagFilterArgs']]]]:
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KinesisMetricsSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)


if not MYPY:
    class KinesisMetricsSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        This value has to be set to `TagFilters`
        """
elif False:
    KinesisMetricsSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KinesisMetricsSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        :param pulumi.Input[str] type: This value has to be set to `TagFilters`
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class LocalFileSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    LocalFileSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocalFileSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class LocalFileSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        """
        The name of the local file source. This is required, and has to be unique. Changing this will force recreation the source.
        """
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    LocalFileSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LocalFileSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the local file source. This is required, and has to be unique. Changing this will force recreation the source.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the local file source. This is required, and has to be unique. Changing this will force recreation the source.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class LogSearchQueryParameterArgsDict(TypedDict):
        data_type: pulumi.Input[str]
        """
        The data type of the parameter. Supported values are:
        1. `NUMBER`
        2. `STRING`
        3. `ANY`
        4. `KEYWORD`
        """
        name: pulumi.Input[str]
        """
        Name of the search.
        """
        value: pulumi.Input[str]
        """
        Default value of scheduled search parameter.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the search.
        """
elif False:
    LogSearchQueryParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchQueryParameterArgs:
    def __init__(__self__, *,
                 data_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 value: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] data_type: The data type of the parameter. Supported values are:
               1. `NUMBER`
               2. `STRING`
               3. `ANY`
               4. `KEYWORD`
        :param pulumi.Input[str] name: Name of the search.
        :param pulumi.Input[str] value: Default value of scheduled search parameter.
        :param pulumi.Input[str] description: Description of the search.
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> pulumi.Input[str]:
        """
        The data type of the parameter. Supported values are:
        1. `NUMBER`
        2. `STRING`
        3. `ANY`
        4. `KEYWORD`
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the search.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Default value of scheduled search parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the search.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class LogSearchScheduleArgsDict(TypedDict):
        notification: pulumi.Input['LogSearchScheduleNotificationArgsDict']
        """
        Notification of the log search. See
        notification schema
        """
        parseable_time_range: pulumi.Input['LogSearchScheduleParseableTimeRangeArgsDict']
        """
        Time range of the scheduled log search. See
        time range schema
        """
        schedule_type: pulumi.Input[str]
        """
        Run schedule of the scheduled search. Set to "Custom" to specify the schedule with
        a CRON expression. Possible schedule types are: `RealTime`, `15Minutes`, `1Hour`, `2Hours`, `4Hours`, `6Hours`,
        `8Hours`, `12Hours`, `1Day`, `1Week`, `Custom`.

        > With `Custom`, `1Day` and `1Week` schedule types you need to provide the corresponding cron expression
        to determine when to actually run the search. E.g. valid cron for `1Day` is `0 0 16 ? * 2-6 *`.
        """
        time_zone: pulumi.Input[str]
        """
        Time zone for the scheduled log search. Either an abbreviation such as "PST",
        a full name such as "America/Los_Angeles", or a custom ID such as "GMT-8:00". Note that the support of
        abbreviations is for JDK 1.1.x compatibility only and full names should be used.
        """
        cron_expression: NotRequired[pulumi.Input[str]]
        """
        Cron-like expression specifying the search's schedule. `schedule_type` must be set
        to "Custom", otherwise, `schedule_type` takes precedence over `cron_expression`.
        """
        mute_error_emails: NotRequired[pulumi.Input[bool]]
        """
        If enabled, emails are not sent out in case of errors with the search.
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['LogSearchScheduleParameterArgsDict']]]]
        threshold: NotRequired[pulumi.Input['LogSearchScheduleThresholdArgsDict']]
        """
        Threshold for when to send notification. See
        threshold schema
        """
elif False:
    LogSearchScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleArgs:
    def __init__(__self__, *,
                 notification: pulumi.Input['LogSearchScheduleNotificationArgs'],
                 parseable_time_range: pulumi.Input['LogSearchScheduleParseableTimeRangeArgs'],
                 schedule_type: pulumi.Input[str],
                 time_zone: pulumi.Input[str],
                 cron_expression: Optional[pulumi.Input[str]] = None,
                 mute_error_emails: Optional[pulumi.Input[bool]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['LogSearchScheduleParameterArgs']]]] = None,
                 threshold: Optional[pulumi.Input['LogSearchScheduleThresholdArgs']] = None):
        """
        :param pulumi.Input['LogSearchScheduleNotificationArgs'] notification: Notification of the log search. See
               notification schema
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeArgs'] parseable_time_range: Time range of the scheduled log search. See
               time range schema
        :param pulumi.Input[str] schedule_type: Run schedule of the scheduled search. Set to "Custom" to specify the schedule with
               a CRON expression. Possible schedule types are: `RealTime`, `15Minutes`, `1Hour`, `2Hours`, `4Hours`, `6Hours`,
               `8Hours`, `12Hours`, `1Day`, `1Week`, `Custom`.
               
               > With `Custom`, `1Day` and `1Week` schedule types you need to provide the corresponding cron expression
               to determine when to actually run the search. E.g. valid cron for `1Day` is `0 0 16 ? * 2-6 *`.
        :param pulumi.Input[str] time_zone: Time zone for the scheduled log search. Either an abbreviation such as "PST",
               a full name such as "America/Los_Angeles", or a custom ID such as "GMT-8:00". Note that the support of
               abbreviations is for JDK 1.1.x compatibility only and full names should be used.
        :param pulumi.Input[str] cron_expression: Cron-like expression specifying the search's schedule. `schedule_type` must be set
               to "Custom", otherwise, `schedule_type` takes precedence over `cron_expression`.
        :param pulumi.Input[bool] mute_error_emails: If enabled, emails are not sent out in case of errors with the search.
        :param pulumi.Input['LogSearchScheduleThresholdArgs'] threshold: Threshold for when to send notification. See
               threshold schema
        """
        pulumi.set(__self__, "notification", notification)
        pulumi.set(__self__, "parseable_time_range", parseable_time_range)
        pulumi.set(__self__, "schedule_type", schedule_type)
        pulumi.set(__self__, "time_zone", time_zone)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if mute_error_emails is not None:
            pulumi.set(__self__, "mute_error_emails", mute_error_emails)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def notification(self) -> pulumi.Input['LogSearchScheduleNotificationArgs']:
        """
        Notification of the log search. See
        notification schema
        """
        return pulumi.get(self, "notification")

    @notification.setter
    def notification(self, value: pulumi.Input['LogSearchScheduleNotificationArgs']):
        pulumi.set(self, "notification", value)

    @property
    @pulumi.getter(name="parseableTimeRange")
    def parseable_time_range(self) -> pulumi.Input['LogSearchScheduleParseableTimeRangeArgs']:
        """
        Time range of the scheduled log search. See
        time range schema
        """
        return pulumi.get(self, "parseable_time_range")

    @parseable_time_range.setter
    def parseable_time_range(self, value: pulumi.Input['LogSearchScheduleParseableTimeRangeArgs']):
        pulumi.set(self, "parseable_time_range", value)

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> pulumi.Input[str]:
        """
        Run schedule of the scheduled search. Set to "Custom" to specify the schedule with
        a CRON expression. Possible schedule types are: `RealTime`, `15Minutes`, `1Hour`, `2Hours`, `4Hours`, `6Hours`,
        `8Hours`, `12Hours`, `1Day`, `1Week`, `Custom`.

        > With `Custom`, `1Day` and `1Week` schedule types you need to provide the corresponding cron expression
        to determine when to actually run the search. E.g. valid cron for `1Day` is `0 0 16 ? * 2-6 *`.
        """
        return pulumi.get(self, "schedule_type")

    @schedule_type.setter
    def schedule_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "schedule_type", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        """
        Time zone for the scheduled log search. Either an abbreviation such as "PST",
        a full name such as "America/Los_Angeles", or a custom ID such as "GMT-8:00". Note that the support of
        abbreviations is for JDK 1.1.x compatibility only and full names should be used.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[pulumi.Input[str]]:
        """
        Cron-like expression specifying the search's schedule. `schedule_type` must be set
        to "Custom", otherwise, `schedule_type` takes precedence over `cron_expression`.
        """
        return pulumi.get(self, "cron_expression")

    @cron_expression.setter
    def cron_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cron_expression", value)

    @property
    @pulumi.getter(name="muteErrorEmails")
    def mute_error_emails(self) -> Optional[pulumi.Input[bool]]:
        """
        If enabled, emails are not sent out in case of errors with the search.
        """
        return pulumi.get(self, "mute_error_emails")

    @mute_error_emails.setter
    def mute_error_emails(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "mute_error_emails", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['LogSearchScheduleParameterArgs']]]]:
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['LogSearchScheduleParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input['LogSearchScheduleThresholdArgs']]:
        """
        Threshold for when to send notification. See
        threshold schema
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input['LogSearchScheduleThresholdArgs']]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class LogSearchScheduleNotificationArgsDict(TypedDict):
        alert_search_notification: NotRequired[pulumi.Input['LogSearchScheduleNotificationAlertSearchNotificationArgsDict']]
        """
        Run an script action. See
        alert_search_notification schema for details.
        """
        cse_signal_notification: NotRequired[pulumi.Input['LogSearchScheduleNotificationCseSignalNotificationArgsDict']]
        """
        Create a CSE signal with a scheduled search.
        See cse_signal_notification schema schema for details.
        """
        email_search_notification: NotRequired[pulumi.Input['LogSearchScheduleNotificationEmailSearchNotificationArgsDict']]
        """
        Send an alert via email. See
        email_search_notification schema schema for details.
        """
        save_to_lookup_notification: NotRequired[pulumi.Input['LogSearchScheduleNotificationSaveToLookupNotificationArgsDict']]
        """
        Save results to a Lookup Table. See
        save_to_lookup_notification schema schema for details.
        """
        save_to_view_notification: NotRequired[pulumi.Input['LogSearchScheduleNotificationSaveToViewNotificationArgsDict']]
        """
        Save results to an index. See
        save_to_view_notification schema schema for details.
        """
        service_now_search_notification: NotRequired[pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationArgsDict']]
        """
        Send results to Service Now. See
        service_now_search_notification schema schema for details.
        """
        webhook_search_notification: NotRequired[pulumi.Input['LogSearchScheduleNotificationWebhookSearchNotificationArgsDict']]
        """
        Send an alert via Webhook. See
        webhook_search_notification schema schema for details.
        """
elif False:
    LogSearchScheduleNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleNotificationArgs:
    def __init__(__self__, *,
                 alert_search_notification: Optional[pulumi.Input['LogSearchScheduleNotificationAlertSearchNotificationArgs']] = None,
                 cse_signal_notification: Optional[pulumi.Input['LogSearchScheduleNotificationCseSignalNotificationArgs']] = None,
                 email_search_notification: Optional[pulumi.Input['LogSearchScheduleNotificationEmailSearchNotificationArgs']] = None,
                 save_to_lookup_notification: Optional[pulumi.Input['LogSearchScheduleNotificationSaveToLookupNotificationArgs']] = None,
                 save_to_view_notification: Optional[pulumi.Input['LogSearchScheduleNotificationSaveToViewNotificationArgs']] = None,
                 service_now_search_notification: Optional[pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationArgs']] = None,
                 webhook_search_notification: Optional[pulumi.Input['LogSearchScheduleNotificationWebhookSearchNotificationArgs']] = None):
        """
        :param pulumi.Input['LogSearchScheduleNotificationAlertSearchNotificationArgs'] alert_search_notification: Run an script action. See
               alert_search_notification schema for details.
        :param pulumi.Input['LogSearchScheduleNotificationCseSignalNotificationArgs'] cse_signal_notification: Create a CSE signal with a scheduled search.
               See cse_signal_notification schema schema for details.
        :param pulumi.Input['LogSearchScheduleNotificationEmailSearchNotificationArgs'] email_search_notification: Send an alert via email. See
               email_search_notification schema schema for details.
        :param pulumi.Input['LogSearchScheduleNotificationSaveToLookupNotificationArgs'] save_to_lookup_notification: Save results to a Lookup Table. See
               save_to_lookup_notification schema schema for details.
        :param pulumi.Input['LogSearchScheduleNotificationSaveToViewNotificationArgs'] save_to_view_notification: Save results to an index. See
               save_to_view_notification schema schema for details.
        :param pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationArgs'] service_now_search_notification: Send results to Service Now. See
               service_now_search_notification schema schema for details.
        :param pulumi.Input['LogSearchScheduleNotificationWebhookSearchNotificationArgs'] webhook_search_notification: Send an alert via Webhook. See
               webhook_search_notification schema schema for details.
        """
        if alert_search_notification is not None:
            pulumi.set(__self__, "alert_search_notification", alert_search_notification)
        if cse_signal_notification is not None:
            pulumi.set(__self__, "cse_signal_notification", cse_signal_notification)
        if email_search_notification is not None:
            pulumi.set(__self__, "email_search_notification", email_search_notification)
        if save_to_lookup_notification is not None:
            pulumi.set(__self__, "save_to_lookup_notification", save_to_lookup_notification)
        if save_to_view_notification is not None:
            pulumi.set(__self__, "save_to_view_notification", save_to_view_notification)
        if service_now_search_notification is not None:
            pulumi.set(__self__, "service_now_search_notification", service_now_search_notification)
        if webhook_search_notification is not None:
            pulumi.set(__self__, "webhook_search_notification", webhook_search_notification)

    @property
    @pulumi.getter(name="alertSearchNotification")
    def alert_search_notification(self) -> Optional[pulumi.Input['LogSearchScheduleNotificationAlertSearchNotificationArgs']]:
        """
        Run an script action. See
        alert_search_notification schema for details.
        """
        return pulumi.get(self, "alert_search_notification")

    @alert_search_notification.setter
    def alert_search_notification(self, value: Optional[pulumi.Input['LogSearchScheduleNotificationAlertSearchNotificationArgs']]):
        pulumi.set(self, "alert_search_notification", value)

    @property
    @pulumi.getter(name="cseSignalNotification")
    def cse_signal_notification(self) -> Optional[pulumi.Input['LogSearchScheduleNotificationCseSignalNotificationArgs']]:
        """
        Create a CSE signal with a scheduled search.
        See cse_signal_notification schema schema for details.
        """
        return pulumi.get(self, "cse_signal_notification")

    @cse_signal_notification.setter
    def cse_signal_notification(self, value: Optional[pulumi.Input['LogSearchScheduleNotificationCseSignalNotificationArgs']]):
        pulumi.set(self, "cse_signal_notification", value)

    @property
    @pulumi.getter(name="emailSearchNotification")
    def email_search_notification(self) -> Optional[pulumi.Input['LogSearchScheduleNotificationEmailSearchNotificationArgs']]:
        """
        Send an alert via email. See
        email_search_notification schema schema for details.
        """
        return pulumi.get(self, "email_search_notification")

    @email_search_notification.setter
    def email_search_notification(self, value: Optional[pulumi.Input['LogSearchScheduleNotificationEmailSearchNotificationArgs']]):
        pulumi.set(self, "email_search_notification", value)

    @property
    @pulumi.getter(name="saveToLookupNotification")
    def save_to_lookup_notification(self) -> Optional[pulumi.Input['LogSearchScheduleNotificationSaveToLookupNotificationArgs']]:
        """
        Save results to a Lookup Table. See
        save_to_lookup_notification schema schema for details.
        """
        return pulumi.get(self, "save_to_lookup_notification")

    @save_to_lookup_notification.setter
    def save_to_lookup_notification(self, value: Optional[pulumi.Input['LogSearchScheduleNotificationSaveToLookupNotificationArgs']]):
        pulumi.set(self, "save_to_lookup_notification", value)

    @property
    @pulumi.getter(name="saveToViewNotification")
    def save_to_view_notification(self) -> Optional[pulumi.Input['LogSearchScheduleNotificationSaveToViewNotificationArgs']]:
        """
        Save results to an index. See
        save_to_view_notification schema schema for details.
        """
        return pulumi.get(self, "save_to_view_notification")

    @save_to_view_notification.setter
    def save_to_view_notification(self, value: Optional[pulumi.Input['LogSearchScheduleNotificationSaveToViewNotificationArgs']]):
        pulumi.set(self, "save_to_view_notification", value)

    @property
    @pulumi.getter(name="serviceNowSearchNotification")
    def service_now_search_notification(self) -> Optional[pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationArgs']]:
        """
        Send results to Service Now. See
        service_now_search_notification schema schema for details.
        """
        return pulumi.get(self, "service_now_search_notification")

    @service_now_search_notification.setter
    def service_now_search_notification(self, value: Optional[pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationArgs']]):
        pulumi.set(self, "service_now_search_notification", value)

    @property
    @pulumi.getter(name="webhookSearchNotification")
    def webhook_search_notification(self) -> Optional[pulumi.Input['LogSearchScheduleNotificationWebhookSearchNotificationArgs']]:
        """
        Send an alert via Webhook. See
        webhook_search_notification schema schema for details.
        """
        return pulumi.get(self, "webhook_search_notification")

    @webhook_search_notification.setter
    def webhook_search_notification(self, value: Optional[pulumi.Input['LogSearchScheduleNotificationWebhookSearchNotificationArgs']]):
        pulumi.set(self, "webhook_search_notification", value)


if not MYPY:
    class LogSearchScheduleNotificationAlertSearchNotificationArgsDict(TypedDict):
        source_id: pulumi.Input[str]
        """
        Identifier of the collector's source.
        """
elif False:
    LogSearchScheduleNotificationAlertSearchNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleNotificationAlertSearchNotificationArgs:
    def __init__(__self__, *,
                 source_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] source_id: Identifier of the collector's source.
        """
        pulumi.set(__self__, "source_id", source_id)

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> pulumi.Input[str]:
        """
        Identifier of the collector's source.
        """
        return pulumi.get(self, "source_id")

    @source_id.setter
    def source_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_id", value)


if not MYPY:
    class LogSearchScheduleNotificationCseSignalNotificationArgsDict(TypedDict):
        record_type: pulumi.Input[str]
        """
        Name of the Cloud SIEM Enterprise Record to be created.
        """
elif False:
    LogSearchScheduleNotificationCseSignalNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleNotificationCseSignalNotificationArgs:
    def __init__(__self__, *,
                 record_type: pulumi.Input[str]):
        """
        :param pulumi.Input[str] record_type: Name of the Cloud SIEM Enterprise Record to be created.
        """
        pulumi.set(__self__, "record_type", record_type)

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> pulumi.Input[str]:
        """
        Name of the Cloud SIEM Enterprise Record to be created.
        """
        return pulumi.get(self, "record_type")

    @record_type.setter
    def record_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "record_type", value)


if not MYPY:
    class LogSearchScheduleNotificationEmailSearchNotificationArgsDict(TypedDict):
        to_lists: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of email recipients.
        """
        include_csv_attachment: NotRequired[pulumi.Input[bool]]
        """
        If the search results should be included in the notification email
        as a CSV attachment.
        """
        include_histogram: NotRequired[pulumi.Input[bool]]
        """
        If the search result histogram should be included in the notification email.
        """
        include_query: NotRequired[pulumi.Input[bool]]
        """
        If the search query should be included in the notification email.
        """
        include_result_set: NotRequired[pulumi.Input[bool]]
        """
        If the search result set should be included in the notification email.
        """
        subject_template: NotRequired[pulumi.Input[str]]
        """
        Subject of the email. If the notification is scheduled with a threshold,
        the default subject template will be `Search Alert: {{AlertCondition}} results found for {{SearchName}}`.
        For email notifications without a threshold, the default subject template is `Search Results: {{SearchName}}`.
        """
elif False:
    LogSearchScheduleNotificationEmailSearchNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleNotificationEmailSearchNotificationArgs:
    def __init__(__self__, *,
                 to_lists: pulumi.Input[Sequence[pulumi.Input[str]]],
                 include_csv_attachment: Optional[pulumi.Input[bool]] = None,
                 include_histogram: Optional[pulumi.Input[bool]] = None,
                 include_query: Optional[pulumi.Input[bool]] = None,
                 include_result_set: Optional[pulumi.Input[bool]] = None,
                 subject_template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] to_lists: A list of email recipients.
        :param pulumi.Input[bool] include_csv_attachment: If the search results should be included in the notification email
               as a CSV attachment.
        :param pulumi.Input[bool] include_histogram: If the search result histogram should be included in the notification email.
        :param pulumi.Input[bool] include_query: If the search query should be included in the notification email.
        :param pulumi.Input[bool] include_result_set: If the search result set should be included in the notification email.
        :param pulumi.Input[str] subject_template: Subject of the email. If the notification is scheduled with a threshold,
               the default subject template will be `Search Alert: {{AlertCondition}} results found for {{SearchName}}`.
               For email notifications without a threshold, the default subject template is `Search Results: {{SearchName}}`.
        """
        pulumi.set(__self__, "to_lists", to_lists)
        if include_csv_attachment is not None:
            pulumi.set(__self__, "include_csv_attachment", include_csv_attachment)
        if include_histogram is not None:
            pulumi.set(__self__, "include_histogram", include_histogram)
        if include_query is not None:
            pulumi.set(__self__, "include_query", include_query)
        if include_result_set is not None:
            pulumi.set(__self__, "include_result_set", include_result_set)
        if subject_template is not None:
            pulumi.set(__self__, "subject_template", subject_template)

    @property
    @pulumi.getter(name="toLists")
    def to_lists(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of email recipients.
        """
        return pulumi.get(self, "to_lists")

    @to_lists.setter
    def to_lists(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "to_lists", value)

    @property
    @pulumi.getter(name="includeCsvAttachment")
    def include_csv_attachment(self) -> Optional[pulumi.Input[bool]]:
        """
        If the search results should be included in the notification email
        as a CSV attachment.
        """
        return pulumi.get(self, "include_csv_attachment")

    @include_csv_attachment.setter
    def include_csv_attachment(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_csv_attachment", value)

    @property
    @pulumi.getter(name="includeHistogram")
    def include_histogram(self) -> Optional[pulumi.Input[bool]]:
        """
        If the search result histogram should be included in the notification email.
        """
        return pulumi.get(self, "include_histogram")

    @include_histogram.setter
    def include_histogram(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_histogram", value)

    @property
    @pulumi.getter(name="includeQuery")
    def include_query(self) -> Optional[pulumi.Input[bool]]:
        """
        If the search query should be included in the notification email.
        """
        return pulumi.get(self, "include_query")

    @include_query.setter
    def include_query(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_query", value)

    @property
    @pulumi.getter(name="includeResultSet")
    def include_result_set(self) -> Optional[pulumi.Input[bool]]:
        """
        If the search result set should be included in the notification email.
        """
        return pulumi.get(self, "include_result_set")

    @include_result_set.setter
    def include_result_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_result_set", value)

    @property
    @pulumi.getter(name="subjectTemplate")
    def subject_template(self) -> Optional[pulumi.Input[str]]:
        """
        Subject of the email. If the notification is scheduled with a threshold,
        the default subject template will be `Search Alert: {{AlertCondition}} results found for {{SearchName}}`.
        For email notifications without a threshold, the default subject template is `Search Results: {{SearchName}}`.
        """
        return pulumi.get(self, "subject_template")

    @subject_template.setter
    def subject_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject_template", value)


if not MYPY:
    class LogSearchScheduleNotificationSaveToLookupNotificationArgsDict(TypedDict):
        is_lookup_merge_operation: pulumi.Input[bool]
        """
        Whether to merge the file contents with existing data in the lookup table.
        """
        lookup_file_path: pulumi.Input[str]
        """
        Path of the lookup table to save the results to.
        """
elif False:
    LogSearchScheduleNotificationSaveToLookupNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleNotificationSaveToLookupNotificationArgs:
    def __init__(__self__, *,
                 is_lookup_merge_operation: pulumi.Input[bool],
                 lookup_file_path: pulumi.Input[str]):
        """
        :param pulumi.Input[bool] is_lookup_merge_operation: Whether to merge the file contents with existing data in the lookup table.
        :param pulumi.Input[str] lookup_file_path: Path of the lookup table to save the results to.
        """
        pulumi.set(__self__, "is_lookup_merge_operation", is_lookup_merge_operation)
        pulumi.set(__self__, "lookup_file_path", lookup_file_path)

    @property
    @pulumi.getter(name="isLookupMergeOperation")
    def is_lookup_merge_operation(self) -> pulumi.Input[bool]:
        """
        Whether to merge the file contents with existing data in the lookup table.
        """
        return pulumi.get(self, "is_lookup_merge_operation")

    @is_lookup_merge_operation.setter
    def is_lookup_merge_operation(self, value: pulumi.Input[bool]):
        pulumi.set(self, "is_lookup_merge_operation", value)

    @property
    @pulumi.getter(name="lookupFilePath")
    def lookup_file_path(self) -> pulumi.Input[str]:
        """
        Path of the lookup table to save the results to.
        """
        return pulumi.get(self, "lookup_file_path")

    @lookup_file_path.setter
    def lookup_file_path(self, value: pulumi.Input[str]):
        pulumi.set(self, "lookup_file_path", value)


if not MYPY:
    class LogSearchScheduleNotificationSaveToViewNotificationArgsDict(TypedDict):
        view_name: pulumi.Input[str]
        """
        Name of the View(Index) to save the results to.
        """
elif False:
    LogSearchScheduleNotificationSaveToViewNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleNotificationSaveToViewNotificationArgs:
    def __init__(__self__, *,
                 view_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] view_name: Name of the View(Index) to save the results to.
        """
        pulumi.set(__self__, "view_name", view_name)

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> pulumi.Input[str]:
        """
        Name of the View(Index) to save the results to.
        """
        return pulumi.get(self, "view_name")

    @view_name.setter
    def view_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_name", value)


if not MYPY:
    class LogSearchScheduleNotificationServiceNowSearchNotificationArgsDict(TypedDict):
        external_id: pulumi.Input[str]
        """
        Service Now Identifier.
        """
        fields: NotRequired[pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgsDict']]
        """
        Service Now fields.
        """
elif False:
    LogSearchScheduleNotificationServiceNowSearchNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleNotificationServiceNowSearchNotificationArgs:
    def __init__(__self__, *,
                 external_id: pulumi.Input[str],
                 fields: Optional[pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgs']] = None):
        """
        :param pulumi.Input[str] external_id: Service Now Identifier.
        :param pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgs'] fields: Service Now fields.
        """
        pulumi.set(__self__, "external_id", external_id)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> pulumi.Input[str]:
        """
        Service Now Identifier.
        """
        return pulumi.get(self, "external_id")

    @external_id.setter
    def external_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "external_id", value)

    @property
    @pulumi.getter
    def fields(self) -> Optional[pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgs']]:
        """
        Service Now fields.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: Optional[pulumi.Input['LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgs']]):
        pulumi.set(self, "fields", value)


if not MYPY:
    class LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgsDict(TypedDict):
        event_type: NotRequired[pulumi.Input[str]]
        """
        The category that the event source uses to identify the event.
        """
        node: NotRequired[pulumi.Input[str]]
        """
        The physical or virtual device on which the event occurred.
        """
        resource: NotRequired[pulumi.Input[str]]
        """
        The component on the node to which the event applies.
        """
        severity: NotRequired[pulumi.Input[int]]
        """
        An integer value representing the severity of the alert. Supported values are:
        * 0 for Clear
        * 1 for Critical
        * 2 for Major
        * 3 for Minor
        * 4 for Warning
        """
elif False:
    LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgs:
    def __init__(__self__, *,
                 event_type: Optional[pulumi.Input[str]] = None,
                 node: Optional[pulumi.Input[str]] = None,
                 resource: Optional[pulumi.Input[str]] = None,
                 severity: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] event_type: The category that the event source uses to identify the event.
        :param pulumi.Input[str] node: The physical or virtual device on which the event occurred.
        :param pulumi.Input[str] resource: The component on the node to which the event applies.
        :param pulumi.Input[int] severity: An integer value representing the severity of the alert. Supported values are:
               * 0 for Clear
               * 1 for Critical
               * 2 for Major
               * 3 for Minor
               * 4 for Warning
        """
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if node is not None:
            pulumi.set(__self__, "node", node)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[pulumi.Input[str]]:
        """
        The category that the event source uses to identify the event.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter
    def node(self) -> Optional[pulumi.Input[str]]:
        """
        The physical or virtual device on which the event occurred.
        """
        return pulumi.get(self, "node")

    @node.setter
    def node(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node", value)

    @property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[str]]:
        """
        The component on the node to which the event applies.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[int]]:
        """
        An integer value representing the severity of the alert. Supported values are:
        * 0 for Clear
        * 1 for Critical
        * 2 for Major
        * 3 for Minor
        * 4 for Warning
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class LogSearchScheduleNotificationWebhookSearchNotificationArgsDict(TypedDict):
        webhook_id: pulumi.Input[str]
        """
        Identifier of the webhook connection.
        """
        itemize_alerts: NotRequired[pulumi.Input[bool]]
        """
        If set to true, one webhook per result will be sent when the trigger conditions are met.
        """
        max_itemized_alerts: NotRequired[pulumi.Input[int]]
        """
        The maximum number of results for which we send separate alerts.
        """
        payload: NotRequired[pulumi.Input[str]]
        """
        A JSON object in the format required by the target WebHook URL.
        """
elif False:
    LogSearchScheduleNotificationWebhookSearchNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleNotificationWebhookSearchNotificationArgs:
    def __init__(__self__, *,
                 webhook_id: pulumi.Input[str],
                 itemize_alerts: Optional[pulumi.Input[bool]] = None,
                 max_itemized_alerts: Optional[pulumi.Input[int]] = None,
                 payload: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] webhook_id: Identifier of the webhook connection.
        :param pulumi.Input[bool] itemize_alerts: If set to true, one webhook per result will be sent when the trigger conditions are met.
        :param pulumi.Input[int] max_itemized_alerts: The maximum number of results for which we send separate alerts.
        :param pulumi.Input[str] payload: A JSON object in the format required by the target WebHook URL.
        """
        pulumi.set(__self__, "webhook_id", webhook_id)
        if itemize_alerts is not None:
            pulumi.set(__self__, "itemize_alerts", itemize_alerts)
        if max_itemized_alerts is not None:
            pulumi.set(__self__, "max_itemized_alerts", max_itemized_alerts)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter(name="webhookId")
    def webhook_id(self) -> pulumi.Input[str]:
        """
        Identifier of the webhook connection.
        """
        return pulumi.get(self, "webhook_id")

    @webhook_id.setter
    def webhook_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "webhook_id", value)

    @property
    @pulumi.getter(name="itemizeAlerts")
    def itemize_alerts(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, one webhook per result will be sent when the trigger conditions are met.
        """
        return pulumi.get(self, "itemize_alerts")

    @itemize_alerts.setter
    def itemize_alerts(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "itemize_alerts", value)

    @property
    @pulumi.getter(name="maxItemizedAlerts")
    def max_itemized_alerts(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of results for which we send separate alerts.
        """
        return pulumi.get(self, "max_itemized_alerts")

    @max_itemized_alerts.setter
    def max_itemized_alerts(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_itemized_alerts", value)

    @property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON object in the format required by the target WebHook URL.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload", value)


if not MYPY:
    class LogSearchScheduleParameterArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the search.
        """
        value: pulumi.Input[str]
        """
        Default value of scheduled search parameter.
        """
elif False:
    LogSearchScheduleParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParameterArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the search.
        :param pulumi.Input[str] value: Default value of scheduled search parameter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the search.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Default value of scheduled search parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeArgsDict(TypedDict):
        begin_bounded_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgsDict']]
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        complete_literal_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgsDict']]
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
elif False:
    LogSearchScheduleParseableTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeArgs:
    def __init__(__self__, *,
                 begin_bounded_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgs']] = None,
                 complete_literal_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgs']] = None):
        """
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgs'] begin_bounded_time_range: Bounded time range. See
               begin_bounded_time_range schema schema for details.
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgs'] complete_literal_time_range: Literal time range. See
               complete_literal_time_range schema for details.
        """
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgs']]:
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        return pulumi.get(self, "begin_bounded_time_range")

    @begin_bounded_time_range.setter
    def begin_bounded_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgs']]):
        pulumi.set(self, "begin_bounded_time_range", value)

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgs']]:
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
        return pulumi.get(self, "complete_literal_time_range")

    @complete_literal_time_range.setter
    def complete_literal_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgs']]):
        pulumi.set(self, "complete_literal_time_range", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgsDict(TypedDict):
        from_: pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgsDict']
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        to: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgsDict']]
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgs'],
                 to: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgs']] = None):
        """
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgs'] from_: Start boundary of bounded time range. See
               time_range_boundary schema for details.
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgs'] to: End boundary of bounded time range. See
               time_range_boundary schema for details.
        """
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgs']:
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgs']):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgs']]:
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict']]
        """
        Time since the epoch.
        """
        iso8601_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict']]
        """
        Time in ISO 8601 format.
        """
        literal_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict']]
        """
        Time in literal format.
        """
        relative_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict']]
        """
        Time in relative format.
        """
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']] = None):
        """
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs'] epoch_time_range: Time since the epoch.
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs'] iso8601_time_range: Time in ISO 8601 format.
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs'] literal_time_range: Time in literal format.
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs'] relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
        """
        Time as a number of milliseconds since the epoch.
        """
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        """
        :param pulumi.Input[int] epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
        """
        Time as a string in ISO 8601 format.
        """
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict']]
        """
        Time since the epoch.
        """
        iso8601_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict']]
        """
        Time in ISO 8601 format.
        """
        literal_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict']]
        """
        Time in literal format.
        """
        relative_time_range: NotRequired[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict']]
        """
        Time in relative format.
        """
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']] = None):
        """
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs'] epoch_time_range: Time since the epoch.
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs'] iso8601_time_range: Time in ISO 8601 format.
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs'] literal_time_range: Time in literal format.
        :param pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs'] relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
        """
        Time as a number of milliseconds since the epoch.
        """
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        """
        :param pulumi.Input[int] epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
        """
        Time as a string in ISO 8601 format.
        """
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
elif False:
    LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class LogSearchScheduleThresholdArgsDict(TypedDict):
        count: pulumi.Input[int]
        """
        Expected result count.
        """
        operator: pulumi.Input[str]
        """
        Criterion to be applied when comparing actual result count with expected count. Possible
        values are: `eq`, `gt`, `ge`, `lt`, and `le`.
        """
        threshold_type: pulumi.Input[str]
        """
        Threshold type for the scheduled log search. Possible values are: `message` and `group`.
        Use `group` as threshold type if the search query is of aggregate type. For non-aggregate queries, set it
        to `message`.
        """
elif False:
    LogSearchScheduleThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchScheduleThresholdArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[int],
                 operator: pulumi.Input[str],
                 threshold_type: pulumi.Input[str]):
        """
        :param pulumi.Input[int] count: Expected result count.
        :param pulumi.Input[str] operator: Criterion to be applied when comparing actual result count with expected count. Possible
               values are: `eq`, `gt`, `ge`, `lt`, and `le`.
        :param pulumi.Input[str] threshold_type: Threshold type for the scheduled log search. Possible values are: `message` and `group`.
               Use `group` as threshold type if the search query is of aggregate type. For non-aggregate queries, set it
               to `message`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[int]:
        """
        Expected result count.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Criterion to be applied when comparing actual result count with expected count. Possible
        values are: `eq`, `gt`, `ge`, `lt`, and `le`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> pulumi.Input[str]:
        """
        Threshold type for the scheduled log search. Possible values are: `message` and `group`.
        Use `group` as threshold type if the search query is of aggregate type. For non-aggregate queries, set it
        to `message`.
        """
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "threshold_type", value)


if not MYPY:
    class LogSearchTimeRangeArgsDict(TypedDict):
        begin_bounded_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeArgsDict']]
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        complete_literal_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeCompleteLiteralTimeRangeArgsDict']]
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
elif False:
    LogSearchTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeArgs:
    def __init__(__self__, *,
                 begin_bounded_time_range: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeArgs']] = None,
                 complete_literal_time_range: Optional[pulumi.Input['LogSearchTimeRangeCompleteLiteralTimeRangeArgs']] = None):
        """
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeArgs'] begin_bounded_time_range: Bounded time range. See
               begin_bounded_time_range schema schema for details.
        :param pulumi.Input['LogSearchTimeRangeCompleteLiteralTimeRangeArgs'] complete_literal_time_range: Literal time range. See
               complete_literal_time_range schema for details.
        """
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeArgs']]:
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        return pulumi.get(self, "begin_bounded_time_range")

    @begin_bounded_time_range.setter
    def begin_bounded_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeArgs']]):
        pulumi.set(self, "begin_bounded_time_range", value)

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeCompleteLiteralTimeRangeArgs']]:
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
        return pulumi.get(self, "complete_literal_time_range")

    @complete_literal_time_range.setter
    def complete_literal_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeCompleteLiteralTimeRangeArgs']]):
        pulumi.set(self, "complete_literal_time_range", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeArgsDict(TypedDict):
        from_: pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromArgsDict']
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        to: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToArgsDict']]
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromArgs'],
                 to: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToArgs']] = None):
        """
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromArgs'] from_: Start boundary of bounded time range. See
               time_range_boundary schema for details.
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToArgs'] to: End boundary of bounded time range. See
               time_range_boundary schema for details.
        """
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromArgs']:
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromArgs']):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToArgs']]:
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeFromArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict']]
        """
        Time since the epoch.
        """
        iso8601_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict']]
        """
        Time in ISO 8601 format.
        """
        literal_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict']]
        """
        Time in literal format.
        """
        relative_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict']]
        """
        Time in relative format.
        """
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeFromArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']] = None):
        """
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs'] epoch_time_range: Time since the epoch.
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs'] iso8601_time_range: Time in ISO 8601 format.
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs'] literal_time_range: Time in literal format.
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs'] relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
        """
        Time as a number of milliseconds since the epoch.
        """
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        """
        :param pulumi.Input[int] epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
        """
        Time as a string in ISO 8601 format.
        """
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeToArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict']]
        """
        Time since the epoch.
        """
        iso8601_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict']]
        """
        Time in ISO 8601 format.
        """
        literal_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict']]
        """
        Time in literal format.
        """
        relative_time_range: NotRequired[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict']]
        """
        Time in relative format.
        """
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeToArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']] = None):
        """
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs'] epoch_time_range: Time since the epoch.
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs'] iso8601_time_range: Time in ISO 8601 format.
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs'] literal_time_range: Time in literal format.
        :param pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs'] relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
        """
        Time as a number of milliseconds since the epoch.
        """
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        """
        :param pulumi.Input[int] epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
        """
        Time as a string in ISO 8601 format.
        """
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
elif False:
    LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class LogSearchTimeRangeCompleteLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    LogSearchTimeRangeCompleteLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LogSearchTimeRangeCompleteLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class LookupTableFieldArgsDict(TypedDict):
        field_name: pulumi.Input[str]
        field_type: pulumi.Input[str]
elif False:
    LookupTableFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LookupTableFieldArgs:
    def __init__(__self__, *,
                 field_name: pulumi.Input[str],
                 field_type: pulumi.Input[str]):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field_type")

    @field_type.setter
    def field_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "field_type", value)


if not MYPY:
    class MetadataSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
elif False:
    MetadataSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class MetadataSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    MetadataSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class MetadataSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    MetadataSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class MetadataSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. Only allowed value is `AwsMetadataPath`.
        """
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of namespaces. For `AwsMetadataPath` the only valid namespace is `AWS/EC2`.
        """
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Amazon regions.
        """
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Leave this field blank to collect all tags configured for the EC2 instance. To collect a subset of tags, follow the instructions in [Define EC2 tag filters][2]
        """
elif False:
    MetadataSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetadataSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. Only allowed value is `AwsMetadataPath`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_namespaces: List of namespaces. For `AwsMetadataPath` the only valid namespace is `AWS/EC2`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_regions: List of Amazon regions.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tag_filters: Leave this field blank to collect all tags configured for the EC2 instance. To collect a subset of tags, follow the instructions in [Define EC2 tag filters][2]
        """
        pulumi.set(__self__, "type", type)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. Only allowed value is `AwsMetadataPath`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of namespaces. For `AwsMetadataPath` the only valid namespace is `AWS/EC2`.
        """
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Leave this field blank to collect all tags configured for the EC2 instance. To collect a subset of tags, follow the instructions in [Define EC2 tag filters][2]
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tag_filters", value)


if not MYPY:
    class MetricsSearchMetricsQueryArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        A metric query consists of a metric, one or more filters and optionally, one or more [Metrics Operators](https://help.sumologic.com/?cid=10144).
        Strictly speaking, both filters and operators are optional.
        Most of the [Metrics Operators](https://help.sumologic.com/?cid=10144) are allowed in the query string except `fillmissing`, `outlier`, `quantize` and `timeshift`.
        In practice, your metric queries will almost always contain filters that narrow the scope of your query.
        For more information about the query language see [Metrics Queries](https://help.sumologic.com/?cid=1079).
        """
        row_id: pulumi.Input[str]
        """
        Row id for the query row, A to Z letter.
        """
elif False:
    MetricsSearchMetricsQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchMetricsQueryArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 row_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] query: A metric query consists of a metric, one or more filters and optionally, one or more [Metrics Operators](https://help.sumologic.com/?cid=10144).
               Strictly speaking, both filters and operators are optional.
               Most of the [Metrics Operators](https://help.sumologic.com/?cid=10144) are allowed in the query string except `fillmissing`, `outlier`, `quantize` and `timeshift`.
               In practice, your metric queries will almost always contain filters that narrow the scope of your query.
               For more information about the query language see [Metrics Queries](https://help.sumologic.com/?cid=1079).
        :param pulumi.Input[str] row_id: Row id for the query row, A to Z letter.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        A metric query consists of a metric, one or more filters and optionally, one or more [Metrics Operators](https://help.sumologic.com/?cid=10144).
        Strictly speaking, both filters and operators are optional.
        Most of the [Metrics Operators](https://help.sumologic.com/?cid=10144) are allowed in the query string except `fillmissing`, `outlier`, `quantize` and `timeshift`.
        In practice, your metric queries will almost always contain filters that narrow the scope of your query.
        For more information about the query language see [Metrics Queries](https://help.sumologic.com/?cid=1079).
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> pulumi.Input[str]:
        """
        Row id for the query row, A to Z letter.
        """
        return pulumi.get(self, "row_id")

    @row_id.setter
    def row_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "row_id", value)


if not MYPY:
    class MetricsSearchTimeRangeArgsDict(TypedDict):
        begin_bounded_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeArgsDict']]
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        complete_literal_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeCompleteLiteralTimeRangeArgsDict']]
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
elif False:
    MetricsSearchTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeArgs:
    def __init__(__self__, *,
                 begin_bounded_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeArgs']] = None,
                 complete_literal_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeCompleteLiteralTimeRangeArgs']] = None):
        """
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeArgs'] begin_bounded_time_range: Bounded time range. See
               begin_bounded_time_range schema schema for details.
        :param pulumi.Input['MetricsSearchTimeRangeCompleteLiteralTimeRangeArgs'] complete_literal_time_range: Literal time range. See
               complete_literal_time_range schema for details.
        """
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeArgs']]:
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        return pulumi.get(self, "begin_bounded_time_range")

    @begin_bounded_time_range.setter
    def begin_bounded_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeArgs']]):
        pulumi.set(self, "begin_bounded_time_range", value)

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeCompleteLiteralTimeRangeArgs']]:
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
        return pulumi.get(self, "complete_literal_time_range")

    @complete_literal_time_range.setter
    def complete_literal_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeCompleteLiteralTimeRangeArgs']]):
        pulumi.set(self, "complete_literal_time_range", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeArgsDict(TypedDict):
        from_: pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgsDict']
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        to: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToArgsDict']]
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeArgs:
    def __init__(__self__, *,
                 from_: pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgs'],
                 to: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToArgs']] = None):
        """
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgs'] from_: Start boundary of bounded time range. See
               time_range_boundary schema for details.
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToArgs'] to: End boundary of bounded time range. See
               time_range_boundary schema for details.
        """
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgs']:
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgs']):
        pulumi.set(self, "from_", value)

    @property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToArgs']]:
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToArgs']]):
        pulumi.set(self, "to", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict']]
        """
        Time since the epoch.
        """
        iso8601_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict']]
        """
        Time in ISO 8601 format.
        """
        literal_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict']]
        """
        Time in literal format.
        """
        relative_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict']]
        """
        Time in relative format.
        """
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']] = None):
        """
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs'] epoch_time_range: Time since the epoch.
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs'] iso8601_time_range: Time in ISO 8601 format.
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs'] literal_time_range: Time in literal format.
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs'] relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
        """
        Time as a number of milliseconds since the epoch.
        """
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        """
        :param pulumi.Input[int] epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
        """
        Time as a string in ISO 8601 format.
        """
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeToArgsDict(TypedDict):
        epoch_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict']]
        """
        Time since the epoch.
        """
        iso8601_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict']]
        """
        Time in ISO 8601 format.
        """
        literal_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict']]
        """
        Time in literal format.
        """
        relative_time_range: NotRequired[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict']]
        """
        Time in relative format.
        """
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeToArgs:
    def __init__(__self__, *,
                 epoch_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']] = None,
                 iso8601_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']] = None,
                 literal_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']] = None,
                 relative_time_range: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']] = None):
        """
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs'] epoch_time_range: Time since the epoch.
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs'] iso8601_time_range: Time in ISO 8601 format.
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs'] literal_time_range: Time in literal format.
        :param pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs'] relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @epoch_time_range.setter
    def epoch_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs']]):
        pulumi.set(self, "epoch_time_range", value)

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @iso8601_time_range.setter
    def iso8601_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs']]):
        pulumi.set(self, "iso8601_time_range", value)

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @literal_time_range.setter
    def literal_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs']]):
        pulumi.set(self, "literal_time_range", value)

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")

    @relative_time_range.setter
    def relative_time_range(self, value: Optional[pulumi.Input['MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs']]):
        pulumi.set(self, "relative_time_range", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict(TypedDict):
        epoch_millis: pulumi.Input[int]
        """
        Time as a number of milliseconds since the epoch.
        """
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs:
    def __init__(__self__, *,
                 epoch_millis: pulumi.Input[int]):
        """
        :param pulumi.Input[int] epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> pulumi.Input[int]:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")

    @epoch_millis.setter
    def epoch_millis(self, value: pulumi.Input[int]):
        pulumi.set(self, "epoch_millis", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict(TypedDict):
        iso8601_time: pulumi.Input[str]
        """
        Time as a string in ISO 8601 format.
        """
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs:
    def __init__(__self__, *,
                 iso8601_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> pulumi.Input[str]:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")

    @iso8601_time.setter
    def iso8601_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "iso8601_time", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict(TypedDict):
        relative_time: pulumi.Input[str]
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
elif False:
    MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs:
    def __init__(__self__, *,
                 relative_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> pulumi.Input[str]:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")

    @relative_time.setter
    def relative_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "relative_time", value)


if not MYPY:
    class MetricsSearchTimeRangeCompleteLiteralTimeRangeArgsDict(TypedDict):
        range_name: pulumi.Input[str]
elif False:
    MetricsSearchTimeRangeCompleteLiteralTimeRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MetricsSearchTimeRangeCompleteLiteralTimeRangeArgs:
    def __init__(__self__, *,
                 range_name: pulumi.Input[str]):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "range_name")

    @range_name.setter
    def range_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "range_name", value)


if not MYPY:
    class MonitorFolderObjPermissionArgsDict(TypedDict):
        permissions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A Set of Permissions. Valid Permission Values: 
        - `Create`
        - `Read`
        - `Update`
        - `Delete`
        - `Manage`

        Additional data provided in state:
        """
        subject_id: pulumi.Input[str]
        """
        A Role ID or the Org ID of the account
        """
        subject_type: pulumi.Input[str]
        """
        Valid values:
        """
elif False:
    MonitorFolderObjPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorFolderObjPermissionArgs:
    def __init__(__self__, *,
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subject_id: pulumi.Input[str],
                 subject_type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] permissions: A Set of Permissions. Valid Permission Values: 
               - `Create`
               - `Read`
               - `Update`
               - `Delete`
               - `Manage`
               
               Additional data provided in state:
        :param pulumi.Input[str] subject_id: A Role ID or the Org ID of the account
        :param pulumi.Input[str] subject_type: Valid values:
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "subject_id", subject_id)
        pulumi.set(__self__, "subject_type", subject_type)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A Set of Permissions. Valid Permission Values: 
        - `Create`
        - `Read`
        - `Update`
        - `Delete`
        - `Manage`

        Additional data provided in state:
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter(name="subjectId")
    def subject_id(self) -> pulumi.Input[str]:
        """
        A Role ID or the Org ID of the account
        """
        return pulumi.get(self, "subject_id")

    @subject_id.setter
    def subject_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject_id", value)

    @property
    @pulumi.getter(name="subjectType")
    def subject_type(self) -> pulumi.Input[str]:
        """
        Valid values:
        """
        return pulumi.get(self, "subject_type")

    @subject_type.setter
    def subject_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject_type", value)


if not MYPY:
    class MonitorNotificationArgsDict(TypedDict):
        notification: pulumi.Input['MonitorNotificationNotificationArgsDict']
        run_for_trigger_types: pulumi.Input[Sequence[pulumi.Input[str]]]
elif False:
    MonitorNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorNotificationArgs:
    def __init__(__self__, *,
                 notification: pulumi.Input['MonitorNotificationNotificationArgs'],
                 run_for_trigger_types: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(__self__, "notification", notification)
        pulumi.set(__self__, "run_for_trigger_types", run_for_trigger_types)

    @property
    @pulumi.getter
    def notification(self) -> pulumi.Input['MonitorNotificationNotificationArgs']:
        return pulumi.get(self, "notification")

    @notification.setter
    def notification(self, value: pulumi.Input['MonitorNotificationNotificationArgs']):
        pulumi.set(self, "notification", value)

    @property
    @pulumi.getter(name="runForTriggerTypes")
    def run_for_trigger_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        return pulumi.get(self, "run_for_trigger_types")

    @run_for_trigger_types.setter
    def run_for_trigger_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "run_for_trigger_types", value)


if not MYPY:
    class MonitorNotificationNotificationArgsDict(TypedDict):
        action_type: NotRequired[pulumi.Input[str]]
        connection_id: NotRequired[pulumi.Input[str]]
        connection_type: NotRequired[pulumi.Input[str]]
        message_body: NotRequired[pulumi.Input[str]]
        payload_override: NotRequired[pulumi.Input[str]]
        recipients: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        resolution_payload_override: NotRequired[pulumi.Input[str]]
        subject: NotRequired[pulumi.Input[str]]
        time_zone: NotRequired[pulumi.Input[str]]
elif False:
    MonitorNotificationNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorNotificationNotificationArgs:
    def __init__(__self__, *,
                 action_type: Optional[pulumi.Input[str]] = None,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 connection_type: Optional[pulumi.Input[str]] = None,
                 message_body: Optional[pulumi.Input[str]] = None,
                 payload_override: Optional[pulumi.Input[str]] = None,
                 recipients: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 resolution_payload_override: Optional[pulumi.Input[str]] = None,
                 subject: Optional[pulumi.Input[str]] = None,
                 time_zone: Optional[pulumi.Input[str]] = None):
        if action_type is not None:
            warnings.warn("""The field `action_type` is deprecated and will be removed in a future release of the provider - please use `connection_type` instead.""", DeprecationWarning)
            pulumi.log.warn("""action_type is deprecated: The field `action_type` is deprecated and will be removed in a future release of the provider - please use `connection_type` instead.""")
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if payload_override is not None:
            pulumi.set(__self__, "payload_override", payload_override)
        if recipients is not None:
            pulumi.set(__self__, "recipients", recipients)
        if resolution_payload_override is not None:
            pulumi.set(__self__, "resolution_payload_override", resolution_payload_override)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="actionType")
    @_utilities.deprecated("""The field `action_type` is deprecated and will be removed in a future release of the provider - please use `connection_type` instead.""")
    def action_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "action_type")

    @action_type.setter
    def action_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "action_type", value)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "message_body")

    @message_body.setter
    def message_body(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_body", value)

    @property
    @pulumi.getter(name="payloadOverride")
    def payload_override(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "payload_override")

    @payload_override.setter
    def payload_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "payload_override", value)

    @property
    @pulumi.getter
    def recipients(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "recipients")

    @recipients.setter
    def recipients(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "recipients", value)

    @property
    @pulumi.getter(name="resolutionPayloadOverride")
    def resolution_payload_override(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "resolution_payload_override")

    @resolution_payload_override.setter
    def resolution_payload_override(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_payload_override", value)

    @property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "subject", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class MonitorObjPermissionArgsDict(TypedDict):
        permissions: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A Set of Permissions. Valid Permission Values:
        - `Read`
        - `Update`
        - `Delete`
        - `Manage`

        Additional data provided in state:
        """
        subject_id: pulumi.Input[str]
        """
        A Role ID or the Org ID of the account
        """
        subject_type: pulumi.Input[str]
        """
        Valid values:
        """
elif False:
    MonitorObjPermissionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorObjPermissionArgs:
    def __init__(__self__, *,
                 permissions: pulumi.Input[Sequence[pulumi.Input[str]]],
                 subject_id: pulumi.Input[str],
                 subject_type: pulumi.Input[str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] permissions: A Set of Permissions. Valid Permission Values:
               - `Read`
               - `Update`
               - `Delete`
               - `Manage`
               
               Additional data provided in state:
        :param pulumi.Input[str] subject_id: A Role ID or the Org ID of the account
        :param pulumi.Input[str] subject_type: Valid values:
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "subject_id", subject_id)
        pulumi.set(__self__, "subject_type", subject_type)

    @property
    @pulumi.getter
    def permissions(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A Set of Permissions. Valid Permission Values:
        - `Read`
        - `Update`
        - `Delete`
        - `Manage`

        Additional data provided in state:
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "permissions", value)

    @property
    @pulumi.getter(name="subjectId")
    def subject_id(self) -> pulumi.Input[str]:
        """
        A Role ID or the Org ID of the account
        """
        return pulumi.get(self, "subject_id")

    @subject_id.setter
    def subject_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject_id", value)

    @property
    @pulumi.getter(name="subjectType")
    def subject_type(self) -> pulumi.Input[str]:
        """
        Valid values:
        """
        return pulumi.get(self, "subject_type")

    @subject_type.setter
    def subject_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "subject_type", value)


if not MYPY:
    class MonitorQueryArgsDict(TypedDict):
        query: pulumi.Input[str]
        row_id: pulumi.Input[str]
elif False:
    MonitorQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorQueryArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 row_id: pulumi.Input[str]):
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> pulumi.Input[str]:
        return pulumi.get(self, "row_id")

    @row_id.setter
    def row_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "row_id", value)


if not MYPY:
    class MonitorTriggerArgsDict(TypedDict):
        detection_method: NotRequired[pulumi.Input[str]]
        min_data_points: NotRequired[pulumi.Input[int]]
        occurrence_type: NotRequired[pulumi.Input[str]]
        resolution_window: NotRequired[pulumi.Input[str]]
        """
        The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        threshold: NotRequired[pulumi.Input[float]]
        threshold_type: NotRequired[pulumi.Input[str]]
        time_range: NotRequired[pulumi.Input[str]]
        trigger_source: NotRequired[pulumi.Input[str]]
        trigger_type: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerArgs:
    def __init__(__self__, *,
                 detection_method: Optional[pulumi.Input[str]] = None,
                 min_data_points: Optional[pulumi.Input[int]] = None,
                 occurrence_type: Optional[pulumi.Input[str]] = None,
                 resolution_window: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None,
                 time_range: Optional[pulumi.Input[str]] = None,
                 trigger_source: Optional[pulumi.Input[str]] = None,
                 trigger_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resolution_window: The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        if detection_method is not None:
            pulumi.set(__self__, "detection_method", detection_method)
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if resolution_window is not None:
            pulumi.set(__self__, "resolution_window", resolution_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)
        if trigger_source is not None:
            pulumi.set(__self__, "trigger_source", trigger_source)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @property
    @pulumi.getter(name="detectionMethod")
    def detection_method(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "detection_method")

    @detection_method.setter
    def detection_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detection_method", value)

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_data_points")

    @min_data_points.setter
    def min_data_points(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_data_points", value)

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "occurrence_type")

    @occurrence_type.setter
    def occurrence_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "occurrence_type", value)

    @property
    @pulumi.getter(name="resolutionWindow")
    def resolution_window(self) -> Optional[pulumi.Input[str]]:
        """
        The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        return pulumi.get(self, "resolution_window")

    @resolution_window.setter
    def resolution_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_window", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_range", value)

    @property
    @pulumi.getter(name="triggerSource")
    def trigger_source(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "trigger_source")

    @trigger_source.setter
    def trigger_source(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_source", value)

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "trigger_type")

    @trigger_type.setter
    def trigger_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "trigger_type", value)


if not MYPY:
    class MonitorTriggerConditionsArgsDict(TypedDict):
        logs_anomaly_condition: NotRequired[pulumi.Input['MonitorTriggerConditionsLogsAnomalyConditionArgsDict']]
        logs_missing_data_condition: NotRequired[pulumi.Input['MonitorTriggerConditionsLogsMissingDataConditionArgsDict']]
        logs_outlier_condition: NotRequired[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionArgsDict']]
        logs_static_condition: NotRequired[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionArgsDict']]
        metrics_missing_data_condition: NotRequired[pulumi.Input['MonitorTriggerConditionsMetricsMissingDataConditionArgsDict']]
        metrics_outlier_condition: NotRequired[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionArgsDict']]
        metrics_static_condition: NotRequired[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionArgsDict']]
        slo_burn_rate_condition: NotRequired[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionArgsDict']]
        slo_sli_condition: NotRequired[pulumi.Input['MonitorTriggerConditionsSloSliConditionArgsDict']]
elif False:
    MonitorTriggerConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsArgs:
    def __init__(__self__, *,
                 logs_anomaly_condition: Optional[pulumi.Input['MonitorTriggerConditionsLogsAnomalyConditionArgs']] = None,
                 logs_missing_data_condition: Optional[pulumi.Input['MonitorTriggerConditionsLogsMissingDataConditionArgs']] = None,
                 logs_outlier_condition: Optional[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionArgs']] = None,
                 logs_static_condition: Optional[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionArgs']] = None,
                 metrics_missing_data_condition: Optional[pulumi.Input['MonitorTriggerConditionsMetricsMissingDataConditionArgs']] = None,
                 metrics_outlier_condition: Optional[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionArgs']] = None,
                 metrics_static_condition: Optional[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionArgs']] = None,
                 slo_burn_rate_condition: Optional[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionArgs']] = None,
                 slo_sli_condition: Optional[pulumi.Input['MonitorTriggerConditionsSloSliConditionArgs']] = None):
        if logs_anomaly_condition is not None:
            pulumi.set(__self__, "logs_anomaly_condition", logs_anomaly_condition)
        if logs_missing_data_condition is not None:
            pulumi.set(__self__, "logs_missing_data_condition", logs_missing_data_condition)
        if logs_outlier_condition is not None:
            pulumi.set(__self__, "logs_outlier_condition", logs_outlier_condition)
        if logs_static_condition is not None:
            pulumi.set(__self__, "logs_static_condition", logs_static_condition)
        if metrics_missing_data_condition is not None:
            pulumi.set(__self__, "metrics_missing_data_condition", metrics_missing_data_condition)
        if metrics_outlier_condition is not None:
            pulumi.set(__self__, "metrics_outlier_condition", metrics_outlier_condition)
        if metrics_static_condition is not None:
            pulumi.set(__self__, "metrics_static_condition", metrics_static_condition)
        if slo_burn_rate_condition is not None:
            pulumi.set(__self__, "slo_burn_rate_condition", slo_burn_rate_condition)
        if slo_sli_condition is not None:
            pulumi.set(__self__, "slo_sli_condition", slo_sli_condition)

    @property
    @pulumi.getter(name="logsAnomalyCondition")
    def logs_anomaly_condition(self) -> Optional[pulumi.Input['MonitorTriggerConditionsLogsAnomalyConditionArgs']]:
        return pulumi.get(self, "logs_anomaly_condition")

    @logs_anomaly_condition.setter
    def logs_anomaly_condition(self, value: Optional[pulumi.Input['MonitorTriggerConditionsLogsAnomalyConditionArgs']]):
        pulumi.set(self, "logs_anomaly_condition", value)

    @property
    @pulumi.getter(name="logsMissingDataCondition")
    def logs_missing_data_condition(self) -> Optional[pulumi.Input['MonitorTriggerConditionsLogsMissingDataConditionArgs']]:
        return pulumi.get(self, "logs_missing_data_condition")

    @logs_missing_data_condition.setter
    def logs_missing_data_condition(self, value: Optional[pulumi.Input['MonitorTriggerConditionsLogsMissingDataConditionArgs']]):
        pulumi.set(self, "logs_missing_data_condition", value)

    @property
    @pulumi.getter(name="logsOutlierCondition")
    def logs_outlier_condition(self) -> Optional[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionArgs']]:
        return pulumi.get(self, "logs_outlier_condition")

    @logs_outlier_condition.setter
    def logs_outlier_condition(self, value: Optional[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionArgs']]):
        pulumi.set(self, "logs_outlier_condition", value)

    @property
    @pulumi.getter(name="logsStaticCondition")
    def logs_static_condition(self) -> Optional[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionArgs']]:
        return pulumi.get(self, "logs_static_condition")

    @logs_static_condition.setter
    def logs_static_condition(self, value: Optional[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionArgs']]):
        pulumi.set(self, "logs_static_condition", value)

    @property
    @pulumi.getter(name="metricsMissingDataCondition")
    def metrics_missing_data_condition(self) -> Optional[pulumi.Input['MonitorTriggerConditionsMetricsMissingDataConditionArgs']]:
        return pulumi.get(self, "metrics_missing_data_condition")

    @metrics_missing_data_condition.setter
    def metrics_missing_data_condition(self, value: Optional[pulumi.Input['MonitorTriggerConditionsMetricsMissingDataConditionArgs']]):
        pulumi.set(self, "metrics_missing_data_condition", value)

    @property
    @pulumi.getter(name="metricsOutlierCondition")
    def metrics_outlier_condition(self) -> Optional[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionArgs']]:
        return pulumi.get(self, "metrics_outlier_condition")

    @metrics_outlier_condition.setter
    def metrics_outlier_condition(self, value: Optional[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionArgs']]):
        pulumi.set(self, "metrics_outlier_condition", value)

    @property
    @pulumi.getter(name="metricsStaticCondition")
    def metrics_static_condition(self) -> Optional[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionArgs']]:
        return pulumi.get(self, "metrics_static_condition")

    @metrics_static_condition.setter
    def metrics_static_condition(self, value: Optional[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionArgs']]):
        pulumi.set(self, "metrics_static_condition", value)

    @property
    @pulumi.getter(name="sloBurnRateCondition")
    def slo_burn_rate_condition(self) -> Optional[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionArgs']]:
        return pulumi.get(self, "slo_burn_rate_condition")

    @slo_burn_rate_condition.setter
    def slo_burn_rate_condition(self, value: Optional[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionArgs']]):
        pulumi.set(self, "slo_burn_rate_condition", value)

    @property
    @pulumi.getter(name="sloSliCondition")
    def slo_sli_condition(self) -> Optional[pulumi.Input['MonitorTriggerConditionsSloSliConditionArgs']]:
        return pulumi.get(self, "slo_sli_condition")

    @slo_sli_condition.setter
    def slo_sli_condition(self, value: Optional[pulumi.Input['MonitorTriggerConditionsSloSliConditionArgs']]):
        pulumi.set(self, "slo_sli_condition", value)


if not MYPY:
    class MonitorTriggerConditionsLogsAnomalyConditionArgsDict(TypedDict):
        anomaly_detector_type: pulumi.Input[str]
        critical: pulumi.Input['MonitorTriggerConditionsLogsAnomalyConditionCriticalArgsDict']
        field: pulumi.Input[str]
        direction: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsLogsAnomalyConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsAnomalyConditionArgs:
    def __init__(__self__, *,
                 anomaly_detector_type: pulumi.Input[str],
                 critical: pulumi.Input['MonitorTriggerConditionsLogsAnomalyConditionCriticalArgs'],
                 field: pulumi.Input[str],
                 direction: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "anomaly_detector_type", anomaly_detector_type)
        pulumi.set(__self__, "critical", critical)
        pulumi.set(__self__, "field", field)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter(name="anomalyDetectorType")
    def anomaly_detector_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "anomaly_detector_type")

    @anomaly_detector_type.setter
    def anomaly_detector_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "anomaly_detector_type", value)

    @property
    @pulumi.getter
    def critical(self) -> pulumi.Input['MonitorTriggerConditionsLogsAnomalyConditionCriticalArgs']:
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: pulumi.Input['MonitorTriggerConditionsLogsAnomalyConditionCriticalArgs']):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class MonitorTriggerConditionsLogsAnomalyConditionCriticalArgsDict(TypedDict):
        time_range: pulumi.Input[str]
        min_anomaly_count: NotRequired[pulumi.Input[int]]
        sensitivity: NotRequired[pulumi.Input[float]]
elif False:
    MonitorTriggerConditionsLogsAnomalyConditionCriticalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsAnomalyConditionCriticalArgs:
    def __init__(__self__, *,
                 time_range: pulumi.Input[str],
                 min_anomaly_count: Optional[pulumi.Input[int]] = None,
                 sensitivity: Optional[pulumi.Input[float]] = None):
        pulumi.set(__self__, "time_range", time_range)
        if min_anomaly_count is not None:
            pulumi.set(__self__, "min_anomaly_count", min_anomaly_count)
        if sensitivity is not None:
            pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_range", value)

    @property
    @pulumi.getter(name="minAnomalyCount")
    def min_anomaly_count(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_anomaly_count")

    @min_anomaly_count.setter
    def min_anomaly_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_anomaly_count", value)

    @property
    @pulumi.getter
    def sensitivity(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "sensitivity")

    @sensitivity.setter
    def sensitivity(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sensitivity", value)


if not MYPY:
    class MonitorTriggerConditionsLogsMissingDataConditionArgsDict(TypedDict):
        time_range: pulumi.Input[str]
elif False:
    MonitorTriggerConditionsLogsMissingDataConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsMissingDataConditionArgs:
    def __init__(__self__, *,
                 time_range: pulumi.Input[str]):
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class MonitorTriggerConditionsLogsOutlierConditionArgsDict(TypedDict):
        critical: NotRequired[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionCriticalArgsDict']]
        direction: NotRequired[pulumi.Input[str]]
        field: NotRequired[pulumi.Input[str]]
        warning: NotRequired[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionWarningArgsDict']]
elif False:
    MonitorTriggerConditionsLogsOutlierConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsOutlierConditionArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionCriticalArgs']] = None,
                 direction: Optional[pulumi.Input[str]] = None,
                 field: Optional[pulumi.Input[str]] = None,
                 warning: Optional[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionWarningArgs']] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionCriticalArgs']]:
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionCriticalArgs']]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionWarningArgs']]:
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input['MonitorTriggerConditionsLogsOutlierConditionWarningArgs']]):
        pulumi.set(self, "warning", value)


if not MYPY:
    class MonitorTriggerConditionsLogsOutlierConditionCriticalArgsDict(TypedDict):
        consecutive: NotRequired[pulumi.Input[int]]
        threshold: NotRequired[pulumi.Input[float]]
        window: NotRequired[pulumi.Input[int]]
elif False:
    MonitorTriggerConditionsLogsOutlierConditionCriticalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsOutlierConditionCriticalArgs:
    def __init__(__self__, *,
                 consecutive: Optional[pulumi.Input[int]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 window: Optional[pulumi.Input[int]] = None):
        if consecutive is not None:
            pulumi.set(__self__, "consecutive", consecutive)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def consecutive(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive")

    @consecutive.setter
    def consecutive(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def window(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window", value)


if not MYPY:
    class MonitorTriggerConditionsLogsOutlierConditionWarningArgsDict(TypedDict):
        consecutive: NotRequired[pulumi.Input[int]]
        threshold: NotRequired[pulumi.Input[float]]
        window: NotRequired[pulumi.Input[int]]
elif False:
    MonitorTriggerConditionsLogsOutlierConditionWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsOutlierConditionWarningArgs:
    def __init__(__self__, *,
                 consecutive: Optional[pulumi.Input[int]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 window: Optional[pulumi.Input[int]] = None):
        if consecutive is not None:
            pulumi.set(__self__, "consecutive", consecutive)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def consecutive(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "consecutive")

    @consecutive.setter
    def consecutive(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "consecutive", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def window(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window", value)


if not MYPY:
    class MonitorTriggerConditionsLogsStaticConditionArgsDict(TypedDict):
        critical: NotRequired[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalArgsDict']]
        field: NotRequired[pulumi.Input[str]]
        warning: NotRequired[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningArgsDict']]
elif False:
    MonitorTriggerConditionsLogsStaticConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsStaticConditionArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalArgs']] = None,
                 field: Optional[pulumi.Input[str]] = None,
                 warning: Optional[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningArgs']] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalArgs']]:
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalArgs']]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningArgs']]:
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningArgs']]):
        pulumi.set(self, "warning", value)


if not MYPY:
    class MonitorTriggerConditionsLogsStaticConditionCriticalArgsDict(TypedDict):
        alert: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalAlertArgsDict']
        resolution: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalResolutionArgsDict']
        time_range: pulumi.Input[str]
elif False:
    MonitorTriggerConditionsLogsStaticConditionCriticalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsStaticConditionCriticalArgs:
    def __init__(__self__, *,
                 alert: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalAlertArgs'],
                 resolution: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalResolutionArgs'],
                 time_range: pulumi.Input[str]):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalAlertArgs']:
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalAlertArgs']):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter
    def resolution(self) -> pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalResolutionArgs']:
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionCriticalResolutionArgs']):
        pulumi.set(self, "resolution", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class MonitorTriggerConditionsLogsStaticConditionCriticalAlertArgsDict(TypedDict):
        threshold: NotRequired[pulumi.Input[float]]
        threshold_type: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsLogsStaticConditionCriticalAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsStaticConditionCriticalAlertArgs:
    def __init__(__self__, *,
                 threshold: Optional[pulumi.Input[float]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


if not MYPY:
    class MonitorTriggerConditionsLogsStaticConditionCriticalResolutionArgsDict(TypedDict):
        resolution_window: NotRequired[pulumi.Input[str]]
        """
        The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        threshold: NotRequired[pulumi.Input[float]]
        threshold_type: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsLogsStaticConditionCriticalResolutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsStaticConditionCriticalResolutionArgs:
    def __init__(__self__, *,
                 resolution_window: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resolution_window: The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        if resolution_window is not None:
            pulumi.set(__self__, "resolution_window", resolution_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="resolutionWindow")
    def resolution_window(self) -> Optional[pulumi.Input[str]]:
        """
        The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        return pulumi.get(self, "resolution_window")

    @resolution_window.setter
    def resolution_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_window", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


if not MYPY:
    class MonitorTriggerConditionsLogsStaticConditionWarningArgsDict(TypedDict):
        alert: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningAlertArgsDict']
        resolution: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningResolutionArgsDict']
        time_range: pulumi.Input[str]
elif False:
    MonitorTriggerConditionsLogsStaticConditionWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsStaticConditionWarningArgs:
    def __init__(__self__, *,
                 alert: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningAlertArgs'],
                 resolution: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningResolutionArgs'],
                 time_range: pulumi.Input[str]):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningAlertArgs']:
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningAlertArgs']):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter
    def resolution(self) -> pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningResolutionArgs']:
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: pulumi.Input['MonitorTriggerConditionsLogsStaticConditionWarningResolutionArgs']):
        pulumi.set(self, "resolution", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class MonitorTriggerConditionsLogsStaticConditionWarningAlertArgsDict(TypedDict):
        threshold: NotRequired[pulumi.Input[float]]
        threshold_type: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsLogsStaticConditionWarningAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsStaticConditionWarningAlertArgs:
    def __init__(__self__, *,
                 threshold: Optional[pulumi.Input[float]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


if not MYPY:
    class MonitorTriggerConditionsLogsStaticConditionWarningResolutionArgsDict(TypedDict):
        resolution_window: NotRequired[pulumi.Input[str]]
        """
        The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        threshold: NotRequired[pulumi.Input[float]]
        threshold_type: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsLogsStaticConditionWarningResolutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsLogsStaticConditionWarningResolutionArgs:
    def __init__(__self__, *,
                 resolution_window: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] resolution_window: The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        if resolution_window is not None:
            pulumi.set(__self__, "resolution_window", resolution_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="resolutionWindow")
    def resolution_window(self) -> Optional[pulumi.Input[str]]:
        """
        The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        return pulumi.get(self, "resolution_window")

    @resolution_window.setter
    def resolution_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resolution_window", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsMissingDataConditionArgsDict(TypedDict):
        time_range: pulumi.Input[str]
        trigger_source: pulumi.Input[str]
elif False:
    MonitorTriggerConditionsMetricsMissingDataConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsMissingDataConditionArgs:
    def __init__(__self__, *,
                 time_range: pulumi.Input[str],
                 trigger_source: pulumi.Input[str]):
        pulumi.set(__self__, "time_range", time_range)
        pulumi.set(__self__, "trigger_source", trigger_source)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_range", value)

    @property
    @pulumi.getter(name="triggerSource")
    def trigger_source(self) -> pulumi.Input[str]:
        return pulumi.get(self, "trigger_source")

    @trigger_source.setter
    def trigger_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "trigger_source", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsOutlierConditionArgsDict(TypedDict):
        critical: NotRequired[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionCriticalArgsDict']]
        direction: NotRequired[pulumi.Input[str]]
        warning: NotRequired[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionWarningArgsDict']]
elif False:
    MonitorTriggerConditionsMetricsOutlierConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsOutlierConditionArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionCriticalArgs']] = None,
                 direction: Optional[pulumi.Input[str]] = None,
                 warning: Optional[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionWarningArgs']] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionCriticalArgs']]:
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionCriticalArgs']]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "direction", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionWarningArgs']]:
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input['MonitorTriggerConditionsMetricsOutlierConditionWarningArgs']]):
        pulumi.set(self, "warning", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsOutlierConditionCriticalArgsDict(TypedDict):
        baseline_window: NotRequired[pulumi.Input[str]]
        threshold: NotRequired[pulumi.Input[float]]
elif False:
    MonitorTriggerConditionsMetricsOutlierConditionCriticalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsOutlierConditionCriticalArgs:
    def __init__(__self__, *,
                 baseline_window: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None):
        if baseline_window is not None:
            pulumi.set(__self__, "baseline_window", baseline_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="baselineWindow")
    def baseline_window(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "baseline_window")

    @baseline_window.setter
    def baseline_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baseline_window", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsOutlierConditionWarningArgsDict(TypedDict):
        baseline_window: NotRequired[pulumi.Input[str]]
        threshold: NotRequired[pulumi.Input[float]]
elif False:
    MonitorTriggerConditionsMetricsOutlierConditionWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsOutlierConditionWarningArgs:
    def __init__(__self__, *,
                 baseline_window: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None):
        if baseline_window is not None:
            pulumi.set(__self__, "baseline_window", baseline_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="baselineWindow")
    def baseline_window(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "baseline_window")

    @baseline_window.setter
    def baseline_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "baseline_window", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsStaticConditionArgsDict(TypedDict):
        critical: NotRequired[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalArgsDict']]
        warning: NotRequired[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningArgsDict']]
elif False:
    MonitorTriggerConditionsMetricsStaticConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsStaticConditionArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalArgs']] = None,
                 warning: Optional[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningArgs']] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalArgs']]:
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalArgs']]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningArgs']]:
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningArgs']]):
        pulumi.set(self, "warning", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsStaticConditionCriticalArgsDict(TypedDict):
        alert: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalAlertArgsDict']
        occurrence_type: pulumi.Input[str]
        resolution: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalResolutionArgsDict']
        time_range: pulumi.Input[str]
elif False:
    MonitorTriggerConditionsMetricsStaticConditionCriticalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsStaticConditionCriticalArgs:
    def __init__(__self__, *,
                 alert: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalAlertArgs'],
                 occurrence_type: pulumi.Input[str],
                 resolution: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalResolutionArgs'],
                 time_range: pulumi.Input[str]):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "occurrence_type", occurrence_type)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalAlertArgs']:
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalAlertArgs']):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "occurrence_type")

    @occurrence_type.setter
    def occurrence_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "occurrence_type", value)

    @property
    @pulumi.getter
    def resolution(self) -> pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalResolutionArgs']:
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionCriticalResolutionArgs']):
        pulumi.set(self, "resolution", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsStaticConditionCriticalAlertArgsDict(TypedDict):
        min_data_points: NotRequired[pulumi.Input[int]]
        threshold: NotRequired[pulumi.Input[float]]
        threshold_type: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsMetricsStaticConditionCriticalAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsStaticConditionCriticalAlertArgs:
    def __init__(__self__, *,
                 min_data_points: Optional[pulumi.Input[int]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_data_points")

    @min_data_points.setter
    def min_data_points(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_data_points", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsStaticConditionCriticalResolutionArgsDict(TypedDict):
        min_data_points: NotRequired[pulumi.Input[int]]
        occurrence_type: NotRequired[pulumi.Input[str]]
        threshold: NotRequired[pulumi.Input[float]]
        threshold_type: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsMetricsStaticConditionCriticalResolutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsStaticConditionCriticalResolutionArgs:
    def __init__(__self__, *,
                 min_data_points: Optional[pulumi.Input[int]] = None,
                 occurrence_type: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_data_points")

    @min_data_points.setter
    def min_data_points(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_data_points", value)

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "occurrence_type")

    @occurrence_type.setter
    def occurrence_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "occurrence_type", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsStaticConditionWarningArgsDict(TypedDict):
        alert: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningAlertArgsDict']
        occurrence_type: pulumi.Input[str]
        resolution: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningResolutionArgsDict']
        time_range: pulumi.Input[str]
elif False:
    MonitorTriggerConditionsMetricsStaticConditionWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsStaticConditionWarningArgs:
    def __init__(__self__, *,
                 alert: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningAlertArgs'],
                 occurrence_type: pulumi.Input[str],
                 resolution: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningResolutionArgs'],
                 time_range: pulumi.Input[str]):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "occurrence_type", occurrence_type)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningAlertArgs']:
        return pulumi.get(self, "alert")

    @alert.setter
    def alert(self, value: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningAlertArgs']):
        pulumi.set(self, "alert", value)

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "occurrence_type")

    @occurrence_type.setter
    def occurrence_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "occurrence_type", value)

    @property
    @pulumi.getter
    def resolution(self) -> pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningResolutionArgs']:
        return pulumi.get(self, "resolution")

    @resolution.setter
    def resolution(self, value: pulumi.Input['MonitorTriggerConditionsMetricsStaticConditionWarningResolutionArgs']):
        pulumi.set(self, "resolution", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsStaticConditionWarningAlertArgsDict(TypedDict):
        min_data_points: NotRequired[pulumi.Input[int]]
        threshold: NotRequired[pulumi.Input[float]]
        threshold_type: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsMetricsStaticConditionWarningAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsStaticConditionWarningAlertArgs:
    def __init__(__self__, *,
                 min_data_points: Optional[pulumi.Input[int]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_data_points")

    @min_data_points.setter
    def min_data_points(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_data_points", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


if not MYPY:
    class MonitorTriggerConditionsMetricsStaticConditionWarningResolutionArgsDict(TypedDict):
        min_data_points: NotRequired[pulumi.Input[int]]
        occurrence_type: NotRequired[pulumi.Input[str]]
        threshold: NotRequired[pulumi.Input[float]]
        threshold_type: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsMetricsStaticConditionWarningResolutionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsMetricsStaticConditionWarningResolutionArgs:
    def __init__(__self__, *,
                 min_data_points: Optional[pulumi.Input[int]] = None,
                 occurrence_type: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None,
                 threshold_type: Optional[pulumi.Input[str]] = None):
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_data_points")

    @min_data_points.setter
    def min_data_points(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_data_points", value)

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "occurrence_type")

    @occurrence_type.setter
    def occurrence_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "occurrence_type", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "threshold_type")

    @threshold_type.setter
    def threshold_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "threshold_type", value)


if not MYPY:
    class MonitorTriggerConditionsSloBurnRateConditionArgsDict(TypedDict):
        critical: NotRequired[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionCriticalArgsDict']]
        warning: NotRequired[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionWarningArgsDict']]
elif False:
    MonitorTriggerConditionsSloBurnRateConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsSloBurnRateConditionArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionCriticalArgs']] = None,
                 warning: Optional[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionWarningArgs']] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionCriticalArgs']]:
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionCriticalArgs']]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionWarningArgs']]:
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionWarningArgs']]):
        pulumi.set(self, "warning", value)


if not MYPY:
    class MonitorTriggerConditionsSloBurnRateConditionCriticalArgsDict(TypedDict):
        burn_rate_threshold: NotRequired[pulumi.Input[float]]
        burn_rates: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgsDict']]]]
        time_range: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsSloBurnRateConditionCriticalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsSloBurnRateConditionCriticalArgs:
    def __init__(__self__, *,
                 burn_rate_threshold: Optional[pulumi.Input[float]] = None,
                 burn_rates: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgs']]]] = None,
                 time_range: Optional[pulumi.Input[str]] = None):
        if burn_rate_threshold is not None:
            pulumi.set(__self__, "burn_rate_threshold", burn_rate_threshold)
        if burn_rates is not None:
            pulumi.set(__self__, "burn_rates", burn_rates)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="burnRateThreshold")
    def burn_rate_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "burn_rate_threshold")

    @burn_rate_threshold.setter
    def burn_rate_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "burn_rate_threshold", value)

    @property
    @pulumi.getter(name="burnRates")
    def burn_rates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgs']]]]:
        return pulumi.get(self, "burn_rates")

    @burn_rates.setter
    def burn_rates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgs']]]]):
        pulumi.set(self, "burn_rates", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgsDict(TypedDict):
        burn_rate_threshold: pulumi.Input[float]
        time_range: pulumi.Input[str]
elif False:
    MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgs:
    def __init__(__self__, *,
                 burn_rate_threshold: pulumi.Input[float],
                 time_range: pulumi.Input[str]):
        pulumi.set(__self__, "burn_rate_threshold", burn_rate_threshold)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="burnRateThreshold")
    def burn_rate_threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "burn_rate_threshold")

    @burn_rate_threshold.setter
    def burn_rate_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "burn_rate_threshold", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class MonitorTriggerConditionsSloBurnRateConditionWarningArgsDict(TypedDict):
        burn_rate_threshold: NotRequired[pulumi.Input[float]]
        burn_rates: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgsDict']]]]
        time_range: NotRequired[pulumi.Input[str]]
elif False:
    MonitorTriggerConditionsSloBurnRateConditionWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsSloBurnRateConditionWarningArgs:
    def __init__(__self__, *,
                 burn_rate_threshold: Optional[pulumi.Input[float]] = None,
                 burn_rates: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgs']]]] = None,
                 time_range: Optional[pulumi.Input[str]] = None):
        if burn_rate_threshold is not None:
            pulumi.set(__self__, "burn_rate_threshold", burn_rate_threshold)
        if burn_rates is not None:
            pulumi.set(__self__, "burn_rates", burn_rates)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="burnRateThreshold")
    def burn_rate_threshold(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "burn_rate_threshold")

    @burn_rate_threshold.setter
    def burn_rate_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "burn_rate_threshold", value)

    @property
    @pulumi.getter(name="burnRates")
    def burn_rates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgs']]]]:
        return pulumi.get(self, "burn_rates")

    @burn_rates.setter
    def burn_rates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgs']]]]):
        pulumi.set(self, "burn_rates", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgsDict(TypedDict):
        burn_rate_threshold: pulumi.Input[float]
        time_range: pulumi.Input[str]
elif False:
    MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgs:
    def __init__(__self__, *,
                 burn_rate_threshold: pulumi.Input[float],
                 time_range: pulumi.Input[str]):
        pulumi.set(__self__, "burn_rate_threshold", burn_rate_threshold)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="burnRateThreshold")
    def burn_rate_threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "burn_rate_threshold")

    @burn_rate_threshold.setter
    def burn_rate_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "burn_rate_threshold", value)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> pulumi.Input[str]:
        return pulumi.get(self, "time_range")

    @time_range.setter
    def time_range(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_range", value)


if not MYPY:
    class MonitorTriggerConditionsSloSliConditionArgsDict(TypedDict):
        critical: NotRequired[pulumi.Input['MonitorTriggerConditionsSloSliConditionCriticalArgsDict']]
        warning: NotRequired[pulumi.Input['MonitorTriggerConditionsSloSliConditionWarningArgsDict']]
elif False:
    MonitorTriggerConditionsSloSliConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsSloSliConditionArgs:
    def __init__(__self__, *,
                 critical: Optional[pulumi.Input['MonitorTriggerConditionsSloSliConditionCriticalArgs']] = None,
                 warning: Optional[pulumi.Input['MonitorTriggerConditionsSloSliConditionWarningArgs']] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional[pulumi.Input['MonitorTriggerConditionsSloSliConditionCriticalArgs']]:
        return pulumi.get(self, "critical")

    @critical.setter
    def critical(self, value: Optional[pulumi.Input['MonitorTriggerConditionsSloSliConditionCriticalArgs']]):
        pulumi.set(self, "critical", value)

    @property
    @pulumi.getter
    def warning(self) -> Optional[pulumi.Input['MonitorTriggerConditionsSloSliConditionWarningArgs']]:
        return pulumi.get(self, "warning")

    @warning.setter
    def warning(self, value: Optional[pulumi.Input['MonitorTriggerConditionsSloSliConditionWarningArgs']]):
        pulumi.set(self, "warning", value)


if not MYPY:
    class MonitorTriggerConditionsSloSliConditionCriticalArgsDict(TypedDict):
        sli_threshold: pulumi.Input[float]
elif False:
    MonitorTriggerConditionsSloSliConditionCriticalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsSloSliConditionCriticalArgs:
    def __init__(__self__, *,
                 sli_threshold: pulumi.Input[float]):
        pulumi.set(__self__, "sli_threshold", sli_threshold)

    @property
    @pulumi.getter(name="sliThreshold")
    def sli_threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "sli_threshold")

    @sli_threshold.setter
    def sli_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "sli_threshold", value)


if not MYPY:
    class MonitorTriggerConditionsSloSliConditionWarningArgsDict(TypedDict):
        sli_threshold: pulumi.Input[float]
elif False:
    MonitorTriggerConditionsSloSliConditionWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorTriggerConditionsSloSliConditionWarningArgs:
    def __init__(__self__, *,
                 sli_threshold: pulumi.Input[float]):
        pulumi.set(__self__, "sli_threshold", sli_threshold)

    @property
    @pulumi.getter(name="sliThreshold")
    def sli_threshold(self) -> pulumi.Input[float]:
        return pulumi.get(self, "sli_threshold")

    @sli_threshold.setter
    def sli_threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "sli_threshold", value)


if not MYPY:
    class MutingScheduleMonitorArgsDict(TypedDict):
        all: NotRequired[pulumi.Input[bool]]
        """
        True if the schedule applies to all monitors
        """
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of monitor Ids in hex. Must be empty if `all` is true.
        """
elif False:
    MutingScheduleMonitorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MutingScheduleMonitorArgs:
    def __init__(__self__, *,
                 all: Optional[pulumi.Input[bool]] = None,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] all: True if the schedule applies to all monitors
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ids: List of monitor Ids in hex. Must be empty if `all` is true.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def all(self) -> Optional[pulumi.Input[bool]]:
        """
        True if the schedule applies to all monitors
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of monitor Ids in hex. Must be empty if `all` is true.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class MutingScheduleNotificationGroupArgsDict(TypedDict):
        group_key: pulumi.Input[str]
        """
        Field name of an alert group defined in monitors. See [Alert Grouping](https://help.sumologic.com/docs/alerts/monitors/alert-grouping/) for more details.
        """
        group_values: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Values of alert groups generated by monitors

        [1]: https://help.sumologic.com/docs/alerts/monitors/muting-schedules/
        """
elif False:
    MutingScheduleNotificationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MutingScheduleNotificationGroupArgs:
    def __init__(__self__, *,
                 group_key: pulumi.Input[str],
                 group_values: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[str] group_key: Field name of an alert group defined in monitors. See [Alert Grouping](https://help.sumologic.com/docs/alerts/monitors/alert-grouping/) for more details.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] group_values: Values of alert groups generated by monitors
               
               [1]: https://help.sumologic.com/docs/alerts/monitors/muting-schedules/
        """
        pulumi.set(__self__, "group_key", group_key)
        pulumi.set(__self__, "group_values", group_values)

    @property
    @pulumi.getter(name="groupKey")
    def group_key(self) -> pulumi.Input[str]:
        """
        Field name of an alert group defined in monitors. See [Alert Grouping](https://help.sumologic.com/docs/alerts/monitors/alert-grouping/) for more details.
        """
        return pulumi.get(self, "group_key")

    @group_key.setter
    def group_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "group_key", value)

    @property
    @pulumi.getter(name="groupValues")
    def group_values(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Values of alert groups generated by monitors

        [1]: https://help.sumologic.com/docs/alerts/monitors/muting-schedules/
        """
        return pulumi.get(self, "group_values")

    @group_values.setter
    def group_values(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "group_values", value)


if not MYPY:
    class MutingScheduleScheduleArgsDict(TypedDict):
        duration: pulumi.Input[int]
        """
        Duration of the muting in minutes
        """
        start_date: pulumi.Input[str]
        """
        Schedule start date in the format of `yyyy-mm-dd`
        """
        start_time: pulumi.Input[str]
        """
        Schedule start time in the format of `hh:mm`
        """
        timezone: pulumi.Input[str]
        """
        Time zone for the schedule per
        [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        """
        rrule: NotRequired[pulumi.Input[str]]
        """
        Recurrence Rule. See https://freetools.textmagic.com/rrule-generator for more details.
        """
elif False:
    MutingScheduleScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MutingScheduleScheduleArgs:
    def __init__(__self__, *,
                 duration: pulumi.Input[int],
                 start_date: pulumi.Input[str],
                 start_time: pulumi.Input[str],
                 timezone: pulumi.Input[str],
                 rrule: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] duration: Duration of the muting in minutes
        :param pulumi.Input[str] start_date: Schedule start date in the format of `yyyy-mm-dd`
        :param pulumi.Input[str] start_time: Schedule start time in the format of `hh:mm`
        :param pulumi.Input[str] timezone: Time zone for the schedule per
               [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        :param pulumi.Input[str] rrule: Recurrence Rule. See https://freetools.textmagic.com/rrule-generator for more details.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "timezone", timezone)
        if rrule is not None:
            pulumi.set(__self__, "rrule", rrule)

    @property
    @pulumi.getter
    def duration(self) -> pulumi.Input[int]:
        """
        Duration of the muting in minutes
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: pulumi.Input[int]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input[str]:
        """
        Schedule start date in the format of `yyyy-mm-dd`
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[str]:
        """
        Schedule start time in the format of `hh:mm`
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def timezone(self) -> pulumi.Input[str]:
        """
        Time zone for the schedule per
        [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: pulumi.Input[str]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter
    def rrule(self) -> Optional[pulumi.Input[str]]:
        """
        Recurrence Rule. See https://freetools.textmagic.com/rrule-generator for more details.
        """
        return pulumi.get(self, "rrule")

    @rrule.setter
    def rrule(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rrule", value)


if not MYPY:
    class PoliciesUserConcurrentSessionsLimitArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Whether the [User Concurrent Sessions Limit Policy](https://help.sumologic.com/Manage/Security/Set_a_Limit_for_User_Concurrent_Sessions) is enabled.
        """
        max_concurrent_sessions: NotRequired[pulumi.Input[int]]
        """
        Maximum number of concurrent sessions a user may have. Defaults to `100`.
        """
elif False:
    PoliciesUserConcurrentSessionsLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PoliciesUserConcurrentSessionsLimitArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 max_concurrent_sessions: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether the [User Concurrent Sessions Limit Policy](https://help.sumologic.com/Manage/Security/Set_a_Limit_for_User_Concurrent_Sessions) is enabled.
        :param pulumi.Input[int] max_concurrent_sessions: Maximum number of concurrent sessions a user may have. Defaults to `100`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_concurrent_sessions is not None:
            pulumi.set(__self__, "max_concurrent_sessions", max_concurrent_sessions)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether the [User Concurrent Sessions Limit Policy](https://help.sumologic.com/Manage/Security/Set_a_Limit_for_User_Concurrent_Sessions) is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="maxConcurrentSessions")
    def max_concurrent_sessions(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent sessions a user may have. Defaults to `100`.
        """
        return pulumi.get(self, "max_concurrent_sessions")

    @max_concurrent_sessions.setter
    def max_concurrent_sessions(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_sessions", value)


if not MYPY:
    class PollingSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
elif False:
    PollingSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PollingSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)


if not MYPY:
    class PollingSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    PollingSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PollingSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class PollingSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    PollingSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PollingSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class PollingSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. Can be one of `S3BucketPathExpression` or  `CloudWatchPath`
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        """
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of namespaces to limit metrics collection. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace. This is a valid parameter if using type `CloudWatchPath`.
        """
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of Amazon regions to limit metricscollection. This is a valid parameter if  using type `CloudWatchPath`.
        """
        path_expression: NotRequired[pulumi.Input[str]]
        """
        The path to the data. This is needed if using type `S3BucketPathExpression`.
        """
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['PollingSourcePathTagFilterArgsDict']]]]
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. This is a valid parameter if using type `CloudWatchPath` More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
elif False:
    PollingSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PollingSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['PollingSourcePathTagFilterArgs']]]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. Can be one of `S3BucketPathExpression` or  `CloudWatchPath`
        :param pulumi.Input[str] bucket_name: The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_namespaces: List of namespaces to limit metrics collection. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace. This is a valid parameter if using type `CloudWatchPath`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] limit_to_regions: List of Amazon regions to limit metricscollection. This is a valid parameter if  using type `CloudWatchPath`.
        :param pulumi.Input[str] path_expression: The path to the data. This is needed if using type `S3BucketPathExpression`.
        :param pulumi.Input[Sequence[pulumi.Input['PollingSourcePathTagFilterArgs']]] tag_filters: Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. This is a valid parameter if using type `CloudWatchPath` More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. Can be one of `S3BucketPathExpression` or  `CloudWatchPath`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of namespaces to limit metrics collection. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace. This is a valid parameter if using type `CloudWatchPath`.
        """
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of Amazon regions to limit metricscollection. This is a valid parameter if  using type `CloudWatchPath`.
        """
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the data. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PollingSourcePathTagFilterArgs']]]]:
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. This is a valid parameter if using type `CloudWatchPath` More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PollingSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)


if not MYPY:
    class PollingSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        type: NotRequired[pulumi.Input[str]]
        """
        This value has to be set to `TagFilters`
        """
elif False:
    PollingSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PollingSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        :param pulumi.Input[str] type: This value has to be set to `TagFilters`
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RoleV2SelectedViewArgsDict(TypedDict):
        view_name: pulumi.Input[str]
        view_filter: NotRequired[pulumi.Input[str]]
elif False:
    RoleV2SelectedViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoleV2SelectedViewArgs:
    def __init__(__self__, *,
                 view_name: pulumi.Input[str],
                 view_filter: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "view_name", view_name)
        if view_filter is not None:
            pulumi.set(__self__, "view_filter", view_filter)

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "view_name")

    @view_name.setter
    def view_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "view_name", value)

    @property
    @pulumi.getter(name="viewFilter")
    def view_filter(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "view_filter")

    @view_filter.setter
    def view_filter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "view_filter", value)


if not MYPY:
    class RumSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    RumSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RumSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class RumSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    RumSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RumSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class RumSourcePathArgsDict(TypedDict):
        service_name: pulumi.Input[str]
        """
        Add a Service Name of a text string to show for the service name in spans (for example, "bookings-web-app").
        """
        application_name: NotRequired[pulumi.Input[str]]
        """
        (Recommended) Add an Application Name tag of a text string to show for the app name in spans (for example, bookings-app). This groups services in the Application Service View. If left blank, services will belong to a "default" application.
        """
        custom_tags: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Defines custom tags attached to the spans. For example: "internal.version = 0.1.21"
        """
        deployment_environment: NotRequired[pulumi.Input[str]]
        """
        Your production, staging, or development environment name.
        """
        ignore_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Add a list of URLs not to collect trace data from. Supports regex. Make sure provided URLs are valid JavaScript flavor regexes. For example: "/^https:\\/\\/www.tracker.com\\/.*/, /^https:\\/\\/api.mydomain.com\\/log\\/.*/"
        """
        propagate_trace_header_cors_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        (Recommended) Add a list of URLs or URL patterns that pass tracing context to construct traces end-to-end. Provided URLs should be valid JavaScript flavor regexes. Some examples are "/^https:\\/\\/api.mydomain.com\\/apiv3\\/.*/" and "/^https:\\/\\/www.3rdparty.com\\/.*/".
        """
        sampling_rate: NotRequired[pulumi.Input[float]]
        """
        Add a Probabilistic sampling rate for heavy traffic sites in a decimal value based on percentage, for example, 10% would be entered as 0.1. Supports floating values between 0.0 and 1.0, defaults to 1.0 (all data is passed).
        """
        selected_country: NotRequired[pulumi.Input[str]]
        """
        Specify if you want to enrich spans with the details level up to the city - if left blank, enrichment works down to the state level.
        """
elif False:
    RumSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RumSourcePathArgs:
    def __init__(__self__, *,
                 service_name: pulumi.Input[str],
                 application_name: Optional[pulumi.Input[str]] = None,
                 custom_tags: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 deployment_environment: Optional[pulumi.Input[str]] = None,
                 ignore_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 propagate_trace_header_cors_urls: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 sampling_rate: Optional[pulumi.Input[float]] = None,
                 selected_country: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_name: Add a Service Name of a text string to show for the service name in spans (for example, "bookings-web-app").
        :param pulumi.Input[str] application_name: (Recommended) Add an Application Name tag of a text string to show for the app name in spans (for example, bookings-app). This groups services in the Application Service View. If left blank, services will belong to a "default" application.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] custom_tags: Defines custom tags attached to the spans. For example: "internal.version = 0.1.21"
        :param pulumi.Input[str] deployment_environment: Your production, staging, or development environment name.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ignore_urls: Add a list of URLs not to collect trace data from. Supports regex. Make sure provided URLs are valid JavaScript flavor regexes. For example: "/^https:\\/\\/www.tracker.com\\/.*/, /^https:\\/\\/api.mydomain.com\\/log\\/.*/"
        :param pulumi.Input[Sequence[pulumi.Input[str]]] propagate_trace_header_cors_urls: (Recommended) Add a list of URLs or URL patterns that pass tracing context to construct traces end-to-end. Provided URLs should be valid JavaScript flavor regexes. Some examples are "/^https:\\/\\/api.mydomain.com\\/apiv3\\/.*/" and "/^https:\\/\\/www.3rdparty.com\\/.*/".
        :param pulumi.Input[float] sampling_rate: Add a Probabilistic sampling rate for heavy traffic sites in a decimal value based on percentage, for example, 10% would be entered as 0.1. Supports floating values between 0.0 and 1.0, defaults to 1.0 (all data is passed).
        :param pulumi.Input[str] selected_country: Specify if you want to enrich spans with the details level up to the city - if left blank, enrichment works down to the state level.
        """
        pulumi.set(__self__, "service_name", service_name)
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if deployment_environment is not None:
            pulumi.set(__self__, "deployment_environment", deployment_environment)
        if ignore_urls is not None:
            pulumi.set(__self__, "ignore_urls", ignore_urls)
        if propagate_trace_header_cors_urls is not None:
            pulumi.set(__self__, "propagate_trace_header_cors_urls", propagate_trace_header_cors_urls)
        if sampling_rate is not None:
            pulumi.set(__self__, "sampling_rate", sampling_rate)
        if selected_country is not None:
            pulumi.set(__self__, "selected_country", selected_country)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> pulumi.Input[str]:
        """
        Add a Service Name of a text string to show for the service name in spans (for example, "bookings-web-app").
        """
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "service_name", value)

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Recommended) Add an Application Name tag of a text string to show for the app name in spans (for example, bookings-app). This groups services in the Application Service View. If left blank, services will belong to a "default" application.
        """
        return pulumi.get(self, "application_name")

    @application_name.setter
    def application_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application_name", value)

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Defines custom tags attached to the spans. For example: "internal.version = 0.1.21"
        """
        return pulumi.get(self, "custom_tags")

    @custom_tags.setter
    def custom_tags(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "custom_tags", value)

    @property
    @pulumi.getter(name="deploymentEnvironment")
    def deployment_environment(self) -> Optional[pulumi.Input[str]]:
        """
        Your production, staging, or development environment name.
        """
        return pulumi.get(self, "deployment_environment")

    @deployment_environment.setter
    def deployment_environment(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deployment_environment", value)

    @property
    @pulumi.getter(name="ignoreUrls")
    def ignore_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Add a list of URLs not to collect trace data from. Supports regex. Make sure provided URLs are valid JavaScript flavor regexes. For example: "/^https:\\/\\/www.tracker.com\\/.*/, /^https:\\/\\/api.mydomain.com\\/log\\/.*/"
        """
        return pulumi.get(self, "ignore_urls")

    @ignore_urls.setter
    def ignore_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ignore_urls", value)

    @property
    @pulumi.getter(name="propagateTraceHeaderCorsUrls")
    def propagate_trace_header_cors_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Recommended) Add a list of URLs or URL patterns that pass tracing context to construct traces end-to-end. Provided URLs should be valid JavaScript flavor regexes. Some examples are "/^https:\\/\\/api.mydomain.com\\/apiv3\\/.*/" and "/^https:\\/\\/www.3rdparty.com\\/.*/".
        """
        return pulumi.get(self, "propagate_trace_header_cors_urls")

    @propagate_trace_header_cors_urls.setter
    def propagate_trace_header_cors_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "propagate_trace_header_cors_urls", value)

    @property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> Optional[pulumi.Input[float]]:
        """
        Add a Probabilistic sampling rate for heavy traffic sites in a decimal value based on percentage, for example, 10% would be entered as 0.1. Supports floating values between 0.0 and 1.0, defaults to 1.0 (all data is passed).
        """
        return pulumi.get(self, "sampling_rate")

    @sampling_rate.setter
    def sampling_rate(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "sampling_rate", value)

    @property
    @pulumi.getter(name="selectedCountry")
    def selected_country(self) -> Optional[pulumi.Input[str]]:
        """
        Specify if you want to enrich spans with the details level up to the city - if left blank, enrichment works down to the state level.
        """
        return pulumi.get(self, "selected_country")

    @selected_country.setter
    def selected_country(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "selected_country", value)


if not MYPY:
    class S3ArchiveSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    S3ArchiveSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3ArchiveSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class S3ArchiveSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    S3ArchiveSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3ArchiveSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class S3ArchiveSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    S3ArchiveSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3ArchiveSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class S3ArchiveSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the bucket.
        """
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        path_expression: NotRequired[pulumi.Input[str]]
        """
        The path to the data.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    S3ArchiveSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3ArchiveSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        :param pulumi.Input[str] bucket_name: The name of the bucket.
        :param pulumi.Input[str] path_expression: The path to the data.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['S3ArchiveSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class S3ArchiveSourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    S3ArchiveSourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3ArchiveSourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class S3ArchiveSourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    S3ArchiveSourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3ArchiveSourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class S3ArchiveSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    S3ArchiveSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3ArchiveSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class S3AuditSourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    S3AuditSourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AuditSourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class S3AuditSourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    S3AuditSourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AuditSourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class S3AuditSourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    S3AuditSourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AuditSourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class S3AuditSourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the bucket.
        """
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        path_expression: NotRequired[pulumi.Input[str]]
        """
        The path to the data.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
elif False:
    S3AuditSourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AuditSourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        :param pulumi.Input[str] bucket_name: The name of the bucket.
        :param pulumi.Input[str] path_expression: The path to the data.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathSnsTopicOrSubscriptionArnArgs']]] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['S3AuditSourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class S3AuditSourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    S3AuditSourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AuditSourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class S3AuditSourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    S3AuditSourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AuditSourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class S3AuditSourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    S3AuditSourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3AuditSourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class S3SourceAuthenticationArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        access_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        auth_provider_x509_cert_url: NotRequired[pulumi.Input[str]]
        auth_uri: NotRequired[pulumi.Input[str]]
        client_email: NotRequired[pulumi.Input[str]]
        client_id: NotRequired[pulumi.Input[str]]
        client_x509_cert_url: NotRequired[pulumi.Input[str]]
        private_key: NotRequired[pulumi.Input[str]]
        private_key_id: NotRequired[pulumi.Input[str]]
        project_id: NotRequired[pulumi.Input[str]]
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        role_arn: NotRequired[pulumi.Input[str]]
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        secret_key: NotRequired[pulumi.Input[str]]
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        shared_access_policy_key: NotRequired[pulumi.Input[str]]
        shared_access_policy_name: NotRequired[pulumi.Input[str]]
        token_uri: NotRequired[pulumi.Input[str]]
elif False:
    S3SourceAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3SourceAuthenticationArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 access_key: Optional[pulumi.Input[str]] = None,
                 auth_provider_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 auth_uri: Optional[pulumi.Input[str]] = None,
                 client_email: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 client_x509_cert_url: Optional[pulumi.Input[str]] = None,
                 private_key: Optional[pulumi.Input[str]] = None,
                 private_key_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 role_arn: Optional[pulumi.Input[str]] = None,
                 secret_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_key: Optional[pulumi.Input[str]] = None,
                 shared_access_policy_name: Optional[pulumi.Input[str]] = None,
                 token_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        :param pulumi.Input[str] access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[str] role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param pulumi.Input[str] secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @access_key.setter
    def access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "access_key", value)

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @auth_provider_x509_cert_url.setter
    def auth_provider_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_provider_x509_cert_url", value)

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "auth_uri")

    @auth_uri.setter
    def auth_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "auth_uri", value)

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_email")

    @client_email.setter
    def client_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_email", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "client_x509_cert_url")

    @client_x509_cert_url.setter
    def client_x509_cert_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_x509_cert_url", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "private_key_id")

    @private_key_id.setter
    def private_key_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role_arn", value)

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_key")

    @shared_access_policy_key.setter
    def shared_access_policy_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_key", value)

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "shared_access_policy_name")

    @shared_access_policy_name.setter
    def shared_access_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "shared_access_policy_name", value)

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "token_uri")

    @token_uri.setter
    def token_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token_uri", value)


if not MYPY:
    class S3SourceDefaultDateFormatArgsDict(TypedDict):
        format: pulumi.Input[str]
        locator: NotRequired[pulumi.Input[str]]
elif False:
    S3SourceDefaultDateFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3SourceDefaultDateFormatArgs:
    def __init__(__self__, *,
                 format: pulumi.Input[str],
                 locator: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> pulumi.Input[str]:
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: pulumi.Input[str]):
        pulumi.set(self, "format", value)

    @property
    @pulumi.getter
    def locator(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "locator")

    @locator.setter
    def locator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "locator", value)


if not MYPY:
    class S3SourceFilterArgsDict(TypedDict):
        filter_type: pulumi.Input[str]
        name: pulumi.Input[str]
        regexp: pulumi.Input[str]
        mask: NotRequired[pulumi.Input[str]]
elif False:
    S3SourceFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3SourceFilterArgs:
    def __init__(__self__, *,
                 filter_type: pulumi.Input[str],
                 name: pulumi.Input[str],
                 regexp: pulumi.Input[str],
                 mask: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> pulumi.Input[str]:
        return pulumi.get(self, "filter_type")

    @filter_type.setter
    def filter_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "filter_type", value)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def regexp(self) -> pulumi.Input[str]:
        return pulumi.get(self, "regexp")

    @regexp.setter
    def regexp(self, value: pulumi.Input[str]):
        pulumi.set(self, "regexp", value)

    @property
    @pulumi.getter
    def mask(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "mask")

    @mask.setter
    def mask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mask", value)


if not MYPY:
    class S3SourcePathArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The name of the bucket.
        """
        consumer_group: NotRequired[pulumi.Input[str]]
        custom_services: NotRequired[pulumi.Input[Sequence[pulumi.Input['S3SourcePathCustomServiceArgsDict']]]]
        event_hub_name: NotRequired[pulumi.Input[str]]
        limit_to_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_regions: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        limit_to_services: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        namespace: NotRequired[pulumi.Input[str]]
        path_expression: NotRequired[pulumi.Input[str]]
        """
        The path to the data.
        """
        region: NotRequired[pulumi.Input[str]]
        """
        Your AWS Bucket region.
        """
        sns_topic_or_subscription_arns: NotRequired[pulumi.Input[Sequence[pulumi.Input['S3SourcePathSnsTopicOrSubscriptionArnArgsDict']]]]
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        tag_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['S3SourcePathTagFilterArgsDict']]]]
        use_versioned_api: NotRequired[pulumi.Input[bool]]
        """
        Whether to Use AWS versioned APIs. Default is set to `true`. If you're collecting from a Cisco Umbrella bucket this must be set to `false`.
        """
elif False:
    S3SourcePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3SourcePathArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 consumer_group: Optional[pulumi.Input[str]] = None,
                 custom_services: Optional[pulumi.Input[Sequence[pulumi.Input['S3SourcePathCustomServiceArgs']]]] = None,
                 event_hub_name: Optional[pulumi.Input[str]] = None,
                 limit_to_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 limit_to_services: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 namespace: Optional[pulumi.Input[str]] = None,
                 path_expression: Optional[pulumi.Input[str]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 sns_topic_or_subscription_arns: Optional[pulumi.Input[Sequence[pulumi.Input['S3SourcePathSnsTopicOrSubscriptionArnArgs']]]] = None,
                 tag_filters: Optional[pulumi.Input[Sequence[pulumi.Input['S3SourcePathTagFilterArgs']]]] = None,
                 use_versioned_api: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        :param pulumi.Input[str] bucket_name: The name of the bucket.
        :param pulumi.Input[str] path_expression: The path to the data.
        :param pulumi.Input[str] region: Your AWS Bucket region.
        :param pulumi.Input[Sequence[pulumi.Input['S3SourcePathSnsTopicOrSubscriptionArnArgs']]] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        :param pulumi.Input[bool] use_versioned_api: Whether to Use AWS versioned APIs. Default is set to `true`. If you're collecting from a Cisco Umbrella bucket this must be set to `false`.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "consumer_group")

    @consumer_group.setter
    def consumer_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "consumer_group", value)

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['S3SourcePathCustomServiceArgs']]]]:
        return pulumi.get(self, "custom_services")

    @custom_services.setter
    def custom_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['S3SourcePathCustomServiceArgs']]]]):
        pulumi.set(self, "custom_services", value)

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "event_hub_name")

    @event_hub_name.setter
    def event_hub_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event_hub_name", value)

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_namespaces")

    @limit_to_namespaces.setter
    def limit_to_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_namespaces", value)

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_regions")

    @limit_to_regions.setter
    def limit_to_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_regions", value)

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "limit_to_services")

    @limit_to_services.setter
    def limit_to_services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "limit_to_services", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[pulumi.Input[str]]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @path_expression.setter
    def path_expression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path_expression", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['S3SourcePathSnsTopicOrSubscriptionArnArgs']]]]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @sns_topic_or_subscription_arns.setter
    def sns_topic_or_subscription_arns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['S3SourcePathSnsTopicOrSubscriptionArnArgs']]]]):
        pulumi.set(self, "sns_topic_or_subscription_arns", value)

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['S3SourcePathTagFilterArgs']]]]:
        return pulumi.get(self, "tag_filters")

    @tag_filters.setter
    def tag_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['S3SourcePathTagFilterArgs']]]]):
        pulumi.set(self, "tag_filters", value)

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to Use AWS versioned APIs. Default is set to `true`. If you're collecting from a Cisco Umbrella bucket this must be set to `false`.
        """
        return pulumi.get(self, "use_versioned_api")

    @use_versioned_api.setter
    def use_versioned_api(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_versioned_api", value)


if not MYPY:
    class S3SourcePathCustomServiceArgsDict(TypedDict):
        prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        service_name: NotRequired[pulumi.Input[str]]
elif False:
    S3SourcePathCustomServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3SourcePathCustomServiceArgs:
    def __init__(__self__, *,
                 prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 service_name: Optional[pulumi.Input[str]] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "prefixes")

    @prefixes.setter
    def prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "prefixes", value)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "service_name")

    @service_name.setter
    def service_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_name", value)


if not MYPY:
    class S3SourcePathSnsTopicOrSubscriptionArnArgsDict(TypedDict):
        arn: NotRequired[pulumi.Input[str]]
        is_success: NotRequired[pulumi.Input[bool]]
elif False:
    S3SourcePathSnsTopicOrSubscriptionArnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3SourcePathSnsTopicOrSubscriptionArnArgs:
    def __init__(__self__, *,
                 arn: Optional[pulumi.Input[str]] = None,
                 is_success: Optional[pulumi.Input[bool]] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "arn")

    @arn.setter
    def arn(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "arn", value)

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "is_success")

    @is_success.setter
    def is_success(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_success", value)


if not MYPY:
    class S3SourcePathTagFilterArgsDict(TypedDict):
        namespace: NotRequired[pulumi.Input[str]]
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        type: NotRequired[pulumi.Input[str]]
elif False:
    S3SourcePathTagFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class S3SourcePathTagFilterArgs:
    def __init__(__self__, *,
                 namespace: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SamlConfigurationOnDemandProvisioningEnabledArgsDict(TypedDict):
        on_demand_provisioning_roles: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        List of Sumo Logic RBAC roles to be assigned when user accounts are provisioned.
        """
        first_name_attribute: NotRequired[pulumi.Input[str]]
        """
        First name attribute of the new user account. Defaults to "".
        """
        last_name_attribute: NotRequired[pulumi.Input[str]]
        """
        Last name attribute of the new user account. Defaults to "".
        """
elif False:
    SamlConfigurationOnDemandProvisioningEnabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SamlConfigurationOnDemandProvisioningEnabledArgs:
    def __init__(__self__, *,
                 on_demand_provisioning_roles: pulumi.Input[Sequence[pulumi.Input[str]]],
                 first_name_attribute: Optional[pulumi.Input[str]] = None,
                 last_name_attribute: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] on_demand_provisioning_roles: List of Sumo Logic RBAC roles to be assigned when user accounts are provisioned.
        :param pulumi.Input[str] first_name_attribute: First name attribute of the new user account. Defaults to "".
        :param pulumi.Input[str] last_name_attribute: Last name attribute of the new user account. Defaults to "".
        """
        pulumi.set(__self__, "on_demand_provisioning_roles", on_demand_provisioning_roles)
        if first_name_attribute is not None:
            pulumi.set(__self__, "first_name_attribute", first_name_attribute)
        if last_name_attribute is not None:
            pulumi.set(__self__, "last_name_attribute", last_name_attribute)

    @property
    @pulumi.getter(name="onDemandProvisioningRoles")
    def on_demand_provisioning_roles(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        List of Sumo Logic RBAC roles to be assigned when user accounts are provisioned.
        """
        return pulumi.get(self, "on_demand_provisioning_roles")

    @on_demand_provisioning_roles.setter
    def on_demand_provisioning_roles(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "on_demand_provisioning_roles", value)

    @property
    @pulumi.getter(name="firstNameAttribute")
    def first_name_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        First name attribute of the new user account. Defaults to "".
        """
        return pulumi.get(self, "first_name_attribute")

    @first_name_attribute.setter
    def first_name_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "first_name_attribute", value)

    @property
    @pulumi.getter(name="lastNameAttribute")
    def last_name_attribute(self) -> Optional[pulumi.Input[str]]:
        """
        Last name attribute of the new user account. Defaults to "".
        """
        return pulumi.get(self, "last_name_attribute")

    @last_name_attribute.setter
    def last_name_attribute(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_name_attribute", value)


if not MYPY:
    class SloComplianceArgsDict(TypedDict):
        compliance_type: pulumi.Input[str]
        """
        The type of compliance to use. Valid values are `Rolling` or `Calendar`.
        """
        size: pulumi.Input[str]
        """
        The size of the compliance period to use.
        - For `Rolling` compliance type it must be a multiple of days e.g. `1d`, `2d`.
        - For `Calendar` compliance type the allowed values are `Week`, `Month`, `Quarter`.
        """
        target: pulumi.Input[float]
        """
        Target percentage for the SLI over the compliance period. Must be a number between 0 and 100.
        """
        timezone: pulumi.Input[str]
        """
        Time zone for the SLO compliance. Follow the format in the [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        """
        start_from: NotRequired[pulumi.Input[str]]
        """
        Start of the calendar window. For `Week` its required and it would be the day of the week (for e.g. Sunday,
        Monday etc).  For `Quarter` its required, it would be the first month of the start of quarter (for e.g. January, February etc.).
        For `Month` it's not required and is set to first day of the month.
        """
elif False:
    SloComplianceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloComplianceArgs:
    def __init__(__self__, *,
                 compliance_type: pulumi.Input[str],
                 size: pulumi.Input[str],
                 target: pulumi.Input[float],
                 timezone: pulumi.Input[str],
                 start_from: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compliance_type: The type of compliance to use. Valid values are `Rolling` or `Calendar`.
        :param pulumi.Input[str] size: The size of the compliance period to use.
               - For `Rolling` compliance type it must be a multiple of days e.g. `1d`, `2d`.
               - For `Calendar` compliance type the allowed values are `Week`, `Month`, `Quarter`.
        :param pulumi.Input[float] target: Target percentage for the SLI over the compliance period. Must be a number between 0 and 100.
        :param pulumi.Input[str] timezone: Time zone for the SLO compliance. Follow the format in the [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        :param pulumi.Input[str] start_from: Start of the calendar window. For `Week` its required and it would be the day of the week (for e.g. Sunday,
               Monday etc).  For `Quarter` its required, it would be the first month of the start of quarter (for e.g. January, February etc.).
               For `Month` it's not required and is set to first day of the month.
        """
        pulumi.set(__self__, "compliance_type", compliance_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "timezone", timezone)
        if start_from is not None:
            pulumi.set(__self__, "start_from", start_from)

    @property
    @pulumi.getter(name="complianceType")
    def compliance_type(self) -> pulumi.Input[str]:
        """
        The type of compliance to use. Valid values are `Rolling` or `Calendar`.
        """
        return pulumi.get(self, "compliance_type")

    @compliance_type.setter
    def compliance_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "compliance_type", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[str]:
        """
        The size of the compliance period to use.
        - For `Rolling` compliance type it must be a multiple of days e.g. `1d`, `2d`.
        - For `Calendar` compliance type the allowed values are `Week`, `Month`, `Quarter`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def target(self) -> pulumi.Input[float]:
        """
        Target percentage for the SLI over the compliance period. Must be a number between 0 and 100.
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[float]):
        pulumi.set(self, "target", value)

    @property
    @pulumi.getter
    def timezone(self) -> pulumi.Input[str]:
        """
        Time zone for the SLO compliance. Follow the format in the [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        """
        return pulumi.get(self, "timezone")

    @timezone.setter
    def timezone(self, value: pulumi.Input[str]):
        pulumi.set(self, "timezone", value)

    @property
    @pulumi.getter(name="startFrom")
    def start_from(self) -> Optional[pulumi.Input[str]]:
        """
        Start of the calendar window. For `Week` its required and it would be the day of the week (for e.g. Sunday,
        Monday etc).  For `Quarter` its required, it would be the first month of the start of quarter (for e.g. January, February etc.).
        For `Month` it's not required and is set to first day of the month.
        """
        return pulumi.get(self, "start_from")

    @start_from.setter
    def start_from(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_from", value)


if not MYPY:
    class SloIndicatorArgsDict(TypedDict):
        monitor_based_evaluation: NotRequired[pulumi.Input['SloIndicatorMonitorBasedEvaluationArgsDict']]
        request_based_evaluation: NotRequired[pulumi.Input['SloIndicatorRequestBasedEvaluationArgsDict']]
        window_based_evaluation: NotRequired[pulumi.Input['SloIndicatorWindowBasedEvaluationArgsDict']]
elif False:
    SloIndicatorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloIndicatorArgs:
    def __init__(__self__, *,
                 monitor_based_evaluation: Optional[pulumi.Input['SloIndicatorMonitorBasedEvaluationArgs']] = None,
                 request_based_evaluation: Optional[pulumi.Input['SloIndicatorRequestBasedEvaluationArgs']] = None,
                 window_based_evaluation: Optional[pulumi.Input['SloIndicatorWindowBasedEvaluationArgs']] = None):
        if monitor_based_evaluation is not None:
            pulumi.set(__self__, "monitor_based_evaluation", monitor_based_evaluation)
        if request_based_evaluation is not None:
            pulumi.set(__self__, "request_based_evaluation", request_based_evaluation)
        if window_based_evaluation is not None:
            pulumi.set(__self__, "window_based_evaluation", window_based_evaluation)

    @property
    @pulumi.getter(name="monitorBasedEvaluation")
    def monitor_based_evaluation(self) -> Optional[pulumi.Input['SloIndicatorMonitorBasedEvaluationArgs']]:
        return pulumi.get(self, "monitor_based_evaluation")

    @monitor_based_evaluation.setter
    def monitor_based_evaluation(self, value: Optional[pulumi.Input['SloIndicatorMonitorBasedEvaluationArgs']]):
        pulumi.set(self, "monitor_based_evaluation", value)

    @property
    @pulumi.getter(name="requestBasedEvaluation")
    def request_based_evaluation(self) -> Optional[pulumi.Input['SloIndicatorRequestBasedEvaluationArgs']]:
        return pulumi.get(self, "request_based_evaluation")

    @request_based_evaluation.setter
    def request_based_evaluation(self, value: Optional[pulumi.Input['SloIndicatorRequestBasedEvaluationArgs']]):
        pulumi.set(self, "request_based_evaluation", value)

    @property
    @pulumi.getter(name="windowBasedEvaluation")
    def window_based_evaluation(self) -> Optional[pulumi.Input['SloIndicatorWindowBasedEvaluationArgs']]:
        return pulumi.get(self, "window_based_evaluation")

    @window_based_evaluation.setter
    def window_based_evaluation(self, value: Optional[pulumi.Input['SloIndicatorWindowBasedEvaluationArgs']]):
        pulumi.set(self, "window_based_evaluation", value)


if not MYPY:
    class SloIndicatorMonitorBasedEvaluationArgsDict(TypedDict):
        monitor_triggers: pulumi.Input['SloIndicatorMonitorBasedEvaluationMonitorTriggersArgsDict']
        """
        Monitor details on which SLO will be based. Only single monitor is supported here.
        """
elif False:
    SloIndicatorMonitorBasedEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloIndicatorMonitorBasedEvaluationArgs:
    def __init__(__self__, *,
                 monitor_triggers: pulumi.Input['SloIndicatorMonitorBasedEvaluationMonitorTriggersArgs']):
        """
        :param pulumi.Input['SloIndicatorMonitorBasedEvaluationMonitorTriggersArgs'] monitor_triggers: Monitor details on which SLO will be based. Only single monitor is supported here.
        """
        pulumi.set(__self__, "monitor_triggers", monitor_triggers)

    @property
    @pulumi.getter(name="monitorTriggers")
    def monitor_triggers(self) -> pulumi.Input['SloIndicatorMonitorBasedEvaluationMonitorTriggersArgs']:
        """
        Monitor details on which SLO will be based. Only single monitor is supported here.
        """
        return pulumi.get(self, "monitor_triggers")

    @monitor_triggers.setter
    def monitor_triggers(self, value: pulumi.Input['SloIndicatorMonitorBasedEvaluationMonitorTriggersArgs']):
        pulumi.set(self, "monitor_triggers", value)


if not MYPY:
    class SloIndicatorMonitorBasedEvaluationMonitorTriggersArgsDict(TypedDict):
        monitor_id: pulumi.Input[str]
        """
        ID of the monitor. Ex: `0000000000BCB3A4`
        """
        trigger_types: pulumi.Input[str]
        """
        Type of monitor trigger which will attribute towards a successful or unsuccessful SLO 
        window. Valid values are `Critical`, `Warning`, `MissingData`. Only one trigger type is supported.

        [1]: https://help.sumologic.com/docs/observability/reliability-management-slo/

        [2]: slo_folder.html.markdown

        [3]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List
        """
elif False:
    SloIndicatorMonitorBasedEvaluationMonitorTriggersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloIndicatorMonitorBasedEvaluationMonitorTriggersArgs:
    def __init__(__self__, *,
                 monitor_id: pulumi.Input[str],
                 trigger_types: pulumi.Input[str]):
        """
        :param pulumi.Input[str] monitor_id: ID of the monitor. Ex: `0000000000BCB3A4`
        :param pulumi.Input[str] trigger_types: Type of monitor trigger which will attribute towards a successful or unsuccessful SLO 
               window. Valid values are `Critical`, `Warning`, `MissingData`. Only one trigger type is supported.
               
               [1]: https://help.sumologic.com/docs/observability/reliability-management-slo/
               
               [2]: slo_folder.html.markdown
               
               [3]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List
        """
        pulumi.set(__self__, "monitor_id", monitor_id)
        pulumi.set(__self__, "trigger_types", trigger_types)

    @property
    @pulumi.getter(name="monitorId")
    def monitor_id(self) -> pulumi.Input[str]:
        """
        ID of the monitor. Ex: `0000000000BCB3A4`
        """
        return pulumi.get(self, "monitor_id")

    @monitor_id.setter
    def monitor_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "monitor_id", value)

    @property
    @pulumi.getter(name="triggerTypes")
    def trigger_types(self) -> pulumi.Input[str]:
        """
        Type of monitor trigger which will attribute towards a successful or unsuccessful SLO 
        window. Valid values are `Critical`, `Warning`, `MissingData`. Only one trigger type is supported.

        [1]: https://help.sumologic.com/docs/observability/reliability-management-slo/

        [2]: slo_folder.html.markdown

        [3]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List
        """
        return pulumi.get(self, "trigger_types")

    @trigger_types.setter
    def trigger_types(self, value: pulumi.Input[str]):
        pulumi.set(self, "trigger_types", value)


if not MYPY:
    class SloIndicatorRequestBasedEvaluationArgsDict(TypedDict):
        queries: pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryArgsDict']]]
        """
        The queries to use.
        """
        query_type: pulumi.Input[str]
        """
        The type of query to use. Valid values are `Metrics` or `Logs`.
        """
        op: NotRequired[pulumi.Input[str]]
        """
        Comparison function with threshold. Valid values are `LessThan`, `LessThanOrEqual`, `GreaterThan`
        , `GreaterThanOrEqual`.
        """
        threshold: NotRequired[pulumi.Input[float]]
        """
        Compared against threshold query's raw data points to determine success criteria.
        """
elif False:
    SloIndicatorRequestBasedEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloIndicatorRequestBasedEvaluationArgs:
    def __init__(__self__, *,
                 queries: pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryArgs']]],
                 query_type: pulumi.Input[str],
                 op: Optional[pulumi.Input[str]] = None,
                 threshold: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryArgs']]] queries: The queries to use.
        :param pulumi.Input[str] query_type: The type of query to use. Valid values are `Metrics` or `Logs`.
        :param pulumi.Input[str] op: Comparison function with threshold. Valid values are `LessThan`, `LessThanOrEqual`, `GreaterThan`
               , `GreaterThanOrEqual`.
        :param pulumi.Input[float] threshold: Compared against threshold query's raw data points to determine success criteria.
        """
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "query_type", query_type)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def queries(self) -> pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryArgs']]]:
        """
        The queries to use.
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryArgs']]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> pulumi.Input[str]:
        """
        The type of query to use. Valid values are `Metrics` or `Logs`.
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_type", value)

    @property
    @pulumi.getter
    def op(self) -> Optional[pulumi.Input[str]]:
        """
        Comparison function with threshold. Valid values are `LessThan`, `LessThanOrEqual`, `GreaterThan`
        , `GreaterThanOrEqual`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[float]]:
        """
        Compared against threshold query's raw data points to determine success criteria.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class SloIndicatorRequestBasedEvaluationQueryArgsDict(TypedDict):
        query_group_type: pulumi.Input[str]
        """
        The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
        , `Threshold`.
        """
        query_groups: pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryQueryGroupArgsDict']]]
        """
        List of queries to use.
        """
elif False:
    SloIndicatorRequestBasedEvaluationQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloIndicatorRequestBasedEvaluationQueryArgs:
    def __init__(__self__, *,
                 query_group_type: pulumi.Input[str],
                 query_groups: pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryQueryGroupArgs']]]):
        """
        :param pulumi.Input[str] query_group_type: The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
               , `Threshold`.
        :param pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryQueryGroupArgs']]] query_groups: List of queries to use.
        """
        pulumi.set(__self__, "query_group_type", query_group_type)
        pulumi.set(__self__, "query_groups", query_groups)

    @property
    @pulumi.getter(name="queryGroupType")
    def query_group_type(self) -> pulumi.Input[str]:
        """
        The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
        , `Threshold`.
        """
        return pulumi.get(self, "query_group_type")

    @query_group_type.setter
    def query_group_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_group_type", value)

    @property
    @pulumi.getter(name="queryGroups")
    def query_groups(self) -> pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryQueryGroupArgs']]]:
        """
        List of queries to use.
        """
        return pulumi.get(self, "query_groups")

    @query_groups.setter
    def query_groups(self, value: pulumi.Input[Sequence[pulumi.Input['SloIndicatorRequestBasedEvaluationQueryQueryGroupArgs']]]):
        pulumi.set(self, "query_groups", value)


if not MYPY:
    class SloIndicatorRequestBasedEvaluationQueryQueryGroupArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        The query string to use.
        """
        row_id: pulumi.Input[str]
        """
        The row ID to use.
        """
        use_row_count: pulumi.Input[bool]
        """
        Whether to use the row count. Defaults to false.
        """
        field: NotRequired[pulumi.Input[str]]
        """
        Field of log query output to compare against. To be used only for logs based data
        type when `use_row_count` is false.
        """
elif False:
    SloIndicatorRequestBasedEvaluationQueryQueryGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloIndicatorRequestBasedEvaluationQueryQueryGroupArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 row_id: pulumi.Input[str],
                 use_row_count: pulumi.Input[bool],
                 field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The query string to use.
        :param pulumi.Input[str] row_id: The row ID to use.
        :param pulumi.Input[bool] use_row_count: Whether to use the row count. Defaults to false.
        :param pulumi.Input[str] field: Field of log query output to compare against. To be used only for logs based data
               type when `use_row_count` is false.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)
        pulumi.set(__self__, "use_row_count", use_row_count)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query string to use.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> pulumi.Input[str]:
        """
        The row ID to use.
        """
        return pulumi.get(self, "row_id")

    @row_id.setter
    def row_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "row_id", value)

    @property
    @pulumi.getter(name="useRowCount")
    def use_row_count(self) -> pulumi.Input[bool]:
        """
        Whether to use the row count. Defaults to false.
        """
        return pulumi.get(self, "use_row_count")

    @use_row_count.setter
    def use_row_count(self, value: pulumi.Input[bool]):
        pulumi.set(self, "use_row_count", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        Field of log query output to compare against. To be used only for logs based data
        type when `use_row_count` is false.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)


if not MYPY:
    class SloIndicatorWindowBasedEvaluationArgsDict(TypedDict):
        op: pulumi.Input[str]
        """
        The operator used to define a successful window. Valid values are `LessThan`
        , `LessThanOrEqual`, `GreaterThan`
        , `GreaterThanOrEqual`.
        """
        queries: pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryArgsDict']]]
        """
        The queries to use.
        """
        query_type: pulumi.Input[str]
        """
        The type of query to use. Valid values are `Metrics` or `Logs`.
        """
        size: pulumi.Input[str]
        """
        The size of the window to use, minimum of `1m` and maximum of `1h`.
        """
        threshold: pulumi.Input[float]
        """
        Threshold for classifying window as successful or unsuccessful, i.e. the minimum value
        for `(good windows / total windows) * 100`.
        """
        aggregation: NotRequired[pulumi.Input[str]]
        """
        Aggregation function applied over each window to arrive at SLI. Valid values are `Avg`
        , `Sum`, `Count`, `Max`, `Min` and `p[1-99]`.
        """
elif False:
    SloIndicatorWindowBasedEvaluationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloIndicatorWindowBasedEvaluationArgs:
    def __init__(__self__, *,
                 op: pulumi.Input[str],
                 queries: pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryArgs']]],
                 query_type: pulumi.Input[str],
                 size: pulumi.Input[str],
                 threshold: pulumi.Input[float],
                 aggregation: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] op: The operator used to define a successful window. Valid values are `LessThan`
               , `LessThanOrEqual`, `GreaterThan`
               , `GreaterThanOrEqual`.
        :param pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryArgs']]] queries: The queries to use.
        :param pulumi.Input[str] query_type: The type of query to use. Valid values are `Metrics` or `Logs`.
        :param pulumi.Input[str] size: The size of the window to use, minimum of `1m` and maximum of `1h`.
        :param pulumi.Input[float] threshold: Threshold for classifying window as successful or unsuccessful, i.e. the minimum value
               for `(good windows / total windows) * 100`.
        :param pulumi.Input[str] aggregation: Aggregation function applied over each window to arrive at SLI. Valid values are `Avg`
               , `Sum`, `Count`, `Max`, `Min` and `p[1-99]`.
        """
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "query_type", query_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "threshold", threshold)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)

    @property
    @pulumi.getter
    def op(self) -> pulumi.Input[str]:
        """
        The operator used to define a successful window. Valid values are `LessThan`
        , `LessThanOrEqual`, `GreaterThan`
        , `GreaterThanOrEqual`.
        """
        return pulumi.get(self, "op")

    @op.setter
    def op(self, value: pulumi.Input[str]):
        pulumi.set(self, "op", value)

    @property
    @pulumi.getter
    def queries(self) -> pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryArgs']]]:
        """
        The queries to use.
        """
        return pulumi.get(self, "queries")

    @queries.setter
    def queries(self, value: pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryArgs']]]):
        pulumi.set(self, "queries", value)

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> pulumi.Input[str]:
        """
        The type of query to use. Valid values are `Metrics` or `Logs`.
        """
        return pulumi.get(self, "query_type")

    @query_type.setter
    def query_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_type", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[str]:
        """
        The size of the window to use, minimum of `1m` and maximum of `1h`.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[float]:
        """
        Threshold for classifying window as successful or unsuccessful, i.e. the minimum value
        for `(good windows / total windows) * 100`.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[float]):
        pulumi.set(self, "threshold", value)

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[pulumi.Input[str]]:
        """
        Aggregation function applied over each window to arrive at SLI. Valid values are `Avg`
        , `Sum`, `Count`, `Max`, `Min` and `p[1-99]`.
        """
        return pulumi.get(self, "aggregation")

    @aggregation.setter
    def aggregation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "aggregation", value)


if not MYPY:
    class SloIndicatorWindowBasedEvaluationQueryArgsDict(TypedDict):
        query_group_type: pulumi.Input[str]
        """
        The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
        , `Threshold`.
        """
        query_groups: pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryQueryGroupArgsDict']]]
        """
        List of queries to use.
        """
elif False:
    SloIndicatorWindowBasedEvaluationQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloIndicatorWindowBasedEvaluationQueryArgs:
    def __init__(__self__, *,
                 query_group_type: pulumi.Input[str],
                 query_groups: pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryQueryGroupArgs']]]):
        """
        :param pulumi.Input[str] query_group_type: The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
               , `Threshold`.
        :param pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryQueryGroupArgs']]] query_groups: List of queries to use.
        """
        pulumi.set(__self__, "query_group_type", query_group_type)
        pulumi.set(__self__, "query_groups", query_groups)

    @property
    @pulumi.getter(name="queryGroupType")
    def query_group_type(self) -> pulumi.Input[str]:
        """
        The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
        , `Threshold`.
        """
        return pulumi.get(self, "query_group_type")

    @query_group_type.setter
    def query_group_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "query_group_type", value)

    @property
    @pulumi.getter(name="queryGroups")
    def query_groups(self) -> pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryQueryGroupArgs']]]:
        """
        List of queries to use.
        """
        return pulumi.get(self, "query_groups")

    @query_groups.setter
    def query_groups(self, value: pulumi.Input[Sequence[pulumi.Input['SloIndicatorWindowBasedEvaluationQueryQueryGroupArgs']]]):
        pulumi.set(self, "query_groups", value)


if not MYPY:
    class SloIndicatorWindowBasedEvaluationQueryQueryGroupArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        The query string to use.
        """
        row_id: pulumi.Input[str]
        """
        The row ID to use.
        """
        use_row_count: pulumi.Input[bool]
        """
        Whether to use the row count. Defaults to false.
        """
        field: NotRequired[pulumi.Input[str]]
        """
        Field of log query output to compare against. To be used only for logs based data
        type when `use_row_count` is false.
        """
elif False:
    SloIndicatorWindowBasedEvaluationQueryQueryGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SloIndicatorWindowBasedEvaluationQueryQueryGroupArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 row_id: pulumi.Input[str],
                 use_row_count: pulumi.Input[bool],
                 field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: The query string to use.
        :param pulumi.Input[str] row_id: The row ID to use.
        :param pulumi.Input[bool] use_row_count: Whether to use the row count. Defaults to false.
        :param pulumi.Input[str] field: Field of log query output to compare against. To be used only for logs based data
               type when `use_row_count` is false.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)
        pulumi.set(__self__, "use_row_count", use_row_count)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        The query string to use.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> pulumi.Input[str]:
        """
        The row ID to use.
        """
        return pulumi.get(self, "row_id")

    @row_id.setter
    def row_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "row_id", value)

    @property
    @pulumi.getter(name="useRowCount")
    def use_row_count(self) -> pulumi.Input[bool]:
        """
        Whether to use the row count. Defaults to false.
        """
        return pulumi.get(self, "use_row_count")

    @use_row_count.setter
    def use_row_count(self, value: pulumi.Input[bool]):
        pulumi.set(self, "use_row_count", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        Field of log query output to compare against. To be used only for logs based data
        type when `use_row_count` is false.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)


