# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from . import _utilities
from . import outputs

__all__ = [
    'AwsInventorySourceAuthentication',
    'AwsInventorySourceDefaultDateFormat',
    'AwsInventorySourceFilter',
    'AwsInventorySourcePath',
    'AwsInventorySourcePathCustomService',
    'AwsInventorySourcePathSnsTopicOrSubscriptionArn',
    'AwsInventorySourcePathTagFilter',
    'AwsXraySourceAuthentication',
    'AwsXraySourceDefaultDateFormat',
    'AwsXraySourceFilter',
    'AwsXraySourcePath',
    'AwsXraySourcePathCustomService',
    'AwsXraySourcePathSnsTopicOrSubscriptionArn',
    'AwsXraySourcePathTagFilter',
    'CloudSyslogSourceDefaultDateFormat',
    'CloudSyslogSourceFilter',
    'CloudfrontSourceAuthentication',
    'CloudfrontSourceDefaultDateFormat',
    'CloudfrontSourceFilter',
    'CloudfrontSourcePath',
    'CloudfrontSourcePathCustomService',
    'CloudfrontSourcePathSnsTopicOrSubscriptionArn',
    'CloudfrontSourcePathTagFilter',
    'CloudtrailSourceAuthentication',
    'CloudtrailSourceDefaultDateFormat',
    'CloudtrailSourceFilter',
    'CloudtrailSourcePath',
    'CloudtrailSourcePathCustomService',
    'CloudtrailSourcePathSnsTopicOrSubscriptionArn',
    'CloudtrailSourcePathTagFilter',
    'CloudwatchSourceAuthentication',
    'CloudwatchSourceDefaultDateFormat',
    'CloudwatchSourceFilter',
    'CloudwatchSourcePath',
    'CloudwatchSourcePathCustomService',
    'CloudwatchSourcePathSnsTopicOrSubscriptionArn',
    'CloudwatchSourcePathTagFilter',
    'ContentPermissionPermission',
    'CseAggregationRuleAggregationFunction',
    'CseAggregationRuleEntitySelector',
    'CseAggregationRuleSeverityMapping',
    'CseAggregationRuleSeverityMappingMapping',
    'CseChainRuleEntitySelector',
    'CseChainRuleExpressionsAndLimit',
    'CseLogMappingField',
    'CseLogMappingFieldLookup',
    'CseLogMappingStructuredInput',
    'CseLogMappingUnstructuredFields',
    'CseMatchListItem',
    'CseMatchRuleEntitySelector',
    'CseMatchRuleSeverityMapping',
    'CseMatchRuleSeverityMappingMapping',
    'CseThresholdRuleEntitySelector',
    'DashboardColoringRule',
    'DashboardColoringRuleColorThreshold',
    'DashboardLayout',
    'DashboardLayoutGrid',
    'DashboardLayoutGridLayoutStructure',
    'DashboardPanel',
    'DashboardPanelSumoSearchPanel',
    'DashboardPanelSumoSearchPanelColoringRule',
    'DashboardPanelSumoSearchPanelColoringRuleColorThreshold',
    'DashboardPanelSumoSearchPanelLinkedDashboard',
    'DashboardPanelSumoSearchPanelQuery',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryData',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter',
    'DashboardPanelSumoSearchPanelTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange',
    'DashboardPanelTextPanel',
    'DashboardTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFrom',
    'DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeTo',
    'DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'DashboardTimeRangeCompleteLiteralTimeRange',
    'DashboardTopologyLabelMap',
    'DashboardTopologyLabelMapData',
    'DashboardVariable',
    'DashboardVariableSourceDefinition',
    'DashboardVariableSourceDefinitionCsvVariableSourceDefinition',
    'DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition',
    'DashboardVariableSourceDefinitionMetadataVariableSourceDefinition',
    'ElbSourceAuthentication',
    'ElbSourceDefaultDateFormat',
    'ElbSourceFilter',
    'ElbSourcePath',
    'ElbSourcePathCustomService',
    'ElbSourcePathSnsTopicOrSubscriptionArn',
    'ElbSourcePathTagFilter',
    'GcpMetricsSourceAuthentication',
    'GcpMetricsSourceDefaultDateFormat',
    'GcpMetricsSourceFilter',
    'GcpMetricsSourcePath',
    'GcpMetricsSourcePathCustomService',
    'GcpMetricsSourcePathSnsTopicOrSubscriptionArn',
    'GcpMetricsSourcePathTagFilter',
    'GcpSourceAuthentication',
    'GcpSourceDefaultDateFormat',
    'GcpSourceFilter',
    'GcpSourcePath',
    'HierarchyFilter',
    'HierarchyLevel',
    'HierarchyLevelNextLevel',
    'HierarchyLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HttpSourceDefaultDateFormat',
    'HttpSourceFilter',
    'KineisLogSourceAuthentication',
    'KineisLogSourceDefaultDateFormat',
    'KineisLogSourceFilter',
    'KineisLogSourcePath',
    'KinesisMetricsSourceAuthentication',
    'KinesisMetricsSourceDefaultDateFormat',
    'KinesisMetricsSourceFilter',
    'KinesisMetricsSourcePath',
    'KinesisMetricsSourcePathTagFilter',
    'LookupTableField',
    'MetadataSourceAuthentication',
    'MetadataSourceDefaultDateFormat',
    'MetadataSourceFilter',
    'MetadataSourcePath',
    'MonitorNotification',
    'MonitorNotificationNotification',
    'MonitorQuery',
    'MonitorTrigger',
    'MonitorTriggerConditions',
    'MonitorTriggerConditionsLogsMissingDataCondition',
    'MonitorTriggerConditionsLogsOutlierCondition',
    'MonitorTriggerConditionsLogsOutlierConditionCritical',
    'MonitorTriggerConditionsLogsOutlierConditionWarning',
    'MonitorTriggerConditionsLogsStaticCondition',
    'MonitorTriggerConditionsLogsStaticConditionCritical',
    'MonitorTriggerConditionsLogsStaticConditionCriticalAlert',
    'MonitorTriggerConditionsLogsStaticConditionCriticalResolution',
    'MonitorTriggerConditionsLogsStaticConditionWarning',
    'MonitorTriggerConditionsLogsStaticConditionWarningAlert',
    'MonitorTriggerConditionsLogsStaticConditionWarningResolution',
    'MonitorTriggerConditionsMetricsMissingDataCondition',
    'MonitorTriggerConditionsMetricsOutlierCondition',
    'MonitorTriggerConditionsMetricsOutlierConditionCritical',
    'MonitorTriggerConditionsMetricsOutlierConditionWarning',
    'MonitorTriggerConditionsMetricsStaticCondition',
    'MonitorTriggerConditionsMetricsStaticConditionCritical',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalAlert',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalResolution',
    'MonitorTriggerConditionsMetricsStaticConditionWarning',
    'MonitorTriggerConditionsMetricsStaticConditionWarningAlert',
    'MonitorTriggerConditionsMetricsStaticConditionWarningResolution',
    'PoliciesUserConcurrentSessionsLimit',
    'PollingSourceAuthentication',
    'PollingSourceDefaultDateFormat',
    'PollingSourceFilter',
    'PollingSourcePath',
    'PollingSourcePathTagFilter',
    'S3AuditSourceAuthentication',
    'S3AuditSourceDefaultDateFormat',
    'S3AuditSourceFilter',
    'S3AuditSourcePath',
    'S3AuditSourcePathCustomService',
    'S3AuditSourcePathSnsTopicOrSubscriptionArn',
    'S3AuditSourcePathTagFilter',
    'S3SourceAuthentication',
    'S3SourceDefaultDateFormat',
    'S3SourceFilter',
    'S3SourcePath',
    'S3SourcePathCustomService',
    'S3SourcePathSnsTopicOrSubscriptionArn',
    'S3SourcePathTagFilter',
    'SamlConfigurationOnDemandProvisioningEnabled',
]

@pulumi.output_type
class AwsInventorySourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 auth_provider_x509_cert_url: Optional[str] = None,
                 auth_uri: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_x509_cert_url: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 token_uri: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        :param str role_arn: Your AWS role ARN. More details [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Grant-Access-to-an-AWS-Product#iam-role).
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN. More details [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Grant-Access-to-an-AWS-Product#iam-role).
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class AwsInventorySourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class AwsInventorySourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class AwsInventorySourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 custom_services: Optional[Sequence['outputs.AwsInventorySourcePathCustomService']] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 limit_to_services: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.AwsInventorySourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.AwsInventorySourcePathTagFilter']] = None):
        """
        :param str type: type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        :param Sequence[str] limit_to_namespaces: List of namespaces. By default all namespaces are selected. You can also choose a subset from
               + AWS/EC2
               + AWS/AutoScaling
               + AWS/EBS
               + AWS/ELB
               + AWS/ApplicationELB
               + AWS/NetworkELB
               + AWS/Lambda
               + AWS/RDS
               + AWS/Dynamodb
               + AWS/ECS
               + AWS/Elasticache
               + AWS/Redshift
               + AWS/Kinesis
        :param Sequence[str] limit_to_regions: List of Amazon regions.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.AwsInventorySourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        """
        List of namespaces. By default all namespaces are selected. You can also choose a subset from
        + AWS/EC2
        + AWS/AutoScaling
        + AWS/EBS
        + AWS/ELB
        + AWS/ApplicationELB
        + AWS/NetworkELB
        + AWS/Lambda
        + AWS/RDS
        + AWS/Dynamodb
        + AWS/ECS
        + AWS/Elasticache
        + AWS/Redshift
        + AWS/Kinesis
        """
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.AwsInventorySourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AwsInventorySourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class AwsInventorySourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AwsInventorySourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_success: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class AwsInventorySourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AwsXraySourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 auth_provider_x509_cert_url: Optional[str] = None,
                 auth_uri: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_x509_cert_url: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 token_uri: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class AwsXraySourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class AwsXraySourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class AwsXraySourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 custom_services: Optional[Sequence['outputs.AwsXraySourcePathCustomService']] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 limit_to_services: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.AwsXraySourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.AwsXraySourcePathTagFilter']] = None):
        """
        :param str type: type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        :param Sequence[str] limit_to_regions: List of Amazon regions.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.AwsXraySourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.AwsXraySourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AwsXraySourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class AwsXraySourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AwsXraySourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_success: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class AwsXraySourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CloudSyslogSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudSyslogSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudSyslogSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudSyslogSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudSyslogSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudfrontSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 auth_provider_x509_cert_url: Optional[str] = None,
                 auth_uri: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_x509_cert_url: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 token_uri: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param str region: Your AWS Bucket region.
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class CloudfrontSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudfrontSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudfrontSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 custom_services: Optional[Sequence['outputs.CloudfrontSourcePathCustomService']] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 limit_to_services: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.CloudfrontSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.CloudfrontSourcePathTagFilter']] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        :param str bucket_name: The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        :param str path_expression: The path to the data. This is needed if using type `S3BucketPathExpression`.
        :param Sequence['CloudfrontSourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.CloudfrontSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        """
        The path to the data. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.CloudfrontSourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.CloudfrontSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class CloudfrontSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class CloudfrontSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_success: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class CloudfrontSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CloudtrailSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 auth_provider_x509_cert_url: Optional[str] = None,
                 auth_uri: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_x509_cert_url: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 token_uri: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param str region: Your AWS Bucket region.
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class CloudtrailSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudtrailSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudtrailSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 custom_services: Optional[Sequence['outputs.CloudtrailSourcePathCustomService']] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 limit_to_services: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.CloudtrailSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.CloudtrailSourcePathTagFilter']] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        :param str bucket_name: The name of the bucket.
        :param str path_expression: The path to the data.
        :param Sequence['CloudtrailSourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.CloudtrailSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.CloudtrailSourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.CloudtrailSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class CloudtrailSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class CloudtrailSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_success: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class CloudtrailSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CloudwatchSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 auth_provider_x509_cert_url: Optional[str] = None,
                 auth_uri: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_x509_cert_url: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 token_uri: Optional[str] = None):
        """
        :param str type: This value has to be set to `TagFilters`
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param str region: Your AWS Bucket region.
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class CloudwatchSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudwatchSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudwatchSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 custom_services: Optional[Sequence['outputs.CloudwatchSourcePathCustomService']] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 limit_to_services: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.CloudwatchSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.CloudwatchSourcePathTagFilter']] = None):
        """
        :param str type: This value has to be set to `TagFilters`
        :param Sequence[str] limit_to_namespaces: List of namespaces. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace.
        :param Sequence[str] limit_to_regions: List of Amazon regions.
        :param Sequence['CloudwatchSourcePathTagFilterArgs'] tag_filters: Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.CloudwatchSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        """
        List of namespaces. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace.
        """
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.CloudwatchSourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.CloudwatchSourcePathTagFilter']]:
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class CloudwatchSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class CloudwatchSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_success: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class CloudwatchSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param Sequence[str] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        :param str type: This value has to be set to `TagFilters`
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ContentPermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionName":
            suggest = "permission_name"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentPermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentPermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentPermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission_name: str,
                 source_id: str,
                 source_type: str):
        """
        :param str permission_name: Content permission name. Valid values are `View`, `GrantView`,
               `Edit`, `GrantEdit`, `Manage`, and `GrantManage`. You can read more about permission levels
               [here](https://help.sumologic.com/Manage/Content_Sharing/Share-Content#available-permission-levels).
        :param str source_id: An identifier that belongs to the source type chosen above. For example,
               if the `sourceType` is set to `user`, `sourceId` should be identifier of the user you want to share
               content with (same goes for role and org source type).
        :param str source_type: Type of source for the permission. Valid values are `user`, `role`,
               and `org`.
        """
        pulumi.set(__self__, "permission_name", permission_name)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="permissionName")
    def permission_name(self) -> str:
        """
        Content permission name. Valid values are `View`, `GrantView`,
        `Edit`, `GrantEdit`, `Manage`, and `GrantManage`. You can read more about permission levels
        [here](https://help.sumologic.com/Manage/Content_Sharing/Share-Content#available-permission-levels).
        """
        return pulumi.get(self, "permission_name")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> str:
        """
        An identifier that belongs to the source type chosen above. For example,
        if the `sourceType` is set to `user`, `sourceId` should be identifier of the user you want to share
        content with (same goes for role and org source type).
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> str:
        """
        Type of source for the permission. Valid values are `user`, `role`,
        and `org`.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class CseAggregationRuleAggregationFunction(dict):
    def __init__(__self__, *,
                 arguments: Sequence[str],
                 function: str,
                 name: str):
        """
        :param Sequence[str] arguments: One or more expressions to pass as arguments to the function
        :param str function: The function to aggregate with
        :param str name: The name of the Rule
        """
        pulumi.set(__self__, "arguments", arguments)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arguments(self) -> Sequence[str]:
        """
        One or more expressions to pass as arguments to the function
        """
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter
    def function(self) -> str:
        """
        The function to aggregate with
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        The name of the Rule
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CseAggregationRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseAggregationRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseAggregationRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseAggregationRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 expression: str):
        """
        :param str expression: The expression or field name to generate the Signal on.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression or field name to generate the Signal on.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class CseAggregationRuleSeverityMapping(dict):
    def __init__(__self__, *,
                 type: str,
                 default: Optional[int] = None,
                 field: Optional[str] = None,
                 mappings: Optional[Sequence['outputs.CseAggregationRuleSeverityMappingMapping']] = None):
        """
        :param str type: Must be set to "eq" currently
        :param int default: The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        :param str field: The field to use in the "fieldValue"/"fieldValueMapping" cases.
        :param Sequence['CseAggregationRuleSeverityMappingMappingArgs'] mappings: The map of record values to severities to use in the "fieldValueMapping" case
        """
        pulumi.set(__self__, "type", type)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Must be set to "eq" currently
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        """
        The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        The field to use in the "fieldValue"/"fieldValueMapping" cases.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.CseAggregationRuleSeverityMappingMapping']]:
        """
        The map of record values to severities to use in the "fieldValueMapping" case
        """
        return pulumi.get(self, "mappings")


@pulumi.output_type
class CseAggregationRuleSeverityMappingMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseAggregationRuleSeverityMappingMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseAggregationRuleSeverityMappingMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseAggregationRuleSeverityMappingMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: str,
                 to: int,
                 type: str):
        """
        :param str from_: The record value to map from
        :param int to: The severity value to map to
        :param str type: Must be set to "eq" currently
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        """
        The record value to map from
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        """
        The severity value to map to
        """
        return pulumi.get(self, "to")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Must be set to "eq" currently
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CseChainRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseChainRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseChainRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseChainRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 expression: str):
        """
        :param str expression: The expression for which records to match on
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression for which records to match on
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class CseChainRuleExpressionsAndLimit(dict):
    def __init__(__self__, *,
                 expression: str,
                 limit: int):
        """
        :param str expression: The expression for which records to match on
        :param int limit: How many times this expression must match for the Signal to fire
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression for which records to match on
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def limit(self) -> int:
        """
        How many times this expression must match for the Signal to fire
        """
        return pulumi.get(self, "limit")


@pulumi.output_type
class CseLogMappingField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternateValues":
            suggest = "alternate_values"
        elif key == "caseInsensitive":
            suggest = "case_insensitive"
        elif key == "defaultValue":
            suggest = "default_value"
        elif key == "fieldJoins":
            suggest = "field_joins"
        elif key == "formatParameters":
            suggest = "format_parameters"
        elif key == "joinDelimiter":
            suggest = "join_delimiter"
        elif key == "skippedValues":
            suggest = "skipped_values"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "splitIndex":
            suggest = "split_index"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseLogMappingField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseLogMappingField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseLogMappingField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 alternate_values: Optional[Sequence[str]] = None,
                 case_insensitive: Optional[bool] = None,
                 default_value: Optional[str] = None,
                 field_joins: Optional[Sequence[str]] = None,
                 format: Optional[str] = None,
                 format_parameters: Optional[Sequence[str]] = None,
                 join_delimiter: Optional[str] = None,
                 lookups: Optional[Sequence['outputs.CseLogMappingFieldLookup']] = None,
                 skipped_values: Optional[Sequence[str]] = None,
                 split_delimiter: Optional[str] = None,
                 split_index: Optional[int] = None,
                 time_zone: Optional[str] = None,
                 value: Optional[str] = None,
                 value_type: Optional[str] = None):
        """
        :param str name: Name of the field.
        :param Sequence[str] alternate_values: List of alternate values.
        :param bool case_insensitive: Case insensitive flag.
        :param str default_value: Default value of the field.
        :param Sequence[str] field_joins: List of field join values.
        :param str format: Format of the field. (JSON, Windows, Syslog, CEF, LEEF )
        :param Sequence[str] format_parameters: List of format parameters.
        :param str join_delimiter: Join delimiter.
        :param Sequence['CseLogMappingFieldLookupArgs'] lookups: List of lookup key value pair for field. See lookup_schema for details.
        :param Sequence[str] skipped_values: List of skipped values.
        :param str split_delimiter: Split delimiter to be used. (some example: ",", "-", "|")
        :param int split_index: The index value to select (starting at zero)
        :param str time_zone: Time zone.
        :param str value: Lookup value.
        :param str value_type: The value type.
        """
        pulumi.set(__self__, "name", name)
        if alternate_values is not None:
            pulumi.set(__self__, "alternate_values", alternate_values)
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if field_joins is not None:
            pulumi.set(__self__, "field_joins", field_joins)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_parameters is not None:
            pulumi.set(__self__, "format_parameters", format_parameters)
        if join_delimiter is not None:
            pulumi.set(__self__, "join_delimiter", join_delimiter)
        if lookups is not None:
            pulumi.set(__self__, "lookups", lookups)
        if skipped_values is not None:
            pulumi.set(__self__, "skipped_values", skipped_values)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if split_index is not None:
            pulumi.set(__self__, "split_index", split_index)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def name(self) -> str:
        """
        Name of the field.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="alternateValues")
    def alternate_values(self) -> Optional[Sequence[str]]:
        """
        List of alternate values.
        """
        return pulumi.get(self, "alternate_values")

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[bool]:
        """
        Case insensitive flag.
        """
        return pulumi.get(self, "case_insensitive")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        """
        Default value of the field.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="fieldJoins")
    def field_joins(self) -> Optional[Sequence[str]]:
        """
        List of field join values.
        """
        return pulumi.get(self, "field_joins")

    @property
    @pulumi.getter
    def format(self) -> Optional[str]:
        """
        Format of the field. (JSON, Windows, Syslog, CEF, LEEF )
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="formatParameters")
    def format_parameters(self) -> Optional[Sequence[str]]:
        """
        List of format parameters.
        """
        return pulumi.get(self, "format_parameters")

    @property
    @pulumi.getter(name="joinDelimiter")
    def join_delimiter(self) -> Optional[str]:
        """
        Join delimiter.
        """
        return pulumi.get(self, "join_delimiter")

    @property
    @pulumi.getter
    def lookups(self) -> Optional[Sequence['outputs.CseLogMappingFieldLookup']]:
        """
        List of lookup key value pair for field. See lookup_schema for details.
        """
        return pulumi.get(self, "lookups")

    @property
    @pulumi.getter(name="skippedValues")
    def skipped_values(self) -> Optional[Sequence[str]]:
        """
        List of skipped values.
        """
        return pulumi.get(self, "skipped_values")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[str]:
        """
        Split delimiter to be used. (some example: ",", "-", "|")
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter(name="splitIndex")
    def split_index(self) -> Optional[int]:
        """
        The index value to select (starting at zero)
        """
        return pulumi.get(self, "split_index")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        """
        Time zone.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Lookup value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[str]:
        """
        The value type.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class CseLogMappingFieldLookup(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Lookup key.
        :param str value: Lookup value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Lookup key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Lookup value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CseLogMappingStructuredInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventIdPattern":
            suggest = "event_id_pattern"
        elif key == "logFormat":
            suggest = "log_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseLogMappingStructuredInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseLogMappingStructuredInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseLogMappingStructuredInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_id_pattern: str,
                 log_format: str,
                 product: str,
                 vendor: str):
        """
        :param str event_id_pattern: Event id pattern.
        :param str log_format: Log format. (JSON, Windows, Syslog, CEF, LEEF )
        :param str product: Product name.
        :param str vendor: Vendor name.
        """
        pulumi.set(__self__, "event_id_pattern", event_id_pattern)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="eventIdPattern")
    def event_id_pattern(self) -> str:
        """
        Event id pattern.
        """
        return pulumi.get(self, "event_id_pattern")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> str:
        """
        Log format. (JSON, Windows, Syslog, CEF, LEEF )
        """
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter
    def product(self) -> str:
        """
        Product name.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def vendor(self) -> str:
        """
        Vendor name.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class CseLogMappingUnstructuredFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternNames":
            suggest = "pattern_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseLogMappingUnstructuredFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseLogMappingUnstructuredFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseLogMappingUnstructuredFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pattern_names: Sequence[str]):
        """
        :param Sequence[str] pattern_names: List of grok pattern names.
        """
        pulumi.set(__self__, "pattern_names", pattern_names)

    @property
    @pulumi.getter(name="patternNames")
    def pattern_names(self) -> Sequence[str]:
        """
        List of grok pattern names.
        """
        return pulumi.get(self, "pattern_names")


@pulumi.output_type
class CseMatchListItem(dict):
    def __init__(__self__, *,
                 description: str,
                 value: str,
                 expiration: Optional[str] = None,
                 id: Optional[str] = None):
        """
        :param str description: Match list item description.
        :param str value: Match list item value.
        :param str expiration: Match list item expiration. (Format: YYYY-MM-DDTHH:mm:ss)
        :param str id: The internal ID of the match list.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def description(self) -> str:
        """
        Match list item description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Match list item value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def expiration(self) -> Optional[str]:
        """
        Match list item expiration. (Format: YYYY-MM-DDTHH:mm:ss)
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        """
        The internal ID of the match list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CseMatchRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseMatchRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseMatchRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseMatchRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 expression: str):
        """
        :param str expression: The expression for which records to match on
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression for which records to match on
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class CseMatchRuleSeverityMapping(dict):
    def __init__(__self__, *,
                 type: str,
                 default: Optional[int] = None,
                 field: Optional[str] = None,
                 mappings: Optional[Sequence['outputs.CseMatchRuleSeverityMappingMapping']] = None):
        """
        :param str type: Must be set to "eq" currently
        :param int default: The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        :param str field: The field to use in the "fieldValue"/"fieldValueMapping" cases.
        :param Sequence['CseMatchRuleSeverityMappingMappingArgs'] mappings: The map of record values to severities to use in the "fieldValueMapping" case
        """
        pulumi.set(__self__, "type", type)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Must be set to "eq" currently
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def default(self) -> Optional[int]:
        """
        The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        """
        The field to use in the "fieldValue"/"fieldValueMapping" cases.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.CseMatchRuleSeverityMappingMapping']]:
        """
        The map of record values to severities to use in the "fieldValueMapping" case
        """
        return pulumi.get(self, "mappings")


@pulumi.output_type
class CseMatchRuleSeverityMappingMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseMatchRuleSeverityMappingMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseMatchRuleSeverityMappingMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseMatchRuleSeverityMappingMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: str,
                 to: int,
                 type: str):
        """
        :param str from_: The record value to map from
        :param int to: The severity value to map to
        :param str type: Must be set to "eq" currently
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> str:
        """
        The record value to map from
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> int:
        """
        The severity value to map to
        """
        return pulumi.get(self, "to")

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Must be set to "eq" currently
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CseThresholdRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseThresholdRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseThresholdRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseThresholdRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 expression: str):
        """
        :param str expression: The expression for which records to match on
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> str:
        """
        The expression for which records to match on
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class DashboardColoringRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multipleSeriesAggregateFunction":
            suggest = "multiple_series_aggregate_function"
        elif key == "singleSeriesAggregateFunction":
            suggest = "single_series_aggregate_function"
        elif key == "colorThresholds":
            suggest = "color_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColoringRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColoringRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColoringRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multiple_series_aggregate_function: str,
                 scope: str,
                 single_series_aggregate_function: str,
                 color_thresholds: Optional[Sequence['outputs.DashboardColoringRuleColorThreshold']] = None):
        pulumi.set(__self__, "multiple_series_aggregate_function", multiple_series_aggregate_function)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "single_series_aggregate_function", single_series_aggregate_function)
        if color_thresholds is not None:
            pulumi.set(__self__, "color_thresholds", color_thresholds)

    @property
    @pulumi.getter(name="multipleSeriesAggregateFunction")
    def multiple_series_aggregate_function(self) -> str:
        return pulumi.get(self, "multiple_series_aggregate_function")

    @property
    @pulumi.getter
    def scope(self) -> str:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="singleSeriesAggregateFunction")
    def single_series_aggregate_function(self) -> str:
        return pulumi.get(self, "single_series_aggregate_function")

    @property
    @pulumi.getter(name="colorThresholds")
    def color_thresholds(self) -> Optional[Sequence['outputs.DashboardColoringRuleColorThreshold']]:
        return pulumi.get(self, "color_thresholds")


@pulumi.output_type
class DashboardColoringRuleColorThreshold(dict):
    def __init__(__self__, *,
                 color: str,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        pulumi.set(__self__, "color", color)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class DashboardLayout(dict):
    def __init__(__self__, *,
                 grid: Optional['outputs.DashboardLayoutGrid'] = None):
        if grid is not None:
            pulumi.set(__self__, "grid", grid)

    @property
    @pulumi.getter
    def grid(self) -> Optional['outputs.DashboardLayoutGrid']:
        return pulumi.get(self, "grid")


@pulumi.output_type
class DashboardLayoutGrid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layoutStructures":
            suggest = "layout_structures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLayoutGrid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLayoutGrid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLayoutGrid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout_structures: Sequence['outputs.DashboardLayoutGridLayoutStructure']):
        pulumi.set(__self__, "layout_structures", layout_structures)

    @property
    @pulumi.getter(name="layoutStructures")
    def layout_structures(self) -> Sequence['outputs.DashboardLayoutGridLayoutStructure']:
        return pulumi.get(self, "layout_structures")


@pulumi.output_type
class DashboardLayoutGridLayoutStructure(dict):
    def __init__(__self__, *,
                 key: str,
                 structure: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def structure(self) -> str:
        return pulumi.get(self, "structure")


@pulumi.output_type
class DashboardPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sumoSearchPanel":
            suggest = "sumo_search_panel"
        elif key == "textPanel":
            suggest = "text_panel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sumo_search_panel: Optional['outputs.DashboardPanelSumoSearchPanel'] = None,
                 text_panel: Optional['outputs.DashboardPanelTextPanel'] = None):
        if sumo_search_panel is not None:
            pulumi.set(__self__, "sumo_search_panel", sumo_search_panel)
        if text_panel is not None:
            pulumi.set(__self__, "text_panel", text_panel)

    @property
    @pulumi.getter(name="sumoSearchPanel")
    def sumo_search_panel(self) -> Optional['outputs.DashboardPanelSumoSearchPanel']:
        return pulumi.get(self, "sumo_search_panel")

    @property
    @pulumi.getter(name="textPanel")
    def text_panel(self) -> Optional['outputs.DashboardPanelTextPanel']:
        return pulumi.get(self, "text_panel")


@pulumi.output_type
class DashboardPanelSumoSearchPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coloringRule":
            suggest = "coloring_rule"
        elif key == "keepVisualSettingsConsistentWithParent":
            suggest = "keep_visual_settings_consistent_with_parent"
        elif key == "linkedDashboard":
            suggest = "linked_dashboard"
        elif key == "timeRange":
            suggest = "time_range"
        elif key == "visualSettings":
            suggest = "visual_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 coloring_rule: Optional['outputs.DashboardPanelSumoSearchPanelColoringRule'] = None,
                 description: Optional[str] = None,
                 id: Optional[str] = None,
                 keep_visual_settings_consistent_with_parent: Optional[bool] = None,
                 linked_dashboard: Optional['outputs.DashboardPanelSumoSearchPanelLinkedDashboard'] = None,
                 queries: Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQuery']] = None,
                 time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRange'] = None,
                 title: Optional[str] = None,
                 visual_settings: Optional[str] = None):
        """
        :param str description: Description of the dashboard.
        :param 'DashboardPanelSumoSearchPanelTimeRangeArgs' time_range: Time range of the dashboard. See time range schema
               for details.
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if coloring_rule is not None:
            pulumi.set(__self__, "coloring_rule", coloring_rule)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if linked_dashboard is not None:
            pulumi.set(__self__, "linked_dashboard", linked_dashboard)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="coloringRule")
    def coloring_rule(self) -> Optional['outputs.DashboardPanelSumoSearchPanelColoringRule']:
        return pulumi.get(self, "coloring_rule")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        Description of the dashboard.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[bool]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @property
    @pulumi.getter(name="linkedDashboard")
    def linked_dashboard(self) -> Optional['outputs.DashboardPanelSumoSearchPanelLinkedDashboard']:
        return pulumi.get(self, "linked_dashboard")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRange']:
        """
        Time range of the dashboard. See time range schema
        for details.
        """
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[str]:
        return pulumi.get(self, "visual_settings")


@pulumi.output_type
class DashboardPanelSumoSearchPanelColoringRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multipleSeriesAggregateFunction":
            suggest = "multiple_series_aggregate_function"
        elif key == "singleSeriesAggregateFunction":
            suggest = "single_series_aggregate_function"
        elif key == "colorThresholds":
            suggest = "color_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelColoringRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelColoringRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelColoringRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multiple_series_aggregate_function: str,
                 scope: str,
                 single_series_aggregate_function: str,
                 color_thresholds: Optional[Sequence['outputs.DashboardPanelSumoSearchPanelColoringRuleColorThreshold']] = None):
        pulumi.set(__self__, "multiple_series_aggregate_function", multiple_series_aggregate_function)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "single_series_aggregate_function", single_series_aggregate_function)
        if color_thresholds is not None:
            pulumi.set(__self__, "color_thresholds", color_thresholds)

    @property
    @pulumi.getter(name="multipleSeriesAggregateFunction")
    def multiple_series_aggregate_function(self) -> str:
        return pulumi.get(self, "multiple_series_aggregate_function")

    @property
    @pulumi.getter
    def scope(self) -> str:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="singleSeriesAggregateFunction")
    def single_series_aggregate_function(self) -> str:
        return pulumi.get(self, "single_series_aggregate_function")

    @property
    @pulumi.getter(name="colorThresholds")
    def color_thresholds(self) -> Optional[Sequence['outputs.DashboardPanelSumoSearchPanelColoringRuleColorThreshold']]:
        return pulumi.get(self, "color_thresholds")


@pulumi.output_type
class DashboardPanelSumoSearchPanelColoringRuleColorThreshold(dict):
    def __init__(__self__, *,
                 color: str,
                 max: Optional[float] = None,
                 min: Optional[float] = None):
        pulumi.set(__self__, "color", color)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def color(self) -> str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def max(self) -> Optional[float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class DashboardPanelSumoSearchPanelLinkedDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeTimeRange":
            suggest = "include_time_range"
        elif key == "includeVariables":
            suggest = "include_variables"
        elif key == "relativePath":
            suggest = "relative_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelLinkedDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelLinkedDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelLinkedDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: str,
                 include_time_range: Optional[bool] = None,
                 include_variables: Optional[bool] = None,
                 relative_path: Optional[str] = None):
        pulumi.set(__self__, "id", id)
        if include_time_range is not None:
            pulumi.set(__self__, "include_time_range", include_time_range)
        if include_variables is not None:
            pulumi.set(__self__, "include_variables", include_variables)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)

    @property
    @pulumi.getter
    def id(self) -> str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includeTimeRange")
    def include_time_range(self) -> Optional[bool]:
        return pulumi.get(self, "include_time_range")

    @property
    @pulumi.getter(name="includeVariables")
    def include_variables(self) -> Optional[bool]:
        return pulumi.get(self, "include_variables")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[str]:
        return pulumi.get(self, "relative_path")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryKey":
            suggest = "query_key"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "queryType":
            suggest = "query_type"
        elif key == "metricsQueryData":
            suggest = "metrics_query_data"
        elif key == "metricsQueryMode":
            suggest = "metrics_query_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_key: str,
                 query_string: str,
                 query_type: str,
                 metrics_query_data: Optional['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryData'] = None,
                 metrics_query_mode: Optional[str] = None):
        pulumi.set(__self__, "query_key", query_key)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "query_type", query_type)
        if metrics_query_data is not None:
            pulumi.set(__self__, "metrics_query_data", metrics_query_data)
        if metrics_query_mode is not None:
            pulumi.set(__self__, "metrics_query_mode", metrics_query_mode)

    @property
    @pulumi.getter(name="queryKey")
    def query_key(self) -> str:
        return pulumi.get(self, "query_key")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> str:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> str:
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter(name="metricsQueryData")
    def metrics_query_data(self) -> Optional['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryData']:
        return pulumi.get(self, "metrics_query_data")

    @property
    @pulumi.getter(name="metricsQueryMode")
    def metrics_query_mode(self) -> Optional[str]:
        return pulumi.get(self, "metrics_query_mode")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelQueryMetricsQueryData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter'],
                 metric: str,
                 aggregation_type: Optional[str] = None,
                 group_by: Optional[str] = None,
                 operators: Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator']] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "metric", metric)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if group_by is not None:
            pulumi.set(__self__, "group_by", group_by)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def metric(self) -> str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[str]:
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[str]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def operators(self) -> Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator']]:
        return pulumi.get(self, "operators")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 negation: Optional[bool] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if negation is not None:
            pulumi.set(__self__, "negation", negation)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negation(self) -> Optional[bool]:
        return pulumi.get(self, "negation")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorName":
            suggest = "operator_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_name: str,
                 parameters: Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter']):
        pulumi.set(__self__, "operator_name", operator_name)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="operatorName")
    def operator_name(self) -> str:
        return pulumi.get(self, "operator_name")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter']:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange'] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange']:
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange']:
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo'] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom':
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo']:
        return pulumi.get(self, "to")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelTextPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepVisualSettingsConsistentWithParent":
            suggest = "keep_visual_settings_consistent_with_parent"
        elif key == "visualSettings":
            suggest = "visual_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTextPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTextPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTextPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: str,
                 id: Optional[str] = None,
                 keep_visual_settings_consistent_with_parent: Optional[bool] = None,
                 text: Optional[str] = None,
                 title: Optional[str] = None,
                 visual_settings: Optional[str] = None):
        """
        :param str title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[bool]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @property
    @pulumi.getter
    def text(self) -> Optional[str]:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def title(self) -> Optional[str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[str]:
        return pulumi.get(self, "visual_settings")


@pulumi.output_type
class DashboardTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.DashboardTimeRangeCompleteLiteralTimeRange'] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRange']:
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.DashboardTimeRangeCompleteLiteralTimeRange']:
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.DashboardTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeTo'] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.DashboardTimeRangeBeginBoundedTimeRangeFrom':
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeTo']:
        return pulumi.get(self, "to")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTopologyLabelMap(dict):
    def __init__(__self__, *,
                 datas: Sequence['outputs.DashboardTopologyLabelMapData']):
        pulumi.set(__self__, "datas", datas)

    @property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.DashboardTopologyLabelMapData']:
        return pulumi.get(self, "datas")


@pulumi.output_type
class DashboardTopologyLabelMapData(dict):
    def __init__(__self__, *,
                 label: str,
                 values: Sequence[str]):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def label(self) -> str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceDefinition":
            suggest = "source_definition"
        elif key == "allowMultiSelect":
            suggest = "allow_multi_select"
        elif key == "defaultValue":
            suggest = "default_value"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "hideFromUi":
            suggest = "hide_from_ui"
        elif key == "includeAllOption":
            suggest = "include_all_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: str,
                 source_definition: 'outputs.DashboardVariableSourceDefinition',
                 allow_multi_select: Optional[bool] = None,
                 default_value: Optional[str] = None,
                 display_name: Optional[str] = None,
                 hide_from_ui: Optional[bool] = None,
                 id: Optional[str] = None,
                 include_all_option: Optional[bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_definition", source_definition)
        if allow_multi_select is not None:
            pulumi.set(__self__, "allow_multi_select", allow_multi_select)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if hide_from_ui is not None:
            pulumi.set(__self__, "hide_from_ui", hide_from_ui)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if include_all_option is not None:
            pulumi.set(__self__, "include_all_option", include_all_option)

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceDefinition")
    def source_definition(self) -> 'outputs.DashboardVariableSourceDefinition':
        return pulumi.get(self, "source_definition")

    @property
    @pulumi.getter(name="allowMultiSelect")
    def allow_multi_select(self) -> Optional[bool]:
        return pulumi.get(self, "allow_multi_select")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[str]:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="hideFromUi")
    def hide_from_ui(self) -> Optional[bool]:
        return pulumi.get(self, "hide_from_ui")

    @property
    @pulumi.getter
    def id(self) -> Optional[str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includeAllOption")
    def include_all_option(self) -> Optional[bool]:
        return pulumi.get(self, "include_all_option")


@pulumi.output_type
class DashboardVariableSourceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvVariableSourceDefinition":
            suggest = "csv_variable_source_definition"
        elif key == "logQueryVariableSourceDefinition":
            suggest = "log_query_variable_source_definition"
        elif key == "metadataVariableSourceDefinition":
            suggest = "metadata_variable_source_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVariableSourceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVariableSourceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVariableSourceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 csv_variable_source_definition: Optional['outputs.DashboardVariableSourceDefinitionCsvVariableSourceDefinition'] = None,
                 log_query_variable_source_definition: Optional['outputs.DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition'] = None,
                 metadata_variable_source_definition: Optional['outputs.DashboardVariableSourceDefinitionMetadataVariableSourceDefinition'] = None):
        if csv_variable_source_definition is not None:
            pulumi.set(__self__, "csv_variable_source_definition", csv_variable_source_definition)
        if log_query_variable_source_definition is not None:
            pulumi.set(__self__, "log_query_variable_source_definition", log_query_variable_source_definition)
        if metadata_variable_source_definition is not None:
            pulumi.set(__self__, "metadata_variable_source_definition", metadata_variable_source_definition)

    @property
    @pulumi.getter(name="csvVariableSourceDefinition")
    def csv_variable_source_definition(self) -> Optional['outputs.DashboardVariableSourceDefinitionCsvVariableSourceDefinition']:
        return pulumi.get(self, "csv_variable_source_definition")

    @property
    @pulumi.getter(name="logQueryVariableSourceDefinition")
    def log_query_variable_source_definition(self) -> Optional['outputs.DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition']:
        return pulumi.get(self, "log_query_variable_source_definition")

    @property
    @pulumi.getter(name="metadataVariableSourceDefinition")
    def metadata_variable_source_definition(self) -> Optional['outputs.DashboardVariableSourceDefinitionMetadataVariableSourceDefinition']:
        return pulumi.get(self, "metadata_variable_source_definition")


@pulumi.output_type
class DashboardVariableSourceDefinitionCsvVariableSourceDefinition(dict):
    def __init__(__self__, *,
                 values: str):
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> str:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition(dict):
    def __init__(__self__, *,
                 field: str,
                 query: str):
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def field(self) -> str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardVariableSourceDefinitionMetadataVariableSourceDefinition(dict):
    def __init__(__self__, *,
                 filter: str,
                 key: str):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def filter(self) -> str:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def key(self) -> str:
        return pulumi.get(self, "key")


@pulumi.output_type
class ElbSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 auth_provider_x509_cert_url: Optional[str] = None,
                 auth_uri: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_x509_cert_url: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 token_uri: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param str region: Your AWS Bucket region.
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class ElbSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class ElbSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class ElbSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 custom_services: Optional[Sequence['outputs.ElbSourcePathCustomService']] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 limit_to_services: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.ElbSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.ElbSourcePathTagFilter']] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        :param str bucket_name: The name of the bucket.
        :param str path_expression: The path to the data.
        :param Sequence['ElbSourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.ElbSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.ElbSourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.ElbSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class ElbSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class ElbSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_success: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class ElbSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GcpMetricsSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 auth_provider_x509_cert_url: Optional[str] = None,
                 auth_uri: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_x509_cert_url: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 token_uri: Optional[str] = None):
        """
        :param str type: Type of polling source. This has to be `GcpMetricsPath`.
        :param str auth_provider_x509_cert_url: As per the service_account.json downloaded from GCP
        :param str auth_uri: As per the service_account.json downloaded from GCP
        :param str client_email: As per the service_account.json downloaded from GCP
        :param str client_id: As per the service_account.json downloaded from GCP
        :param str client_x509_cert_url: As per the service_account.json downloaded from GCP
        :param str private_key: As per the service_account.json downloaded from GCP
        :param str private_key_id: As per the service_account.json downloaded from GCP
        :param str project_id: As per the service_account.json downloaded from GCP
        :param str token_uri: As per the service_account.json downloaded from GCP
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of polling source. This has to be `GcpMetricsPath`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class GcpMetricsSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class GcpMetricsSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class GcpMetricsSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 custom_services: Optional[Sequence['outputs.GcpMetricsSourcePathCustomService']] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 limit_to_services: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.GcpMetricsSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.GcpMetricsSourcePathTagFilter']] = None):
        """
        :param str type: Type of polling source. This has to be `GcpMetricsPath`.
        :param Sequence['GcpMetricsSourcePathCustomServiceArgs'] custom_services: Sumoloigc provides list of services that can be used in limit_to_services for which metrics would be collected. Custom Services allow you to define your own service w.r.t. metric collection. You can provide list of metric prefixes that should be collected as part of the custom service. This provides fine-grain control w.r.t. what all metrics are ingested by sumologic.
        :param Sequence[str] limit_to_regions: List of regions for which metrics would be collected (Empty to collect from all regions)
        :param Sequence[str] limit_to_services: List of services from which metrics would be collected
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Type of polling source. This has to be `GcpMetricsPath`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.GcpMetricsSourcePathCustomService']]:
        """
        Sumoloigc provides list of services that can be used in limit_to_services for which metrics would be collected. Custom Services allow you to define your own service w.r.t. metric collection. You can provide list of metric prefixes that should be collected as part of the custom service. This provides fine-grain control w.r.t. what all metrics are ingested by sumologic.
        """
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        """
        List of regions for which metrics would be collected (Empty to collect from all regions)
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[str]]:
        """
        List of services from which metrics would be collected
        """
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.GcpMetricsSourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.GcpMetricsSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class GcpMetricsSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        """
        :param Sequence[str] prefixes: List of metric type prefixes. Eg: `["compute.googleapis.com/instance/","compute.googleapis.com/guest/"]`
        :param str service_name: Name of the custom service you want to define.
        """
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        """
        List of metric type prefixes. Eg: `["compute.googleapis.com/instance/","compute.googleapis.com/guest/"]`
        """
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        """
        Name of the custom service you want to define.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GcpMetricsSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_success: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class GcpMetricsSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str type: Type of polling source. This has to be `GcpMetricsPath`.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of polling source. This has to be `GcpMetricsPath`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GcpSourceAuthentication(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GcpSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class GcpSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class GcpSourcePath(dict):
    def __init__(__self__, *,
                 type: Optional[str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class HierarchyFilter(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str):
        """
        :param str key: Filtering key.
        :param str value: Value required for the filtering key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filtering key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value required for the filtering key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HierarchyLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: str,
                 next_levels_with_conditions: Optional[Sequence[str]] = None):
        """
        :param str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HttpSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class HttpSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class KineisLogSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KineisLogSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KineisLogSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KineisLogSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        """
        :param str type: Must be either `KinesisLogPath` or `NoPathExpression`
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Must be either `KinesisLogPath` or `NoPathExpression`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class KineisLogSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class KineisLogSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KineisLogSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KineisLogSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KineisLogSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class KineisLogSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "scanInterval":
            suggest = "scan_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KineisLogSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KineisLogSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KineisLogSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 path_expression: Optional[str] = None,
                 scan_interval: Optional[int] = None):
        """
        :param str type: Must be either `KinesisLogPath` or `NoPathExpression`
        :param str bucket_name: The name of the bucket. This is needed if using type `KinesisLogPath`.
        :param str path_expression: The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must includes `http-endpoint-failed/`.
        :param int scan_interval: The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if scan_interval is not None:
            pulumi.set(__self__, "scan_interval", scan_interval)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        Must be either `KinesisLogPath` or `NoPathExpression`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The name of the bucket. This is needed if using type `KinesisLogPath`.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        """
        The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must includes `http-endpoint-failed/`.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="scanInterval")
    def scan_interval(self) -> Optional[int]:
        """
        The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        """
        return pulumi.get(self, "scan_interval")


@pulumi.output_type
class KinesisMetricsSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisMetricsSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisMetricsSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisMetricsSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        """
        :param str type: This value has to be set to `TagFilters`
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class KinesisMetricsSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class KinesisMetricsSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisMetricsSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisMetricsSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisMetricsSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class KinesisMetricsSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisMetricsSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisMetricsSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisMetricsSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 tag_filters: Optional[Sequence['outputs.KinesisMetricsSourcePathTagFilter']] = None):
        """
        :param str type: This value has to be set to `TagFilters`
        :param Sequence['KinesisMetricsSourcePathTagFilterArgs'] tag_filters: Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        pulumi.set(__self__, "type", type)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.KinesisMetricsSourcePathTagFilter']]:
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class KinesisMetricsSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param Sequence[str] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        :param str type: This value has to be set to `TagFilters`
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LookupTableField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LookupTableField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LookupTableField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LookupTableField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: str,
                 field_type: str):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> str:
        return pulumi.get(self, "field_type")


@pulumi.output_type
class MetadataSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        """
        :param str type: type of polling source. Only allowed value is `AwsMetadataPath`.
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. Only allowed value is `AwsMetadataPath`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class MetadataSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class MetadataSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class MetadataSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 tag_filters: Optional[Sequence[str]] = None):
        """
        :param str type: type of polling source. Only allowed value is `AwsMetadataPath`.
        :param Sequence[str] limit_to_namespaces: List of namespaces. For `AwsMetadataPath` the only valid namespace is `AWS/EC2`.
        :param Sequence[str] limit_to_regions: List of Amazon regions.
        :param Sequence[str] tag_filters: Leave this field blank to collect all tags configured for the EC2 instance. To collect a subset of tags, follow the instructions in [Define EC2 tag filters][2]
        """
        pulumi.set(__self__, "type", type)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. Only allowed value is `AwsMetadataPath`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        """
        List of namespaces. For `AwsMetadataPath` the only valid namespace is `AWS/EC2`.
        """
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[str]]:
        """
        Leave this field blank to collect all tags configured for the EC2 instance. To collect a subset of tags, follow the instructions in [Define EC2 tag filters][2]
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class MonitorNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runForTriggerTypes":
            suggest = "run_for_trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification: 'outputs.MonitorNotificationNotification',
                 run_for_trigger_types: Sequence[str]):
        pulumi.set(__self__, "notification", notification)
        pulumi.set(__self__, "run_for_trigger_types", run_for_trigger_types)

    @property
    @pulumi.getter
    def notification(self) -> 'outputs.MonitorNotificationNotification':
        return pulumi.get(self, "notification")

    @property
    @pulumi.getter(name="runForTriggerTypes")
    def run_for_trigger_types(self) -> Sequence[str]:
        return pulumi.get(self, "run_for_trigger_types")


@pulumi.output_type
class MonitorNotificationNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "connectionType":
            suggest = "connection_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "payloadOverride":
            suggest = "payload_override"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorNotificationNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorNotificationNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorNotificationNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: Optional[str] = None,
                 connection_id: Optional[str] = None,
                 connection_type: Optional[str] = None,
                 message_body: Optional[str] = None,
                 payload_override: Optional[str] = None,
                 recipients: Optional[Sequence[str]] = None,
                 subject: Optional[str] = None,
                 time_zone: Optional[str] = None):
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if payload_override is not None:
            pulumi.set(__self__, "payload_override", payload_override)
        if recipients is not None:
            pulumi.set(__self__, "recipients", recipients)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="actionType")
    def action_type(self) -> Optional[str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[str]:
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[str]:
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[str]:
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="payloadOverride")
    def payload_override(self) -> Optional[str]:
        return pulumi.get(self, "payload_override")

    @property
    @pulumi.getter
    def recipients(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "recipients")

    @property
    @pulumi.getter
    def subject(self) -> Optional[str]:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[str]:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MonitorQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowId":
            suggest = "row_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: str,
                 row_id: str):
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)

    @property
    @pulumi.getter
    def query(self) -> str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> str:
        return pulumi.get(self, "row_id")


@pulumi.output_type
class MonitorTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "detectionMethod":
            suggest = "detection_method"
        elif key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "thresholdType":
            suggest = "threshold_type"
        elif key == "timeRange":
            suggest = "time_range"
        elif key == "triggerSource":
            suggest = "trigger_source"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 detection_method: Optional[str] = None,
                 occurrence_type: Optional[str] = None,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None,
                 time_range: Optional[str] = None,
                 trigger_source: Optional[str] = None,
                 trigger_type: Optional[str] = None):
        if detection_method is not None:
            pulumi.set(__self__, "detection_method", detection_method)
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)
        if trigger_source is not None:
            pulumi.set(__self__, "trigger_source", trigger_source)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @property
    @pulumi.getter(name="detectionMethod")
    def detection_method(self) -> Optional[str]:
        return pulumi.get(self, "detection_method")

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[str]:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[str]:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter(name="triggerSource")
    def trigger_source(self) -> Optional[str]:
        return pulumi.get(self, "trigger_source")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[str]:
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class MonitorTriggerConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logsMissingDataCondition":
            suggest = "logs_missing_data_condition"
        elif key == "logsOutlierCondition":
            suggest = "logs_outlier_condition"
        elif key == "logsStaticCondition":
            suggest = "logs_static_condition"
        elif key == "metricsMissingDataCondition":
            suggest = "metrics_missing_data_condition"
        elif key == "metricsOutlierCondition":
            suggest = "metrics_outlier_condition"
        elif key == "metricsStaticCondition":
            suggest = "metrics_static_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs_missing_data_condition: Optional['outputs.MonitorTriggerConditionsLogsMissingDataCondition'] = None,
                 logs_outlier_condition: Optional['outputs.MonitorTriggerConditionsLogsOutlierCondition'] = None,
                 logs_static_condition: Optional['outputs.MonitorTriggerConditionsLogsStaticCondition'] = None,
                 metrics_missing_data_condition: Optional['outputs.MonitorTriggerConditionsMetricsMissingDataCondition'] = None,
                 metrics_outlier_condition: Optional['outputs.MonitorTriggerConditionsMetricsOutlierCondition'] = None,
                 metrics_static_condition: Optional['outputs.MonitorTriggerConditionsMetricsStaticCondition'] = None):
        if logs_missing_data_condition is not None:
            pulumi.set(__self__, "logs_missing_data_condition", logs_missing_data_condition)
        if logs_outlier_condition is not None:
            pulumi.set(__self__, "logs_outlier_condition", logs_outlier_condition)
        if logs_static_condition is not None:
            pulumi.set(__self__, "logs_static_condition", logs_static_condition)
        if metrics_missing_data_condition is not None:
            pulumi.set(__self__, "metrics_missing_data_condition", metrics_missing_data_condition)
        if metrics_outlier_condition is not None:
            pulumi.set(__self__, "metrics_outlier_condition", metrics_outlier_condition)
        if metrics_static_condition is not None:
            pulumi.set(__self__, "metrics_static_condition", metrics_static_condition)

    @property
    @pulumi.getter(name="logsMissingDataCondition")
    def logs_missing_data_condition(self) -> Optional['outputs.MonitorTriggerConditionsLogsMissingDataCondition']:
        return pulumi.get(self, "logs_missing_data_condition")

    @property
    @pulumi.getter(name="logsOutlierCondition")
    def logs_outlier_condition(self) -> Optional['outputs.MonitorTriggerConditionsLogsOutlierCondition']:
        return pulumi.get(self, "logs_outlier_condition")

    @property
    @pulumi.getter(name="logsStaticCondition")
    def logs_static_condition(self) -> Optional['outputs.MonitorTriggerConditionsLogsStaticCondition']:
        return pulumi.get(self, "logs_static_condition")

    @property
    @pulumi.getter(name="metricsMissingDataCondition")
    def metrics_missing_data_condition(self) -> Optional['outputs.MonitorTriggerConditionsMetricsMissingDataCondition']:
        return pulumi.get(self, "metrics_missing_data_condition")

    @property
    @pulumi.getter(name="metricsOutlierCondition")
    def metrics_outlier_condition(self) -> Optional['outputs.MonitorTriggerConditionsMetricsOutlierCondition']:
        return pulumi.get(self, "metrics_outlier_condition")

    @property
    @pulumi.getter(name="metricsStaticCondition")
    def metrics_static_condition(self) -> Optional['outputs.MonitorTriggerConditionsMetricsStaticCondition']:
        return pulumi.get(self, "metrics_static_condition")


@pulumi.output_type
class MonitorTriggerConditionsLogsMissingDataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsMissingDataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsMissingDataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsMissingDataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_range: str):
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> str:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsLogsOutlierCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsLogsOutlierConditionCritical'] = None,
                 direction: Optional[str] = None,
                 field: Optional[str] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsLogsOutlierConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsLogsOutlierConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsLogsOutlierConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsLogsOutlierConditionCritical(dict):
    def __init__(__self__, *,
                 consecutive: Optional[int] = None,
                 threshold: Optional[float] = None,
                 window: Optional[int] = None):
        if consecutive is not None:
            pulumi.set(__self__, "consecutive", consecutive)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def consecutive(self) -> Optional[int]:
        return pulumi.get(self, "consecutive")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def window(self) -> Optional[int]:
        return pulumi.get(self, "window")


@pulumi.output_type
class MonitorTriggerConditionsLogsOutlierConditionWarning(dict):
    def __init__(__self__, *,
                 consecutive: Optional[int] = None,
                 threshold: Optional[float] = None,
                 window: Optional[int] = None):
        if consecutive is not None:
            pulumi.set(__self__, "consecutive", consecutive)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def consecutive(self) -> Optional[int]:
        return pulumi.get(self, "consecutive")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def window(self) -> Optional[int]:
        return pulumi.get(self, "window")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsLogsStaticConditionCritical'] = None,
                 field: Optional[str] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsLogsStaticConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsLogsStaticConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def field(self) -> Optional[str]:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsLogsStaticConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert: 'outputs.MonitorTriggerConditionsLogsStaticConditionCriticalAlert',
                 resolution: 'outputs.MonitorTriggerConditionsLogsStaticConditionCriticalResolution',
                 time_range: str):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> 'outputs.MonitorTriggerConditionsLogsStaticConditionCriticalAlert':
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter
    def resolution(self) -> 'outputs.MonitorTriggerConditionsLogsStaticConditionCriticalResolution':
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> str:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionCriticalAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionCriticalAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCriticalAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCriticalAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionCriticalResolution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionCriticalResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCriticalResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCriticalResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert: 'outputs.MonitorTriggerConditionsLogsStaticConditionWarningAlert',
                 resolution: 'outputs.MonitorTriggerConditionsLogsStaticConditionWarningResolution',
                 time_range: str):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> 'outputs.MonitorTriggerConditionsLogsStaticConditionWarningAlert':
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter
    def resolution(self) -> 'outputs.MonitorTriggerConditionsLogsStaticConditionWarningResolution':
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> str:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionWarningAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionWarningAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarningAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarningAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionWarningResolution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionWarningResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarningResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarningResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsMetricsMissingDataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"
        elif key == "triggerSource":
            suggest = "trigger_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsMissingDataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsMissingDataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsMissingDataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_range: str,
                 trigger_source: str):
        pulumi.set(__self__, "time_range", time_range)
        pulumi.set(__self__, "trigger_source", trigger_source)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> str:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter(name="triggerSource")
    def trigger_source(self) -> str:
        return pulumi.get(self, "trigger_source")


@pulumi.output_type
class MonitorTriggerConditionsMetricsOutlierCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsMetricsOutlierConditionCritical'] = None,
                 direction: Optional[str] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsMetricsOutlierConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsMetricsOutlierConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsMetricsOutlierConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsMetricsOutlierConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineWindow":
            suggest = "baseline_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsOutlierConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsOutlierConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsOutlierConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_window: Optional[str] = None,
                 threshold: Optional[float] = None):
        if baseline_window is not None:
            pulumi.set(__self__, "baseline_window", baseline_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="baselineWindow")
    def baseline_window(self) -> Optional[str]:
        return pulumi.get(self, "baseline_window")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class MonitorTriggerConditionsMetricsOutlierConditionWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineWindow":
            suggest = "baseline_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsOutlierConditionWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsOutlierConditionWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsOutlierConditionWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_window: Optional[str] = None,
                 threshold: Optional[float] = None):
        if baseline_window is not None:
            pulumi.set(__self__, "baseline_window", baseline_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="baselineWindow")
    def baseline_window(self) -> Optional[str]:
        return pulumi.get(self, "baseline_window")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsMetricsStaticConditionCritical'] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsMetricsStaticConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsMetricsStaticConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsMetricsStaticConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert: 'outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalAlert',
                 occurrence_type: str,
                 resolution: 'outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalResolution',
                 time_range: str):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "occurrence_type", occurrence_type)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> 'outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalAlert':
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> str:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def resolution(self) -> 'outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalResolution':
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> str:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionCriticalAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionCriticalAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCriticalAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCriticalAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionCriticalResolution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionCriticalResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCriticalResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCriticalResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 occurrence_type: Optional[str] = None,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None):
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[str]:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert: 'outputs.MonitorTriggerConditionsMetricsStaticConditionWarningAlert',
                 occurrence_type: str,
                 resolution: 'outputs.MonitorTriggerConditionsMetricsStaticConditionWarningResolution',
                 time_range: str):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "occurrence_type", occurrence_type)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> 'outputs.MonitorTriggerConditionsMetricsStaticConditionWarningAlert':
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> str:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def resolution(self) -> 'outputs.MonitorTriggerConditionsMetricsStaticConditionWarningResolution':
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> str:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionWarningAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionWarningAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarningAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarningAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionWarningResolution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionWarningResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarningResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarningResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 occurrence_type: Optional[str] = None,
                 threshold: Optional[float] = None,
                 threshold_type: Optional[str] = None):
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[str]:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class PoliciesUserConcurrentSessionsLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentSessions":
            suggest = "max_concurrent_sessions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PoliciesUserConcurrentSessionsLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PoliciesUserConcurrentSessionsLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PoliciesUserConcurrentSessionsLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: bool,
                 max_concurrent_sessions: Optional[int] = None):
        """
        :param bool enabled: Whether the [User Concurrent Sessions Limit Policy](https://help.sumologic.com/Manage/Security/Set_a_Limit_for_User_Concurrent_Sessions) is enabled.
        :param int max_concurrent_sessions: Maximum number of concurrent sessions a user may have. Defaults to `100`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_concurrent_sessions is not None:
            pulumi.set(__self__, "max_concurrent_sessions", max_concurrent_sessions)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether the [User Concurrent Sessions Limit Policy](https://help.sumologic.com/Manage/Security/Set_a_Limit_for_User_Concurrent_Sessions) is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxConcurrentSessions")
    def max_concurrent_sessions(self) -> Optional[int]:
        """
        Maximum number of concurrent sessions a user may have. Defaults to `100`.
        """
        return pulumi.get(self, "max_concurrent_sessions")


@pulumi.output_type
class PollingSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PollingSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PollingSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PollingSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None):
        """
        :param str type: This value has to be set to `TagFilters`
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class PollingSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class PollingSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PollingSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PollingSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PollingSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class PollingSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PollingSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PollingSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PollingSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 tag_filters: Optional[Sequence['outputs.PollingSourcePathTagFilter']] = None):
        """
        :param str type: This value has to be set to `TagFilters`
        :param str bucket_name: The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        :param Sequence[str] limit_to_namespaces: List of namespaces to limit metrics collection. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace. This is a valid parameter if using type `CloudWatchPath`.
        :param Sequence[str] limit_to_regions: List of Amazon regions to limit metricscollection. This is a valid parameter if  using type `CloudWatchPath`.
        :param str path_expression: The path to the data. This is needed if using type `S3BucketPathExpression`.
        :param Sequence['PollingSourcePathTagFilterArgs'] tag_filters: Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. This is a valid parameter if using type `CloudWatchPath` More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        """
        List of namespaces to limit metrics collection. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace. This is a valid parameter if using type `CloudWatchPath`.
        """
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        """
        List of Amazon regions to limit metricscollection. This is a valid parameter if  using type `CloudWatchPath`.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        """
        The path to the data. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.PollingSourcePathTagFilter']]:
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. This is a valid parameter if using type `CloudWatchPath` More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class PollingSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param Sequence[str] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        :param str type: This value has to be set to `TagFilters`
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class S3AuditSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 auth_provider_x509_cert_url: Optional[str] = None,
                 auth_uri: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_x509_cert_url: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 token_uri: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param str region: Your AWS Bucket region.
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class S3AuditSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class S3AuditSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class S3AuditSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 custom_services: Optional[Sequence['outputs.S3AuditSourcePathCustomService']] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 limit_to_services: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.S3AuditSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.S3AuditSourcePathTagFilter']] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        :param str bucket_name: The name of the bucket.
        :param str path_expression: The path to the data.
        :param Sequence['S3AuditSourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.S3AuditSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.S3AuditSourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.S3AuditSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class S3AuditSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class S3AuditSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_success: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class S3AuditSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class S3SourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 access_key: Optional[str] = None,
                 auth_provider_x509_cert_url: Optional[str] = None,
                 auth_uri: Optional[str] = None,
                 client_email: Optional[str] = None,
                 client_id: Optional[str] = None,
                 client_x509_cert_url: Optional[str] = None,
                 private_key: Optional[str] = None,
                 private_key_id: Optional[str] = None,
                 project_id: Optional[str] = None,
                 region: Optional[str] = None,
                 role_arn: Optional[str] = None,
                 secret_key: Optional[str] = None,
                 token_uri: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        :param str access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param str region: Your AWS Bucket region.
        :param str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param str secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class S3SourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: str,
                 locator: Optional[str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class S3SourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: str,
                 name: str,
                 regexp: str,
                 mask: Optional[str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class S3SourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: str,
                 bucket_name: Optional[str] = None,
                 custom_services: Optional[Sequence['outputs.S3SourcePathCustomService']] = None,
                 limit_to_namespaces: Optional[Sequence[str]] = None,
                 limit_to_regions: Optional[Sequence[str]] = None,
                 limit_to_services: Optional[Sequence[str]] = None,
                 path_expression: Optional[str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.S3SourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.S3SourcePathTagFilter']] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        :param str bucket_name: The name of the bucket.
        :param str path_expression: The path to the data.
        :param Sequence['S3SourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[str]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.S3SourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[str]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.S3SourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.S3SourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class S3SourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[str]] = None,
                 service_name: Optional[str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class S3SourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[str] = None,
                 is_success: Optional[bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class S3SourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[str] = None,
                 tags: Optional[Sequence[str]] = None,
                 type: Optional[str] = None):
        """
        :param str type: type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class SamlConfigurationOnDemandProvisioningEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandProvisioningRoles":
            suggest = "on_demand_provisioning_roles"
        elif key == "firstNameAttribute":
            suggest = "first_name_attribute"
        elif key == "lastNameAttribute":
            suggest = "last_name_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SamlConfigurationOnDemandProvisioningEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SamlConfigurationOnDemandProvisioningEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SamlConfigurationOnDemandProvisioningEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_provisioning_roles: Sequence[str],
                 first_name_attribute: Optional[str] = None,
                 last_name_attribute: Optional[str] = None):
        """
        :param Sequence[str] on_demand_provisioning_roles: List of Sumo Logic RBAC roles to be assigned when user accounts are provisioned.
        :param str first_name_attribute: First name attribute of the new user account. Defaults to "".
        :param str last_name_attribute: Last name attribute of the new user account. Defaults to "".
        """
        pulumi.set(__self__, "on_demand_provisioning_roles", on_demand_provisioning_roles)
        if first_name_attribute is not None:
            pulumi.set(__self__, "first_name_attribute", first_name_attribute)
        if last_name_attribute is not None:
            pulumi.set(__self__, "last_name_attribute", last_name_attribute)

    @property
    @pulumi.getter(name="onDemandProvisioningRoles")
    def on_demand_provisioning_roles(self) -> Sequence[str]:
        """
        List of Sumo Logic RBAC roles to be assigned when user accounts are provisioned.
        """
        return pulumi.get(self, "on_demand_provisioning_roles")

    @property
    @pulumi.getter(name="firstNameAttribute")
    def first_name_attribute(self) -> Optional[str]:
        """
        First name attribute of the new user account. Defaults to "".
        """
        return pulumi.get(self, "first_name_attribute")

    @property
    @pulumi.getter(name="lastNameAttribute")
    def last_name_attribute(self) -> Optional[str]:
        """
        Last name attribute of the new user account. Defaults to "".
        """
        return pulumi.get(self, "last_name_attribute")


