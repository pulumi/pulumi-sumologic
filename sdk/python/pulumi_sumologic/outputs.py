# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs

__all__ = [
    'AwsInventorySourceAuthentication',
    'AwsInventorySourceDefaultDateFormat',
    'AwsInventorySourceFilter',
    'AwsInventorySourcePath',
    'AwsInventorySourcePathAzureTagFilter',
    'AwsInventorySourcePathAzureTagFilterTag',
    'AwsInventorySourcePathCustomService',
    'AwsInventorySourcePathSnsTopicOrSubscriptionArn',
    'AwsInventorySourcePathTagFilter',
    'AwsXraySourceAuthentication',
    'AwsXraySourceDefaultDateFormat',
    'AwsXraySourceFilter',
    'AwsXraySourcePath',
    'AwsXraySourcePathAzureTagFilter',
    'AwsXraySourcePathAzureTagFilterTag',
    'AwsXraySourcePathCustomService',
    'AwsXraySourcePathSnsTopicOrSubscriptionArn',
    'AwsXraySourcePathTagFilter',
    'AzureEventHubLogSourceAuthentication',
    'AzureEventHubLogSourceDefaultDateFormat',
    'AzureEventHubLogSourceFilter',
    'AzureEventHubLogSourcePath',
    'AzureEventHubLogSourcePathAzureTagFilter',
    'AzureEventHubLogSourcePathAzureTagFilterTag',
    'AzureEventHubLogSourcePathCustomService',
    'AzureEventHubLogSourcePathSnsTopicOrSubscriptionArn',
    'AzureEventHubLogSourcePathTagFilter',
    'AzureMetricsSourceAuthentication',
    'AzureMetricsSourceDefaultDateFormat',
    'AzureMetricsSourceFilter',
    'AzureMetricsSourcePath',
    'AzureMetricsSourcePathAzureTagFilter',
    'AzureMetricsSourcePathAzureTagFilterTag',
    'AzureMetricsSourcePathCustomService',
    'AzureMetricsSourcePathSnsTopicOrSubscriptionArn',
    'AzureMetricsSourcePathTagFilter',
    'CloudSyslogSourceDefaultDateFormat',
    'CloudSyslogSourceFilter',
    'CloudfrontSourceAuthentication',
    'CloudfrontSourceDefaultDateFormat',
    'CloudfrontSourceFilter',
    'CloudfrontSourcePath',
    'CloudfrontSourcePathAzureTagFilter',
    'CloudfrontSourcePathAzureTagFilterTag',
    'CloudfrontSourcePathCustomService',
    'CloudfrontSourcePathSnsTopicOrSubscriptionArn',
    'CloudfrontSourcePathTagFilter',
    'CloudtrailSourceAuthentication',
    'CloudtrailSourceDefaultDateFormat',
    'CloudtrailSourceFilter',
    'CloudtrailSourcePath',
    'CloudtrailSourcePathAzureTagFilter',
    'CloudtrailSourcePathAzureTagFilterTag',
    'CloudtrailSourcePathCustomService',
    'CloudtrailSourcePathSnsTopicOrSubscriptionArn',
    'CloudtrailSourcePathTagFilter',
    'CloudwatchSourceAuthentication',
    'CloudwatchSourceDefaultDateFormat',
    'CloudwatchSourceFilter',
    'CloudwatchSourcePath',
    'CloudwatchSourcePathAzureTagFilter',
    'CloudwatchSourcePathAzureTagFilterTag',
    'CloudwatchSourcePathCustomService',
    'CloudwatchSourcePathSnsTopicOrSubscriptionArn',
    'CloudwatchSourcePathTagFilter',
    'ContentPermissionPermission',
    'CseAggregationRuleAggregationFunction',
    'CseAggregationRuleEntitySelector',
    'CseAggregationRuleSeverityMapping',
    'CseAggregationRuleSeverityMappingMapping',
    'CseChainRuleEntitySelector',
    'CseChainRuleExpressionsAndLimit',
    'CseCustomInsightDynamicSeverity',
    'CseEntityNormalizationConfigurationDomainMapping',
    'CseFirstSeenRuleEntitySelector',
    'CseLogMappingField',
    'CseLogMappingFieldLookup',
    'CseLogMappingStructuredInput',
    'CseLogMappingUnstructuredFields',
    'CseMatchListItem',
    'CseMatchRuleEntitySelector',
    'CseMatchRuleSeverityMapping',
    'CseMatchRuleSeverityMappingMapping',
    'CseOutlierRuleAggregationFunctions',
    'CseOutlierRuleEntitySelector',
    'CseTagSchemaValueOption',
    'CseThresholdRuleEntitySelector',
    'DashboardColoringRule',
    'DashboardColoringRuleColorThreshold',
    'DashboardLayout',
    'DashboardLayoutGrid',
    'DashboardLayoutGridLayoutStructure',
    'DashboardPanel',
    'DashboardPanelServiceMapPanel',
    'DashboardPanelSumoSearchPanel',
    'DashboardPanelSumoSearchPanelColoringRule',
    'DashboardPanelSumoSearchPanelColoringRuleColorThreshold',
    'DashboardPanelSumoSearchPanelLinkedDashboard',
    'DashboardPanelSumoSearchPanelQuery',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryData',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator',
    'DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter',
    'DashboardPanelSumoSearchPanelTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange',
    'DashboardPanelTextPanel',
    'DashboardPanelTracesListPanel',
    'DashboardPanelTracesListPanelQuery',
    'DashboardPanelTracesListPanelQueryMetricsQueryData',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataFilter',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataOperator',
    'DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameter',
    'DashboardPanelTracesListPanelTimeRange',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRange',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFrom',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeTo',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRange',
    'DashboardTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFrom',
    'DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeTo',
    'DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'DashboardTimeRangeCompleteLiteralTimeRange',
    'DashboardTopologyLabelMap',
    'DashboardTopologyLabelMapData',
    'DashboardVariable',
    'DashboardVariableSourceDefinition',
    'DashboardVariableSourceDefinitionCsvVariableSourceDefinition',
    'DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition',
    'DashboardVariableSourceDefinitionMetadataVariableSourceDefinition',
    'DataForwardingDestinationAuthentication',
    'ElbSourceAuthentication',
    'ElbSourceDefaultDateFormat',
    'ElbSourceFilter',
    'ElbSourcePath',
    'ElbSourcePathAzureTagFilter',
    'ElbSourcePathAzureTagFilterTag',
    'ElbSourcePathCustomService',
    'ElbSourcePathSnsTopicOrSubscriptionArn',
    'ElbSourcePathTagFilter',
    'GcpMetricsSourceAuthentication',
    'GcpMetricsSourceDefaultDateFormat',
    'GcpMetricsSourceFilter',
    'GcpMetricsSourcePath',
    'GcpMetricsSourcePathAzureTagFilter',
    'GcpMetricsSourcePathAzureTagFilterTag',
    'GcpMetricsSourcePathCustomService',
    'GcpMetricsSourcePathSnsTopicOrSubscriptionArn',
    'GcpMetricsSourcePathTagFilter',
    'GcpSourceAuthentication',
    'GcpSourceDefaultDateFormat',
    'GcpSourceFilter',
    'GcpSourcePath',
    'HierarchyFilter',
    'HierarchyLevel',
    'HierarchyLevelNextLevel',
    'HierarchyLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition',
    'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel',
    'HttpSourceDefaultDateFormat',
    'HttpSourceFilter',
    'KinesisLogSourceAuthentication',
    'KinesisLogSourceDefaultDateFormat',
    'KinesisLogSourceFilter',
    'KinesisLogSourcePath',
    'KinesisMetricsSourceAuthentication',
    'KinesisMetricsSourceDefaultDateFormat',
    'KinesisMetricsSourceFilter',
    'KinesisMetricsSourcePath',
    'KinesisMetricsSourcePathTagFilter',
    'LocalFileSourceDefaultDateFormat',
    'LocalFileSourceFilter',
    'LogSearchQueryParameter',
    'LogSearchSchedule',
    'LogSearchScheduleNotification',
    'LogSearchScheduleNotificationAlertSearchNotification',
    'LogSearchScheduleNotificationCseSignalNotification',
    'LogSearchScheduleNotificationEmailSearchNotification',
    'LogSearchScheduleNotificationSaveToLookupNotification',
    'LogSearchScheduleNotificationSaveToViewNotification',
    'LogSearchScheduleNotificationServiceNowSearchNotification',
    'LogSearchScheduleNotificationServiceNowSearchNotificationFields',
    'LogSearchScheduleNotificationWebhookSearchNotification',
    'LogSearchScheduleParameter',
    'LogSearchScheduleParseableTimeRange',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRange',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFrom',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeTo',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRange',
    'LogSearchScheduleThreshold',
    'LogSearchTimeRange',
    'LogSearchTimeRangeBeginBoundedTimeRange',
    'LogSearchTimeRangeBeginBoundedTimeRangeFrom',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'LogSearchTimeRangeBeginBoundedTimeRangeTo',
    'LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'LogSearchTimeRangeCompleteLiteralTimeRange',
    'LookupTableField',
    'MetadataSourceAuthentication',
    'MetadataSourceDefaultDateFormat',
    'MetadataSourceFilter',
    'MetadataSourcePath',
    'MetricsSearchMetricsQuery',
    'MetricsSearchTimeRange',
    'MetricsSearchTimeRangeBeginBoundedTimeRange',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFrom',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeTo',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'MetricsSearchTimeRangeCompleteLiteralTimeRange',
    'MetricsSearchV2Query',
    'MetricsSearchV2TimeRange',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRange',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFrom',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromEpochTimeRange',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromIso8601TimeRange',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromLiteralTimeRange',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromRelativeTimeRange',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeTo',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeToEpochTimeRange',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeToIso8601TimeRange',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeToLiteralTimeRange',
    'MetricsSearchV2TimeRangeBeginBoundedTimeRangeToRelativeTimeRange',
    'MetricsSearchV2TimeRangeCompleteLiteralTimeRange',
    'MonitorFolderObjPermission',
    'MonitorNotification',
    'MonitorNotificationNotification',
    'MonitorObjPermission',
    'MonitorQuery',
    'MonitorTrigger',
    'MonitorTriggerConditions',
    'MonitorTriggerConditionsLogsAnomalyCondition',
    'MonitorTriggerConditionsLogsAnomalyConditionCritical',
    'MonitorTriggerConditionsLogsMissingDataCondition',
    'MonitorTriggerConditionsLogsOutlierCondition',
    'MonitorTriggerConditionsLogsOutlierConditionCritical',
    'MonitorTriggerConditionsLogsOutlierConditionWarning',
    'MonitorTriggerConditionsLogsStaticCondition',
    'MonitorTriggerConditionsLogsStaticConditionCritical',
    'MonitorTriggerConditionsLogsStaticConditionCriticalAlert',
    'MonitorTriggerConditionsLogsStaticConditionCriticalResolution',
    'MonitorTriggerConditionsLogsStaticConditionWarning',
    'MonitorTriggerConditionsLogsStaticConditionWarningAlert',
    'MonitorTriggerConditionsLogsStaticConditionWarningResolution',
    'MonitorTriggerConditionsMetricsAnomalyCondition',
    'MonitorTriggerConditionsMetricsAnomalyConditionCritical',
    'MonitorTriggerConditionsMetricsMissingDataCondition',
    'MonitorTriggerConditionsMetricsOutlierCondition',
    'MonitorTriggerConditionsMetricsOutlierConditionCritical',
    'MonitorTriggerConditionsMetricsOutlierConditionWarning',
    'MonitorTriggerConditionsMetricsStaticCondition',
    'MonitorTriggerConditionsMetricsStaticConditionCritical',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalAlert',
    'MonitorTriggerConditionsMetricsStaticConditionCriticalResolution',
    'MonitorTriggerConditionsMetricsStaticConditionWarning',
    'MonitorTriggerConditionsMetricsStaticConditionWarningAlert',
    'MonitorTriggerConditionsMetricsStaticConditionWarningResolution',
    'MonitorTriggerConditionsSloBurnRateCondition',
    'MonitorTriggerConditionsSloBurnRateConditionCritical',
    'MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRate',
    'MonitorTriggerConditionsSloBurnRateConditionWarning',
    'MonitorTriggerConditionsSloBurnRateConditionWarningBurnRate',
    'MonitorTriggerConditionsSloSliCondition',
    'MonitorTriggerConditionsSloSliConditionCritical',
    'MonitorTriggerConditionsSloSliConditionWarning',
    'MutingScheduleMonitor',
    'MutingScheduleNotificationGroup',
    'MutingScheduleSchedule',
    'PoliciesUserConcurrentSessionsLimit',
    'PollingSourceAuthentication',
    'PollingSourceDefaultDateFormat',
    'PollingSourceFilter',
    'PollingSourcePath',
    'PollingSourcePathTagFilter',
    'RoleV2SelectedView',
    'RumSourceDefaultDateFormat',
    'RumSourceFilter',
    'RumSourcePath',
    'S3ArchiveSourceAuthentication',
    'S3ArchiveSourceDefaultDateFormat',
    'S3ArchiveSourceFilter',
    'S3ArchiveSourcePath',
    'S3ArchiveSourcePathAzureTagFilter',
    'S3ArchiveSourcePathAzureTagFilterTag',
    'S3ArchiveSourcePathCustomService',
    'S3ArchiveSourcePathSnsTopicOrSubscriptionArn',
    'S3ArchiveSourcePathTagFilter',
    'S3AuditSourceAuthentication',
    'S3AuditSourceDefaultDateFormat',
    'S3AuditSourceFilter',
    'S3AuditSourcePath',
    'S3AuditSourcePathAzureTagFilter',
    'S3AuditSourcePathAzureTagFilterTag',
    'S3AuditSourcePathCustomService',
    'S3AuditSourcePathSnsTopicOrSubscriptionArn',
    'S3AuditSourcePathTagFilter',
    'S3SourceAuthentication',
    'S3SourceDefaultDateFormat',
    'S3SourceFilter',
    'S3SourcePath',
    'S3SourcePathAzureTagFilter',
    'S3SourcePathAzureTagFilterTag',
    'S3SourcePathCustomService',
    'S3SourcePathSnsTopicOrSubscriptionArn',
    'S3SourcePathTagFilter',
    'SamlConfigurationOnDemandProvisioningEnabled',
    'ScanBudgetScope',
    'SloCompliance',
    'SloIndicator',
    'SloIndicatorMonitorBasedEvaluation',
    'SloIndicatorMonitorBasedEvaluationMonitorTriggers',
    'SloIndicatorRequestBasedEvaluation',
    'SloIndicatorRequestBasedEvaluationQuery',
    'SloIndicatorRequestBasedEvaluationQueryQueryGroup',
    'SloIndicatorWindowBasedEvaluation',
    'SloIndicatorWindowBasedEvaluationQuery',
    'SloIndicatorWindowBasedEvaluationQueryQueryGroup',
    'SourceTemplateSchemaRef',
    'SourceTemplateSelector',
    'SourceTemplateSelectorTag',
    'GetAppsAppResult',
    'GetAppsAppAttributesResult',
    'GetRoleV2SelectedViewResult',
]

@pulumi.output_type
class AwsInventorySourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be `AWSRoleBasedAuthentication`
        :param builtins.str role_arn: Your AWS role ARN. More details [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Grant-Access-to-an-AWS-Product#iam-role).
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN. More details [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Grant-Access-to-an-AWS-Product#iam-role).
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class AwsInventorySourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class AwsInventorySourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class AwsInventorySourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.AwsInventorySourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.AwsInventorySourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.AwsInventorySourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.AwsInventorySourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        :param Sequence[builtins.str] limit_to_namespaces: List of namespaces. By default all namespaces are selected. You can also choose a subset from
               + AWS/EC2
               + AWS/AutoScaling
               + AWS/EBS
               + AWS/ELB
               + AWS/ApplicationELB
               + AWS/NetworkELB
               + AWS/Lambda
               + AWS/RDS
               + AWS/Dynamodb
               + AWS/ECS
               + AWS/Elasticache
               + AWS/Redshift
               + AWS/Kinesis
        :param Sequence[builtins.str] limit_to_regions: List of Amazon regions.
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. This has to be `AwsInventoryPath` for AWS Inventory source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.AwsInventorySourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.AwsInventorySourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        """
        List of namespaces. By default all namespaces are selected. You can also choose a subset from
        + AWS/EC2
        + AWS/AutoScaling
        + AWS/EBS
        + AWS/ELB
        + AWS/ApplicationELB
        + AWS/NetworkELB
        + AWS/Lambda
        + AWS/RDS
        + AWS/Dynamodb
        + AWS/ECS
        + AWS/Elasticache
        + AWS/Redshift
        + AWS/Kinesis
        """
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.AwsInventorySourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AwsInventorySourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class AwsInventorySourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.AwsInventorySourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.AwsInventorySourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsInventorySourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AwsInventorySourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AwsInventorySourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsInventorySourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsInventorySourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsInventorySourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class AwsInventorySourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class AwsXraySourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class AwsXraySourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class AwsXraySourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class AwsXraySourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.AwsXraySourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.AwsXraySourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.AwsXraySourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.AwsXraySourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        :param Sequence[builtins.str] limit_to_regions: List of Amazon regions.
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. This has to be `AwsXRayPath` for AWS XRay source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.AwsXraySourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.AwsXraySourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.AwsXraySourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AwsXraySourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class AwsXraySourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.AwsXraySourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.AwsXraySourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class AwsXraySourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AwsXraySourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AwsXraySourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AwsXraySourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AwsXraySourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AwsXraySourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class AwsXraySourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class AzureEventHubLogSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureEventHubLogSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureEventHubLogSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureEventHubLogSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be `AzureEventHubAuthentication`.
        :param builtins.str region: The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        :param builtins.str shared_access_policy_key: Your shared access policy key.
        :param builtins.str shared_access_policy_name: Your shared access policy name.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be `AzureEventHubAuthentication`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        """
        Your shared access policy key.
        """
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        """
        Your shared access policy name.
        """
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class AzureEventHubLogSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class AzureEventHubLogSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureEventHubLogSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureEventHubLogSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureEventHubLogSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class AzureEventHubLogSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureEventHubLogSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureEventHubLogSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureEventHubLogSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.AzureEventHubLogSourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.AzureEventHubLogSourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.AzureEventHubLogSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.AzureEventHubLogSourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: Must be `AzureEventHubPath`.
        :param builtins.str consumer_group: The consumer group of the event hub.
        :param builtins.str event_hub_name: The name of the event hub.
        :param builtins.str namespace: The namespace of the event hub.
        :param builtins.str region: The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be `AzureEventHubPath`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.AzureEventHubLogSourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        """
        The consumer group of the event hub.
        """
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.AzureEventHubLogSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        """
        The name of the event hub.
        """
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        The namespace of the event hub.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        The region of the event hub. The value can be either `Commercial` for Azure, or `US Gov` for Azure Government. Defaults to `Commercial`.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.AzureEventHubLogSourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AzureEventHubLogSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class AzureEventHubLogSourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.AzureEventHubLogSourcePathAzureTagFilterTag']] = None):
        """
        :param builtins.str namespace: The namespace of the event hub.
        """
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        The namespace of the event hub.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.AzureEventHubLogSourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class AzureEventHubLogSourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AzureEventHubLogSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureEventHubLogSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureEventHubLogSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureEventHubLogSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AzureEventHubLogSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureEventHubLogSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureEventHubLogSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureEventHubLogSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class AzureEventHubLogSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str namespace: The namespace of the event hub.
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        The namespace of the event hub.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class AzureMetricsSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMetricsSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMetricsSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMetricsSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class AzureMetricsSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class AzureMetricsSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMetricsSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMetricsSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMetricsSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class AzureMetricsSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMetricsSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMetricsSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMetricsSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.AzureMetricsSourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.AzureMetricsSourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.AzureMetricsSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.AzureMetricsSourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.AzureMetricsSourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.AzureMetricsSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.AzureMetricsSourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.AzureMetricsSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class AzureMetricsSourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.AzureMetricsSourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.AzureMetricsSourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class AzureMetricsSourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class AzureMetricsSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMetricsSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMetricsSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMetricsSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class AzureMetricsSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AzureMetricsSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AzureMetricsSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AzureMetricsSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class AzureMetricsSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CloudSyslogSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudSyslogSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudSyslogSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudSyslogSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudSyslogSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudfrontSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param builtins.str region: Your AWS Bucket region.
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class CloudfrontSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudfrontSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudfrontSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.CloudfrontSourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.CloudfrontSourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.CloudfrontSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.CloudfrontSourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        :param builtins.str bucket_name: The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        :param builtins.str path_expression: The path to the data. This is needed if using type `S3BucketPathExpression`.
        :param builtins.str region: Your AWS Bucket region.
        :param Sequence['CloudfrontSourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudFront` source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.CloudfrontSourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        """
        The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.CloudfrontSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        """
        The path to the data. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.CloudfrontSourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.CloudfrontSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class CloudfrontSourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.CloudfrontSourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CloudfrontSourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class CloudfrontSourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CloudfrontSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class CloudfrontSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudfrontSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudfrontSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudfrontSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class CloudfrontSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CloudtrailSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param builtins.str region: Your AWS Bucket region.
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class CloudtrailSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudtrailSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudtrailSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.CloudtrailSourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.CloudtrailSourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.CloudtrailSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.CloudtrailSourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        :param builtins.str bucket_name: The name of the bucket.
        :param builtins.str path_expression: The path to the data.
        :param builtins.str region: Your AWS Bucket region.
        :param Sequence['CloudtrailSourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `CloudTrail` source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.CloudtrailSourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.CloudtrailSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.CloudtrailSourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.CloudtrailSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class CloudtrailSourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.CloudtrailSourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CloudtrailSourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class CloudtrailSourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CloudtrailSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class CloudtrailSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudtrailSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudtrailSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudtrailSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class CloudtrailSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class CloudwatchSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param builtins.str region: Your AWS Bucket region.
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class CloudwatchSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class CloudwatchSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class CloudwatchSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.CloudwatchSourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.CloudwatchSourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.CloudwatchSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.CloudwatchSourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: type of polling source. This has to be `CloudWatchPath` for CloudWatch source.
        :param Sequence[builtins.str] limit_to_namespaces: List of namespaces. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace.
        :param Sequence[builtins.str] limit_to_regions: List of Amazon regions.
        :param builtins.str namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param builtins.str region: Your AWS Bucket region.
        :param Sequence['CloudwatchSourcePathTagFilterArgs'] tag_filters: Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. This has to be `CloudWatchPath` for CloudWatch source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.CloudwatchSourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.CloudwatchSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        """
        List of namespaces. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace.
        """
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.CloudwatchSourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.CloudwatchSourcePathTagFilter']]:
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class CloudwatchSourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.CloudwatchSourcePathAzureTagFilterTag']] = None):
        """
        :param builtins.str namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param Sequence['CloudwatchSourcePathAzureTagFilterTagArgs'] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.CloudwatchSourcePathAzureTagFilterTag']]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class CloudwatchSourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class CloudwatchSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class CloudwatchSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CloudwatchSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CloudwatchSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CloudwatchSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class CloudwatchSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param Sequence[builtins.str] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        :param builtins.str type: This value has to be set to `TagFilters`
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ContentPermissionPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "permissionName":
            suggest = "permission_name"
        elif key == "sourceId":
            suggest = "source_id"
        elif key == "sourceType":
            suggest = "source_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ContentPermissionPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ContentPermissionPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ContentPermissionPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permission_name: builtins.str,
                 source_id: builtins.str,
                 source_type: builtins.str):
        """
        :param builtins.str permission_name: Content permission name. Valid values are `View`, `GrantView`,
               `Edit`, `GrantEdit`, `Manage`, and `GrantManage`. You can read more about permission levels
               [here](https://help.sumologic.com/Manage/Content_Sharing/Share-Content#available-permission-levels).
        :param builtins.str source_id: An identifier that belongs to the source type chosen above. For example,
               if the `sourceType` is set to `user`, `sourceId` should be identifier of the user you want to share
               content with (same goes for role and org source type).
        :param builtins.str source_type: Type of source for the permission. Valid values are `user`, `role`,
               and `org`.
        """
        pulumi.set(__self__, "permission_name", permission_name)
        pulumi.set(__self__, "source_id", source_id)
        pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="permissionName")
    def permission_name(self) -> builtins.str:
        """
        Content permission name. Valid values are `View`, `GrantView`,
        `Edit`, `GrantEdit`, `Manage`, and `GrantManage`. You can read more about permission levels
        [here](https://help.sumologic.com/Manage/Content_Sharing/Share-Content#available-permission-levels).
        """
        return pulumi.get(self, "permission_name")

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> builtins.str:
        """
        An identifier that belongs to the source type chosen above. For example,
        if the `sourceType` is set to `user`, `sourceId` should be identifier of the user you want to share
        content with (same goes for role and org source type).
        """
        return pulumi.get(self, "source_id")

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> builtins.str:
        """
        Type of source for the permission. Valid values are `user`, `role`,
        and `org`.
        """
        return pulumi.get(self, "source_type")


@pulumi.output_type
class CseAggregationRuleAggregationFunction(dict):
    def __init__(__self__, *,
                 arguments: Sequence[builtins.str],
                 function: builtins.str,
                 name: builtins.str):
        """
        :param Sequence[builtins.str] arguments: One or more expressions to pass as arguments to the function
        :param builtins.str function: The function to aggregate with
        :param builtins.str name: The name to use to reference the result in the trigger_expression
        """
        pulumi.set(__self__, "arguments", arguments)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arguments(self) -> Sequence[builtins.str]:
        """
        One or more expressions to pass as arguments to the function
        """
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter
    def function(self) -> builtins.str:
        """
        The function to aggregate with
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name to use to reference the result in the trigger_expression
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CseAggregationRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseAggregationRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseAggregationRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseAggregationRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 expression: builtins.str):
        """
        :param builtins.str expression: The expression or field name to generate the Signal on.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        The expression or field name to generate the Signal on.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class CseAggregationRuleSeverityMapping(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 default: Optional[builtins.int] = None,
                 field: Optional[builtins.str] = None,
                 mappings: Optional[Sequence['outputs.CseAggregationRuleSeverityMappingMapping']] = None):
        """
        :param builtins.str type: Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        :param builtins.int default: The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        :param builtins.str field: The field to use in the "fieldValue"/"fieldValueMapping" cases.
        :param Sequence['CseAggregationRuleSeverityMappingMappingArgs'] mappings: The map of record values to severities to use in the "fieldValueMapping" case
        """
        pulumi.set(__self__, "type", type)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def default(self) -> Optional[builtins.int]:
        """
        The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def field(self) -> Optional[builtins.str]:
        """
        The field to use in the "fieldValue"/"fieldValueMapping" cases.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.CseAggregationRuleSeverityMappingMapping']]:
        """
        The map of record values to severities to use in the "fieldValueMapping" case
        """
        return pulumi.get(self, "mappings")


@pulumi.output_type
class CseAggregationRuleSeverityMappingMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseAggregationRuleSeverityMappingMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseAggregationRuleSeverityMappingMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseAggregationRuleSeverityMappingMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: builtins.str,
                 to: builtins.int,
                 type: builtins.str):
        """
        :param builtins.str from_: The record value to map from
        :param builtins.int to: The severity value to map to
        :param builtins.str type: Must be set to "eq" currently
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> builtins.str:
        """
        The record value to map from
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> builtins.int:
        """
        The severity value to map to
        """
        return pulumi.get(self, "to")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be set to "eq" currently
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CseChainRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseChainRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseChainRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseChainRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 expression: builtins.str):
        """
        :param builtins.str expression: The expression or field name to generate the Signal on.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        The expression or field name to generate the Signal on.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class CseChainRuleExpressionsAndLimit(dict):
    def __init__(__self__, *,
                 expression: builtins.str,
                 limit: builtins.int):
        """
        :param builtins.str expression: The expression for which records to match on
        :param builtins.int limit: How many times this expression must match for the Signal to fire
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "limit", limit)

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        The expression for which records to match on
        """
        return pulumi.get(self, "expression")

    @property
    @pulumi.getter
    def limit(self) -> builtins.int:
        """
        How many times this expression must match for the Signal to fire
        """
        return pulumi.get(self, "limit")


@pulumi.output_type
class CseCustomInsightDynamicSeverity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "insightSeverity":
            suggest = "insight_severity"
        elif key == "minimumSignalSeverity":
            suggest = "minimum_signal_severity"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseCustomInsightDynamicSeverity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseCustomInsightDynamicSeverity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseCustomInsightDynamicSeverity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 insight_severity: builtins.str,
                 minimum_signal_severity: builtins.int):
        """
        :param builtins.str insight_severity: The severity of the generated Insight (CRITICAL, HIGH, MEDIUM, or LOW)
        :param builtins.int minimum_signal_severity: minimum Signal severity as the threshold for an Insight severity level
        """
        pulumi.set(__self__, "insight_severity", insight_severity)
        pulumi.set(__self__, "minimum_signal_severity", minimum_signal_severity)

    @property
    @pulumi.getter(name="insightSeverity")
    def insight_severity(self) -> builtins.str:
        """
        The severity of the generated Insight (CRITICAL, HIGH, MEDIUM, or LOW)
        """
        return pulumi.get(self, "insight_severity")

    @property
    @pulumi.getter(name="minimumSignalSeverity")
    def minimum_signal_severity(self) -> builtins.int:
        """
        minimum Signal severity as the threshold for an Insight severity level
        """
        return pulumi.get(self, "minimum_signal_severity")


@pulumi.output_type
class CseEntityNormalizationConfigurationDomainMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "normalizedDomain":
            suggest = "normalized_domain"
        elif key == "rawDomain":
            suggest = "raw_domain"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseEntityNormalizationConfigurationDomainMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseEntityNormalizationConfigurationDomainMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseEntityNormalizationConfigurationDomainMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 normalized_domain: builtins.str,
                 raw_domain: builtins.str):
        """
        :param builtins.str normalized_domain: The normalized domain.
        :param builtins.str raw_domain: The raw domain to be normalized.
        """
        pulumi.set(__self__, "normalized_domain", normalized_domain)
        pulumi.set(__self__, "raw_domain", raw_domain)

    @property
    @pulumi.getter(name="normalizedDomain")
    def normalized_domain(self) -> builtins.str:
        """
        The normalized domain.
        """
        return pulumi.get(self, "normalized_domain")

    @property
    @pulumi.getter(name="rawDomain")
    def raw_domain(self) -> builtins.str:
        """
        The raw domain to be normalized.
        """
        return pulumi.get(self, "raw_domain")


@pulumi.output_type
class CseFirstSeenRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseFirstSeenRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseFirstSeenRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseFirstSeenRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 expression: builtins.str):
        """
        :param builtins.str expression: The expression or field name to generate the Signal on
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        The expression or field name to generate the Signal on
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class CseLogMappingField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alternateValues":
            suggest = "alternate_values"
        elif key == "caseInsensitive":
            suggest = "case_insensitive"
        elif key == "defaultValue":
            suggest = "default_value"
        elif key == "fieldJoins":
            suggest = "field_joins"
        elif key == "formatParameters":
            suggest = "format_parameters"
        elif key == "joinDelimiter":
            suggest = "join_delimiter"
        elif key == "skippedValues":
            suggest = "skipped_values"
        elif key == "splitDelimiter":
            suggest = "split_delimiter"
        elif key == "splitIndex":
            suggest = "split_index"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "valueType":
            suggest = "value_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseLogMappingField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseLogMappingField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseLogMappingField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 alternate_values: Optional[Sequence[builtins.str]] = None,
                 case_insensitive: Optional[builtins.bool] = None,
                 default_value: Optional[builtins.str] = None,
                 field_joins: Optional[Sequence[builtins.str]] = None,
                 format: Optional[builtins.str] = None,
                 format_parameters: Optional[Sequence[builtins.str]] = None,
                 join_delimiter: Optional[builtins.str] = None,
                 lookups: Optional[Sequence['outputs.CseLogMappingFieldLookup']] = None,
                 skipped_values: Optional[Sequence[builtins.str]] = None,
                 split_delimiter: Optional[builtins.str] = None,
                 split_index: Optional[builtins.int] = None,
                 time_zone: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None,
                 value_type: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the log mapping.
        :param Sequence[builtins.str] alternate_values: List of alternate values.
        :param builtins.bool case_insensitive: Case insensitive flag.
        :param builtins.str default_value: Default value of the field.
        :param Sequence[builtins.str] field_joins: List of field join values.
        :param builtins.str format: Format of the field. (JSON, Windows, Syslog, CEF, LEEF )
        :param Sequence[builtins.str] format_parameters: List of format parameters.
        :param builtins.str join_delimiter: Join delimiter.
        :param Sequence['CseLogMappingFieldLookupArgs'] lookups: List of lookup key value pair for field. See lookup_schema for details.
        :param Sequence[builtins.str] skipped_values: List of skipped values.
        :param builtins.str split_delimiter: Split delimiter to be used. (some example: ",", "-", "|")
        :param builtins.int split_index: The index value to select (starting at zero)
        :param builtins.str time_zone: Time zone.
        :param builtins.str value: Lookup value.
        :param builtins.str value_type: The value type.
        """
        pulumi.set(__self__, "name", name)
        if alternate_values is not None:
            pulumi.set(__self__, "alternate_values", alternate_values)
        if case_insensitive is not None:
            pulumi.set(__self__, "case_insensitive", case_insensitive)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if field_joins is not None:
            pulumi.set(__self__, "field_joins", field_joins)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if format_parameters is not None:
            pulumi.set(__self__, "format_parameters", format_parameters)
        if join_delimiter is not None:
            pulumi.set(__self__, "join_delimiter", join_delimiter)
        if lookups is not None:
            pulumi.set(__self__, "lookups", lookups)
        if skipped_values is not None:
            pulumi.set(__self__, "skipped_values", skipped_values)
        if split_delimiter is not None:
            pulumi.set(__self__, "split_delimiter", split_delimiter)
        if split_index is not None:
            pulumi.set(__self__, "split_index", split_index)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)
        if value is not None:
            pulumi.set(__self__, "value", value)
        if value_type is not None:
            pulumi.set(__self__, "value_type", value_type)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the log mapping.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="alternateValues")
    def alternate_values(self) -> Optional[Sequence[builtins.str]]:
        """
        List of alternate values.
        """
        return pulumi.get(self, "alternate_values")

    @property
    @pulumi.getter(name="caseInsensitive")
    def case_insensitive(self) -> Optional[builtins.bool]:
        """
        Case insensitive flag.
        """
        return pulumi.get(self, "case_insensitive")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[builtins.str]:
        """
        Default value of the field.
        """
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="fieldJoins")
    def field_joins(self) -> Optional[Sequence[builtins.str]]:
        """
        List of field join values.
        """
        return pulumi.get(self, "field_joins")

    @property
    @pulumi.getter
    def format(self) -> Optional[builtins.str]:
        """
        Format of the field. (JSON, Windows, Syslog, CEF, LEEF )
        """
        return pulumi.get(self, "format")

    @property
    @pulumi.getter(name="formatParameters")
    def format_parameters(self) -> Optional[Sequence[builtins.str]]:
        """
        List of format parameters.
        """
        return pulumi.get(self, "format_parameters")

    @property
    @pulumi.getter(name="joinDelimiter")
    def join_delimiter(self) -> Optional[builtins.str]:
        """
        Join delimiter.
        """
        return pulumi.get(self, "join_delimiter")

    @property
    @pulumi.getter
    def lookups(self) -> Optional[Sequence['outputs.CseLogMappingFieldLookup']]:
        """
        List of lookup key value pair for field. See lookup_schema for details.
        """
        return pulumi.get(self, "lookups")

    @property
    @pulumi.getter(name="skippedValues")
    def skipped_values(self) -> Optional[Sequence[builtins.str]]:
        """
        List of skipped values.
        """
        return pulumi.get(self, "skipped_values")

    @property
    @pulumi.getter(name="splitDelimiter")
    def split_delimiter(self) -> Optional[builtins.str]:
        """
        Split delimiter to be used. (some example: ",", "-", "|")
        """
        return pulumi.get(self, "split_delimiter")

    @property
    @pulumi.getter(name="splitIndex")
    def split_index(self) -> Optional[builtins.int]:
        """
        The index value to select (starting at zero)
        """
        return pulumi.get(self, "split_index")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[builtins.str]:
        """
        Time zone.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Lookup value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter(name="valueType")
    def value_type(self) -> Optional[builtins.str]:
        """
        The value type.
        """
        return pulumi.get(self, "value_type")


@pulumi.output_type
class CseLogMappingFieldLookup(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str key: Lookup key.
        :param builtins.str value: Lookup value.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Lookup key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Lookup value.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class CseLogMappingStructuredInput(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventIdPattern":
            suggest = "event_id_pattern"
        elif key == "logFormat":
            suggest = "log_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseLogMappingStructuredInput. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseLogMappingStructuredInput.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseLogMappingStructuredInput.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_id_pattern: builtins.str,
                 log_format: builtins.str,
                 product: builtins.str,
                 vendor: builtins.str):
        """
        :param builtins.str event_id_pattern: Event id pattern.
        :param builtins.str log_format: Log format. (JSON, Windows, Syslog, CEF, LEEF )
        :param builtins.str product: Product name.
        :param builtins.str vendor: Vendor name.
        """
        pulumi.set(__self__, "event_id_pattern", event_id_pattern)
        pulumi.set(__self__, "log_format", log_format)
        pulumi.set(__self__, "product", product)
        pulumi.set(__self__, "vendor", vendor)

    @property
    @pulumi.getter(name="eventIdPattern")
    def event_id_pattern(self) -> builtins.str:
        """
        Event id pattern.
        """
        return pulumi.get(self, "event_id_pattern")

    @property
    @pulumi.getter(name="logFormat")
    def log_format(self) -> builtins.str:
        """
        Log format. (JSON, Windows, Syslog, CEF, LEEF )
        """
        return pulumi.get(self, "log_format")

    @property
    @pulumi.getter
    def product(self) -> builtins.str:
        """
        Product name.
        """
        return pulumi.get(self, "product")

    @property
    @pulumi.getter
    def vendor(self) -> builtins.str:
        """
        Vendor name.
        """
        return pulumi.get(self, "vendor")


@pulumi.output_type
class CseLogMappingUnstructuredFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "patternNames":
            suggest = "pattern_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseLogMappingUnstructuredFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseLogMappingUnstructuredFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseLogMappingUnstructuredFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pattern_names: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] pattern_names: List of grok pattern names.
               
               
               The following attributes are exported:
        """
        pulumi.set(__self__, "pattern_names", pattern_names)

    @property
    @pulumi.getter(name="patternNames")
    def pattern_names(self) -> Sequence[builtins.str]:
        """
        List of grok pattern names.


        The following attributes are exported:
        """
        return pulumi.get(self, "pattern_names")


@pulumi.output_type
class CseMatchListItem(dict):
    def __init__(__self__, *,
                 description: builtins.str,
                 value: builtins.str,
                 expiration: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None):
        """
        :param builtins.str description: Match list description.
        :param builtins.str value: Match list item value.
        :param builtins.str expiration: Match list item expiration. (Format: YYYY-MM-DDTHH:mm:ss)
               
               The following attributes are exported:
        :param builtins.str id: The internal ID of the match list.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "value", value)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        """
        Match list description.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Match list item value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def expiration(self) -> Optional[builtins.str]:
        """
        Match list item expiration. (Format: YYYY-MM-DDTHH:mm:ss)

        The following attributes are exported:
        """
        return pulumi.get(self, "expiration")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        """
        The internal ID of the match list.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class CseMatchRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseMatchRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseMatchRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseMatchRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 expression: builtins.str):
        """
        :param builtins.str expression: The expression or field name to generate the Signal on.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        The expression or field name to generate the Signal on.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class CseMatchRuleSeverityMapping(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 default: Optional[builtins.int] = None,
                 field: Optional[builtins.str] = None,
                 mappings: Optional[Sequence['outputs.CseMatchRuleSeverityMappingMapping']] = None):
        """
        :param builtins.str type: Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        :param builtins.int default: The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        :param builtins.str field: The field to use in the "fieldValue"/"fieldValueMapping" cases.
        :param Sequence['CseMatchRuleSeverityMappingMappingArgs'] mappings: The map of record values to severities to use in the "fieldValueMapping" case
        """
        pulumi.set(__self__, "type", type)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if mappings is not None:
            pulumi.set(__self__, "mappings", mappings)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Whether to set a constant severity ("constant"), set the severity based on the direct value of a record field ("fieldValue"), or map a record field value to a severity ("fieldValueMapping").
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def default(self) -> Optional[builtins.int]:
        """
        The severity to use in the "constant" case or to fall back to if the field used by "fieldValue"/"fieldValueMapping" is not populated.
        """
        return pulumi.get(self, "default")

    @property
    @pulumi.getter
    def field(self) -> Optional[builtins.str]:
        """
        The field to use in the "fieldValue"/"fieldValueMapping" cases.
        """
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def mappings(self) -> Optional[Sequence['outputs.CseMatchRuleSeverityMappingMapping']]:
        """
        The map of record values to severities to use in the "fieldValueMapping" case
        """
        return pulumi.get(self, "mappings")


@pulumi.output_type
class CseMatchRuleSeverityMappingMapping(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseMatchRuleSeverityMappingMapping. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseMatchRuleSeverityMappingMapping.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseMatchRuleSeverityMappingMapping.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: builtins.str,
                 to: builtins.int,
                 type: builtins.str):
        """
        :param builtins.str from_: The record value to map from
        :param builtins.int to: The severity value to map to
        :param builtins.str type: Must be set to "eq" currently
        """
        pulumi.set(__self__, "from_", from_)
        pulumi.set(__self__, "to", to)
        pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> builtins.str:
        """
        The record value to map from
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> builtins.int:
        """
        The severity value to map to
        """
        return pulumi.get(self, "to")

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be set to "eq" currently
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class CseOutlierRuleAggregationFunctions(dict):
    def __init__(__self__, *,
                 arguments: Sequence[builtins.str],
                 function: builtins.str,
                 name: builtins.str):
        """
        :param Sequence[builtins.str] arguments: One or more expressions to pass as arguments to the function
        :param builtins.str function: The function to aggregate with
        :param builtins.str name: The name of the Rule
        """
        pulumi.set(__self__, "arguments", arguments)
        pulumi.set(__self__, "function", function)
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def arguments(self) -> Sequence[builtins.str]:
        """
        One or more expressions to pass as arguments to the function
        """
        return pulumi.get(self, "arguments")

    @property
    @pulumi.getter
    def function(self) -> builtins.str:
        """
        The function to aggregate with
        """
        return pulumi.get(self, "function")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the Rule
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class CseOutlierRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseOutlierRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseOutlierRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseOutlierRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 expression: builtins.str):
        """
        :param builtins.str expression: The expression or field name to generate the Signal on
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        The expression or field name to generate the Signal on
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class CseTagSchemaValueOption(dict):
    def __init__(__self__, *,
                 value: builtins.str,
                 label: Optional[builtins.str] = None,
                 link: Optional[builtins.str] = None):
        """
        :param builtins.str value: Value option value.
        :param builtins.str label: Value option label.
        :param builtins.str link: Value option link.
               
               
               
               The following attributes are exported:
        """
        pulumi.set(__self__, "value", value)
        if label is not None:
            pulumi.set(__self__, "label", label)
        if link is not None:
            pulumi.set(__self__, "link", link)

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Value option value.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def label(self) -> Optional[builtins.str]:
        """
        Value option label.
        """
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def link(self) -> Optional[builtins.str]:
        """
        Value option link.



        The following attributes are exported:
        """
        return pulumi.get(self, "link")


@pulumi.output_type
class CseThresholdRuleEntitySelector(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CseThresholdRuleEntitySelector. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CseThresholdRuleEntitySelector.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CseThresholdRuleEntitySelector.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 expression: builtins.str):
        """
        :param builtins.str expression: The expression or field name to generate the Signal on.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "expression", expression)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter
    def expression(self) -> builtins.str:
        """
        The expression or field name to generate the Signal on.
        """
        return pulumi.get(self, "expression")


@pulumi.output_type
class DashboardColoringRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multipleSeriesAggregateFunction":
            suggest = "multiple_series_aggregate_function"
        elif key == "singleSeriesAggregateFunction":
            suggest = "single_series_aggregate_function"
        elif key == "colorThresholds":
            suggest = "color_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardColoringRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardColoringRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardColoringRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multiple_series_aggregate_function: builtins.str,
                 scope: builtins.str,
                 single_series_aggregate_function: builtins.str,
                 color_thresholds: Optional[Sequence['outputs.DashboardColoringRuleColorThreshold']] = None):
        pulumi.set(__self__, "multiple_series_aggregate_function", multiple_series_aggregate_function)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "single_series_aggregate_function", single_series_aggregate_function)
        if color_thresholds is not None:
            pulumi.set(__self__, "color_thresholds", color_thresholds)

    @property
    @pulumi.getter(name="multipleSeriesAggregateFunction")
    def multiple_series_aggregate_function(self) -> builtins.str:
        return pulumi.get(self, "multiple_series_aggregate_function")

    @property
    @pulumi.getter
    def scope(self) -> builtins.str:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="singleSeriesAggregateFunction")
    def single_series_aggregate_function(self) -> builtins.str:
        return pulumi.get(self, "single_series_aggregate_function")

    @property
    @pulumi.getter(name="colorThresholds")
    def color_thresholds(self) -> Optional[Sequence['outputs.DashboardColoringRuleColorThreshold']]:
        return pulumi.get(self, "color_thresholds")


@pulumi.output_type
class DashboardColoringRuleColorThreshold(dict):
    def __init__(__self__, *,
                 color: builtins.str,
                 max: Optional[builtins.float] = None,
                 min: Optional[builtins.float] = None):
        pulumi.set(__self__, "color", color)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def color(self) -> builtins.str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def max(self) -> Optional[builtins.float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class DashboardLayout(dict):
    def __init__(__self__, *,
                 grid: Optional['outputs.DashboardLayoutGrid'] = None):
        if grid is not None:
            pulumi.set(__self__, "grid", grid)

    @property
    @pulumi.getter
    def grid(self) -> Optional['outputs.DashboardLayoutGrid']:
        return pulumi.get(self, "grid")


@pulumi.output_type
class DashboardLayoutGrid(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layoutStructures":
            suggest = "layout_structures"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardLayoutGrid. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardLayoutGrid.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardLayoutGrid.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout_structures: Sequence['outputs.DashboardLayoutGridLayoutStructure']):
        pulumi.set(__self__, "layout_structures", layout_structures)

    @property
    @pulumi.getter(name="layoutStructures")
    def layout_structures(self) -> Sequence['outputs.DashboardLayoutGridLayoutStructure']:
        return pulumi.get(self, "layout_structures")


@pulumi.output_type
class DashboardLayoutGridLayoutStructure(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 structure: builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "structure", structure)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def structure(self) -> builtins.str:
        return pulumi.get(self, "structure")


@pulumi.output_type
class DashboardPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceMapPanel":
            suggest = "service_map_panel"
        elif key == "sumoSearchPanel":
            suggest = "sumo_search_panel"
        elif key == "textPanel":
            suggest = "text_panel"
        elif key == "tracesListPanel":
            suggest = "traces_list_panel"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_map_panel: Optional['outputs.DashboardPanelServiceMapPanel'] = None,
                 sumo_search_panel: Optional['outputs.DashboardPanelSumoSearchPanel'] = None,
                 text_panel: Optional['outputs.DashboardPanelTextPanel'] = None,
                 traces_list_panel: Optional['outputs.DashboardPanelTracesListPanel'] = None):
        if service_map_panel is not None:
            pulumi.set(__self__, "service_map_panel", service_map_panel)
        if sumo_search_panel is not None:
            pulumi.set(__self__, "sumo_search_panel", sumo_search_panel)
        if text_panel is not None:
            pulumi.set(__self__, "text_panel", text_panel)
        if traces_list_panel is not None:
            pulumi.set(__self__, "traces_list_panel", traces_list_panel)

    @property
    @pulumi.getter(name="serviceMapPanel")
    def service_map_panel(self) -> Optional['outputs.DashboardPanelServiceMapPanel']:
        return pulumi.get(self, "service_map_panel")

    @property
    @pulumi.getter(name="sumoSearchPanel")
    def sumo_search_panel(self) -> Optional['outputs.DashboardPanelSumoSearchPanel']:
        return pulumi.get(self, "sumo_search_panel")

    @property
    @pulumi.getter(name="textPanel")
    def text_panel(self) -> Optional['outputs.DashboardPanelTextPanel']:
        return pulumi.get(self, "text_panel")

    @property
    @pulumi.getter(name="tracesListPanel")
    def traces_list_panel(self) -> Optional['outputs.DashboardPanelTracesListPanel']:
        return pulumi.get(self, "traces_list_panel")


@pulumi.output_type
class DashboardPanelServiceMapPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepVisualSettingsConsistentWithParent":
            suggest = "keep_visual_settings_consistent_with_parent"
        elif key == "showRemoteServices":
            suggest = "show_remote_services"
        elif key == "visualSettings":
            suggest = "visual_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelServiceMapPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelServiceMapPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelServiceMapPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: builtins.str,
                 application: Optional[builtins.str] = None,
                 environment: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 keep_visual_settings_consistent_with_parent: Optional[builtins.bool] = None,
                 service: Optional[builtins.str] = None,
                 show_remote_services: Optional[builtins.bool] = None,
                 title: Optional[builtins.str] = None,
                 visual_settings: Optional[builtins.str] = None):
        """
        :param builtins.str title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if application is not None:
            pulumi.set(__self__, "application", application)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if service is not None:
            pulumi.set(__self__, "service", service)
        if show_remote_services is not None:
            pulumi.set(__self__, "show_remote_services", show_remote_services)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def application(self) -> Optional[builtins.str]:
        return pulumi.get(self, "application")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @property
    @pulumi.getter
    def service(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service")

    @property
    @pulumi.getter(name="showRemoteServices")
    def show_remote_services(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "show_remote_services")

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[builtins.str]:
        return pulumi.get(self, "visual_settings")


@pulumi.output_type
class DashboardPanelSumoSearchPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "coloringRule":
            suggest = "coloring_rule"
        elif key == "keepVisualSettingsConsistentWithParent":
            suggest = "keep_visual_settings_consistent_with_parent"
        elif key == "linkedDashboard":
            suggest = "linked_dashboard"
        elif key == "timeRange":
            suggest = "time_range"
        elif key == "visualSettings":
            suggest = "visual_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: builtins.str,
                 coloring_rule: Optional['outputs.DashboardPanelSumoSearchPanelColoringRule'] = None,
                 description: Optional[builtins.str] = None,
                 id: Optional[builtins.str] = None,
                 keep_visual_settings_consistent_with_parent: Optional[builtins.bool] = None,
                 linked_dashboard: Optional['outputs.DashboardPanelSumoSearchPanelLinkedDashboard'] = None,
                 queries: Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQuery']] = None,
                 time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRange'] = None,
                 title: Optional[builtins.str] = None,
                 visual_settings: Optional[builtins.str] = None):
        """
        :param builtins.str description: Description of the dashboard.
        :param 'DashboardPanelSumoSearchPanelTimeRangeArgs' time_range: Time range of the dashboard. See time range schema
               for details.
        :param builtins.str title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if coloring_rule is not None:
            pulumi.set(__self__, "coloring_rule", coloring_rule)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if linked_dashboard is not None:
            pulumi.set(__self__, "linked_dashboard", linked_dashboard)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter(name="coloringRule")
    def coloring_rule(self) -> Optional['outputs.DashboardPanelSumoSearchPanelColoringRule']:
        return pulumi.get(self, "coloring_rule")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the dashboard.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @property
    @pulumi.getter(name="linkedDashboard")
    def linked_dashboard(self) -> Optional['outputs.DashboardPanelSumoSearchPanelLinkedDashboard']:
        return pulumi.get(self, "linked_dashboard")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRange']:
        """
        Time range of the dashboard. See time range schema
        for details.
        """
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[builtins.str]:
        return pulumi.get(self, "visual_settings")


@pulumi.output_type
class DashboardPanelSumoSearchPanelColoringRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "multipleSeriesAggregateFunction":
            suggest = "multiple_series_aggregate_function"
        elif key == "singleSeriesAggregateFunction":
            suggest = "single_series_aggregate_function"
        elif key == "colorThresholds":
            suggest = "color_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelColoringRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelColoringRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelColoringRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 multiple_series_aggregate_function: builtins.str,
                 scope: builtins.str,
                 single_series_aggregate_function: builtins.str,
                 color_thresholds: Optional[Sequence['outputs.DashboardPanelSumoSearchPanelColoringRuleColorThreshold']] = None):
        pulumi.set(__self__, "multiple_series_aggregate_function", multiple_series_aggregate_function)
        pulumi.set(__self__, "scope", scope)
        pulumi.set(__self__, "single_series_aggregate_function", single_series_aggregate_function)
        if color_thresholds is not None:
            pulumi.set(__self__, "color_thresholds", color_thresholds)

    @property
    @pulumi.getter(name="multipleSeriesAggregateFunction")
    def multiple_series_aggregate_function(self) -> builtins.str:
        return pulumi.get(self, "multiple_series_aggregate_function")

    @property
    @pulumi.getter
    def scope(self) -> builtins.str:
        return pulumi.get(self, "scope")

    @property
    @pulumi.getter(name="singleSeriesAggregateFunction")
    def single_series_aggregate_function(self) -> builtins.str:
        return pulumi.get(self, "single_series_aggregate_function")

    @property
    @pulumi.getter(name="colorThresholds")
    def color_thresholds(self) -> Optional[Sequence['outputs.DashboardPanelSumoSearchPanelColoringRuleColorThreshold']]:
        return pulumi.get(self, "color_thresholds")


@pulumi.output_type
class DashboardPanelSumoSearchPanelColoringRuleColorThreshold(dict):
    def __init__(__self__, *,
                 color: builtins.str,
                 max: Optional[builtins.float] = None,
                 min: Optional[builtins.float] = None):
        pulumi.set(__self__, "color", color)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter
    def color(self) -> builtins.str:
        return pulumi.get(self, "color")

    @property
    @pulumi.getter
    def max(self) -> Optional[builtins.float]:
        return pulumi.get(self, "max")

    @property
    @pulumi.getter
    def min(self) -> Optional[builtins.float]:
        return pulumi.get(self, "min")


@pulumi.output_type
class DashboardPanelSumoSearchPanelLinkedDashboard(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "includeTimeRange":
            suggest = "include_time_range"
        elif key == "includeVariables":
            suggest = "include_variables"
        elif key == "relativePath":
            suggest = "relative_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelLinkedDashboard. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelLinkedDashboard.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelLinkedDashboard.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 id: builtins.str,
                 include_time_range: Optional[builtins.bool] = None,
                 include_variables: Optional[builtins.bool] = None,
                 relative_path: Optional[builtins.str] = None):
        pulumi.set(__self__, "id", id)
        if include_time_range is not None:
            pulumi.set(__self__, "include_time_range", include_time_range)
        if include_variables is not None:
            pulumi.set(__self__, "include_variables", include_variables)
        if relative_path is not None:
            pulumi.set(__self__, "relative_path", relative_path)

    @property
    @pulumi.getter
    def id(self) -> builtins.str:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includeTimeRange")
    def include_time_range(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "include_time_range")

    @property
    @pulumi.getter(name="includeVariables")
    def include_variables(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "include_variables")

    @property
    @pulumi.getter(name="relativePath")
    def relative_path(self) -> Optional[builtins.str]:
        return pulumi.get(self, "relative_path")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryKey":
            suggest = "query_key"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "queryType":
            suggest = "query_type"
        elif key == "metricsQueryData":
            suggest = "metrics_query_data"
        elif key == "metricsQueryMode":
            suggest = "metrics_query_mode"
        elif key == "outputCardinalityLimit":
            suggest = "output_cardinality_limit"
        elif key == "parseMode":
            suggest = "parse_mode"
        elif key == "timeSource":
            suggest = "time_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_key: builtins.str,
                 query_string: builtins.str,
                 query_type: builtins.str,
                 metrics_query_data: Optional['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryData'] = None,
                 metrics_query_mode: Optional[builtins.str] = None,
                 output_cardinality_limit: Optional[builtins.int] = None,
                 parse_mode: Optional[builtins.str] = None,
                 time_source: Optional[builtins.str] = None,
                 transient: Optional[builtins.bool] = None):
        pulumi.set(__self__, "query_key", query_key)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "query_type", query_type)
        if metrics_query_data is not None:
            pulumi.set(__self__, "metrics_query_data", metrics_query_data)
        if metrics_query_mode is not None:
            pulumi.set(__self__, "metrics_query_mode", metrics_query_mode)
        if output_cardinality_limit is not None:
            pulumi.set(__self__, "output_cardinality_limit", output_cardinality_limit)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if time_source is not None:
            pulumi.set(__self__, "time_source", time_source)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)

    @property
    @pulumi.getter(name="queryKey")
    def query_key(self) -> builtins.str:
        return pulumi.get(self, "query_key")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> builtins.str:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> builtins.str:
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter(name="metricsQueryData")
    def metrics_query_data(self) -> Optional['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryData']:
        return pulumi.get(self, "metrics_query_data")

    @property
    @pulumi.getter(name="metricsQueryMode")
    def metrics_query_mode(self) -> Optional[builtins.str]:
        return pulumi.get(self, "metrics_query_mode")

    @property
    @pulumi.getter(name="outputCardinalityLimit")
    def output_cardinality_limit(self) -> Optional[builtins.int]:
        return pulumi.get(self, "output_cardinality_limit")

    @property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[builtins.str]:
        return pulumi.get(self, "parse_mode")

    @property
    @pulumi.getter(name="timeSource")
    def time_source(self) -> Optional[builtins.str]:
        return pulumi.get(self, "time_source")

    @property
    @pulumi.getter
    def transient(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "transient")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelQueryMetricsQueryData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter'],
                 metric: builtins.str,
                 aggregation_type: Optional[builtins.str] = None,
                 group_by: Optional[builtins.str] = None,
                 operators: Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator']] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "metric", metric)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if group_by is not None:
            pulumi.set(__self__, "group_by", group_by)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[builtins.str]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def operators(self) -> Optional[Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator']]:
        return pulumi.get(self, "operators")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataFilter(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str,
                 negation: Optional[builtins.bool] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if negation is not None:
            pulumi.set(__self__, "negation", negation)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negation(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "negation")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorName":
            suggest = "operator_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_name: builtins.str,
                 parameters: Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter']):
        pulumi.set(__self__, "operator_name", operator_name)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="operatorName")
    def operator_name(self) -> builtins.str:
        return pulumi.get(self, "operator_name")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter']:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DashboardPanelSumoSearchPanelQueryMetricsQueryDataOperatorParameter(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange'] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange']:
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange']:
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo'] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom':
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo']:
        return pulumi.get(self, "to")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelSumoSearchPanelTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelTextPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepVisualSettingsConsistentWithParent":
            suggest = "keep_visual_settings_consistent_with_parent"
        elif key == "visualSettings":
            suggest = "visual_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTextPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTextPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTextPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: builtins.str,
                 id: Optional[builtins.str] = None,
                 keep_visual_settings_consistent_with_parent: Optional[builtins.bool] = None,
                 text: Optional[builtins.str] = None,
                 title: Optional[builtins.str] = None,
                 visual_settings: Optional[builtins.str] = None):
        """
        :param builtins.str title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @property
    @pulumi.getter
    def text(self) -> Optional[builtins.str]:
        return pulumi.get(self, "text")

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[builtins.str]:
        return pulumi.get(self, "visual_settings")


@pulumi.output_type
class DashboardPanelTracesListPanel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keepVisualSettingsConsistentWithParent":
            suggest = "keep_visual_settings_consistent_with_parent"
        elif key == "timeRange":
            suggest = "time_range"
        elif key == "visualSettings":
            suggest = "visual_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key: builtins.str,
                 id: Optional[builtins.str] = None,
                 keep_visual_settings_consistent_with_parent: Optional[builtins.bool] = None,
                 queries: Optional[Sequence['outputs.DashboardPanelTracesListPanelQuery']] = None,
                 time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRange'] = None,
                 title: Optional[builtins.str] = None,
                 visual_settings: Optional[builtins.str] = None):
        """
        :param 'DashboardPanelTracesListPanelTimeRangeArgs' time_range: Time range of the dashboard. See time range schema
               for details.
        :param builtins.str title: Title of the dashboard.
        """
        pulumi.set(__self__, "key", key)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if keep_visual_settings_consistent_with_parent is not None:
            pulumi.set(__self__, "keep_visual_settings_consistent_with_parent", keep_visual_settings_consistent_with_parent)
        if queries is not None:
            pulumi.set(__self__, "queries", queries)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if visual_settings is not None:
            pulumi.set(__self__, "visual_settings", visual_settings)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="keepVisualSettingsConsistentWithParent")
    def keep_visual_settings_consistent_with_parent(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "keep_visual_settings_consistent_with_parent")

    @property
    @pulumi.getter
    def queries(self) -> Optional[Sequence['outputs.DashboardPanelTracesListPanelQuery']]:
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRange']:
        """
        Time range of the dashboard. See time range schema
        for details.
        """
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter
    def title(self) -> Optional[builtins.str]:
        """
        Title of the dashboard.
        """
        return pulumi.get(self, "title")

    @property
    @pulumi.getter(name="visualSettings")
    def visual_settings(self) -> Optional[builtins.str]:
        return pulumi.get(self, "visual_settings")


@pulumi.output_type
class DashboardPanelTracesListPanelQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryKey":
            suggest = "query_key"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "queryType":
            suggest = "query_type"
        elif key == "metricsQueryData":
            suggest = "metrics_query_data"
        elif key == "metricsQueryMode":
            suggest = "metrics_query_mode"
        elif key == "outputCardinalityLimit":
            suggest = "output_cardinality_limit"
        elif key == "parseMode":
            suggest = "parse_mode"
        elif key == "timeSource":
            suggest = "time_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_key: builtins.str,
                 query_string: builtins.str,
                 query_type: builtins.str,
                 metrics_query_data: Optional['outputs.DashboardPanelTracesListPanelQueryMetricsQueryData'] = None,
                 metrics_query_mode: Optional[builtins.str] = None,
                 output_cardinality_limit: Optional[builtins.int] = None,
                 parse_mode: Optional[builtins.str] = None,
                 time_source: Optional[builtins.str] = None,
                 transient: Optional[builtins.bool] = None):
        pulumi.set(__self__, "query_key", query_key)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "query_type", query_type)
        if metrics_query_data is not None:
            pulumi.set(__self__, "metrics_query_data", metrics_query_data)
        if metrics_query_mode is not None:
            pulumi.set(__self__, "metrics_query_mode", metrics_query_mode)
        if output_cardinality_limit is not None:
            pulumi.set(__self__, "output_cardinality_limit", output_cardinality_limit)
        if parse_mode is not None:
            pulumi.set(__self__, "parse_mode", parse_mode)
        if time_source is not None:
            pulumi.set(__self__, "time_source", time_source)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)

    @property
    @pulumi.getter(name="queryKey")
    def query_key(self) -> builtins.str:
        return pulumi.get(self, "query_key")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> builtins.str:
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> builtins.str:
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter(name="metricsQueryData")
    def metrics_query_data(self) -> Optional['outputs.DashboardPanelTracesListPanelQueryMetricsQueryData']:
        return pulumi.get(self, "metrics_query_data")

    @property
    @pulumi.getter(name="metricsQueryMode")
    def metrics_query_mode(self) -> Optional[builtins.str]:
        return pulumi.get(self, "metrics_query_mode")

    @property
    @pulumi.getter(name="outputCardinalityLimit")
    def output_cardinality_limit(self) -> Optional[builtins.int]:
        return pulumi.get(self, "output_cardinality_limit")

    @property
    @pulumi.getter(name="parseMode")
    def parse_mode(self) -> Optional[builtins.str]:
        return pulumi.get(self, "parse_mode")

    @property
    @pulumi.getter(name="timeSource")
    def time_source(self) -> Optional[builtins.str]:
        return pulumi.get(self, "time_source")

    @property
    @pulumi.getter
    def transient(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "transient")


@pulumi.output_type
class DashboardPanelTracesListPanelQueryMetricsQueryData(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aggregationType":
            suggest = "aggregation_type"
        elif key == "groupBy":
            suggest = "group_by"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelQueryMetricsQueryData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelQueryMetricsQueryData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelQueryMetricsQueryData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filters: Sequence['outputs.DashboardPanelTracesListPanelQueryMetricsQueryDataFilter'],
                 metric: builtins.str,
                 aggregation_type: Optional[builtins.str] = None,
                 group_by: Optional[builtins.str] = None,
                 operators: Optional[Sequence['outputs.DashboardPanelTracesListPanelQueryMetricsQueryDataOperator']] = None):
        pulumi.set(__self__, "filters", filters)
        pulumi.set(__self__, "metric", metric)
        if aggregation_type is not None:
            pulumi.set(__self__, "aggregation_type", aggregation_type)
        if group_by is not None:
            pulumi.set(__self__, "group_by", group_by)
        if operators is not None:
            pulumi.set(__self__, "operators", operators)

    @property
    @pulumi.getter
    def filters(self) -> Sequence['outputs.DashboardPanelTracesListPanelQueryMetricsQueryDataFilter']:
        return pulumi.get(self, "filters")

    @property
    @pulumi.getter
    def metric(self) -> builtins.str:
        return pulumi.get(self, "metric")

    @property
    @pulumi.getter(name="aggregationType")
    def aggregation_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "aggregation_type")

    @property
    @pulumi.getter(name="groupBy")
    def group_by(self) -> Optional[builtins.str]:
        return pulumi.get(self, "group_by")

    @property
    @pulumi.getter
    def operators(self) -> Optional[Sequence['outputs.DashboardPanelTracesListPanelQueryMetricsQueryDataOperator']]:
        return pulumi.get(self, "operators")


@pulumi.output_type
class DashboardPanelTracesListPanelQueryMetricsQueryDataFilter(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str,
                 negation: Optional[builtins.bool] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if negation is not None:
            pulumi.set(__self__, "negation", negation)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def negation(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "negation")


@pulumi.output_type
class DashboardPanelTracesListPanelQueryMetricsQueryDataOperator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "operatorName":
            suggest = "operator_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelQueryMetricsQueryDataOperator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelQueryMetricsQueryDataOperator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelQueryMetricsQueryDataOperator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 operator_name: builtins.str,
                 parameters: Sequence['outputs.DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameter']):
        pulumi.set(__self__, "operator_name", operator_name)
        pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="operatorName")
    def operator_name(self) -> builtins.str:
        return pulumi.get(self, "operator_name")

    @property
    @pulumi.getter
    def parameters(self) -> Sequence['outputs.DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameter']:
        return pulumi.get(self, "parameters")


@pulumi.output_type
class DashboardPanelTracesListPanelQueryMetricsQueryDataOperatorParameter(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        return pulumi.get(self, "value")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRange'] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRange']:
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRange']:
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeTo'] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFrom':
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeTo']:
        return pulumi.get(self, "to")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardPanelTracesListPanelTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.DashboardTimeRangeCompleteLiteralTimeRange'] = None):
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRange']:
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.DashboardTimeRangeCompleteLiteralTimeRange']:
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.DashboardTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeTo'] = None):
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.DashboardTimeRangeBeginBoundedTimeRangeFrom':
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeTo']:
        return pulumi.get(self, "to")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class DashboardTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class DashboardTopologyLabelMap(dict):
    def __init__(__self__, *,
                 datas: Sequence['outputs.DashboardTopologyLabelMapData']):
        pulumi.set(__self__, "datas", datas)

    @property
    @pulumi.getter
    def datas(self) -> Sequence['outputs.DashboardTopologyLabelMapData']:
        return pulumi.get(self, "datas")


@pulumi.output_type
class DashboardTopologyLabelMapData(dict):
    def __init__(__self__, *,
                 label: builtins.str,
                 values: Sequence[builtins.str]):
        pulumi.set(__self__, "label", label)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def label(self) -> builtins.str:
        return pulumi.get(self, "label")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardVariable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceDefinition":
            suggest = "source_definition"
        elif key == "allowMultiSelect":
            suggest = "allow_multi_select"
        elif key == "defaultValue":
            suggest = "default_value"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "hideFromUi":
            suggest = "hide_from_ui"
        elif key == "includeAllOption":
            suggest = "include_all_option"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVariable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVariable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVariable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: builtins.str,
                 source_definition: 'outputs.DashboardVariableSourceDefinition',
                 allow_multi_select: Optional[builtins.bool] = None,
                 default_value: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 hide_from_ui: Optional[builtins.bool] = None,
                 id: Optional[builtins.str] = None,
                 include_all_option: Optional[builtins.bool] = None):
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "source_definition", source_definition)
        if allow_multi_select is not None:
            pulumi.set(__self__, "allow_multi_select", allow_multi_select)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if hide_from_ui is not None:
            pulumi.set(__self__, "hide_from_ui", hide_from_ui)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if include_all_option is not None:
            pulumi.set(__self__, "include_all_option", include_all_option)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="sourceDefinition")
    def source_definition(self) -> 'outputs.DashboardVariableSourceDefinition':
        return pulumi.get(self, "source_definition")

    @property
    @pulumi.getter(name="allowMultiSelect")
    def allow_multi_select(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "allow_multi_select")

    @property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[builtins.str]:
        return pulumi.get(self, "default_value")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="hideFromUi")
    def hide_from_ui(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "hide_from_ui")

    @property
    @pulumi.getter
    def id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "id")

    @property
    @pulumi.getter(name="includeAllOption")
    def include_all_option(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "include_all_option")


@pulumi.output_type
class DashboardVariableSourceDefinition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "csvVariableSourceDefinition":
            suggest = "csv_variable_source_definition"
        elif key == "logQueryVariableSourceDefinition":
            suggest = "log_query_variable_source_definition"
        elif key == "metadataVariableSourceDefinition":
            suggest = "metadata_variable_source_definition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DashboardVariableSourceDefinition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DashboardVariableSourceDefinition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DashboardVariableSourceDefinition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 csv_variable_source_definition: Optional['outputs.DashboardVariableSourceDefinitionCsvVariableSourceDefinition'] = None,
                 log_query_variable_source_definition: Optional['outputs.DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition'] = None,
                 metadata_variable_source_definition: Optional['outputs.DashboardVariableSourceDefinitionMetadataVariableSourceDefinition'] = None):
        if csv_variable_source_definition is not None:
            pulumi.set(__self__, "csv_variable_source_definition", csv_variable_source_definition)
        if log_query_variable_source_definition is not None:
            pulumi.set(__self__, "log_query_variable_source_definition", log_query_variable_source_definition)
        if metadata_variable_source_definition is not None:
            pulumi.set(__self__, "metadata_variable_source_definition", metadata_variable_source_definition)

    @property
    @pulumi.getter(name="csvVariableSourceDefinition")
    def csv_variable_source_definition(self) -> Optional['outputs.DashboardVariableSourceDefinitionCsvVariableSourceDefinition']:
        return pulumi.get(self, "csv_variable_source_definition")

    @property
    @pulumi.getter(name="logQueryVariableSourceDefinition")
    def log_query_variable_source_definition(self) -> Optional['outputs.DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition']:
        return pulumi.get(self, "log_query_variable_source_definition")

    @property
    @pulumi.getter(name="metadataVariableSourceDefinition")
    def metadata_variable_source_definition(self) -> Optional['outputs.DashboardVariableSourceDefinitionMetadataVariableSourceDefinition']:
        return pulumi.get(self, "metadata_variable_source_definition")


@pulumi.output_type
class DashboardVariableSourceDefinitionCsvVariableSourceDefinition(dict):
    def __init__(__self__, *,
                 values: builtins.str):
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def values(self) -> builtins.str:
        return pulumi.get(self, "values")


@pulumi.output_type
class DashboardVariableSourceDefinitionLogQueryVariableSourceDefinition(dict):
    def __init__(__self__, *,
                 field: builtins.str,
                 query: builtins.str):
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "query", query)

    @property
    @pulumi.getter
    def field(self) -> builtins.str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def query(self) -> builtins.str:
        return pulumi.get(self, "query")


@pulumi.output_type
class DashboardVariableSourceDefinitionMetadataVariableSourceDefinition(dict):
    def __init__(__self__, *,
                 filter: builtins.str,
                 key: builtins.str):
        pulumi.set(__self__, "filter", filter)
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def filter(self) -> builtins.str:
        return pulumi.get(self, "filter")

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")


@pulumi.output_type
class DataForwardingDestinationAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataForwardingDestinationAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataForwardingDestinationAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataForwardingDestinationAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None):
        """
        :param builtins.str type: AWS IAM authentication method used for access. Possible values are: 1. `AccessKey` 2. `RoleBased`
        :param builtins.str access_key: The AWS Access ID to access the S3 bucket.
        :param builtins.str role_arn: The AWS Role ARN to access the S3 bucket.
        :param builtins.str secret_key: The AWS Secret Key to access the S3 bucket.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        AWS IAM authentication method used for access. Possible values are: 1. `AccessKey` 2. `RoleBased`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        The AWS Access ID to access the S3 bucket.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        The AWS Role ARN to access the S3 bucket.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        The AWS Secret Key to access the S3 bucket.
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class ElbSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param builtins.str region: Your AWS Bucket region.
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class ElbSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class ElbSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class ElbSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.ElbSourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.ElbSourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.ElbSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.ElbSourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        :param builtins.str bucket_name: The name of the bucket.
        :param builtins.str path_expression: The path to the data.
        :param builtins.str region: Your AWS Bucket region.
        :param Sequence['ElbSourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `ELB` source.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.ElbSourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.ElbSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.ElbSourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.ElbSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class ElbSourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.ElbSourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.ElbSourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class ElbSourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class ElbSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class ElbSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ElbSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ElbSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ElbSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class ElbSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GcpMetricsSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be `service_account`.
        :param builtins.str auth_provider_x509_cert_url: As per the service_account.json downloaded from GCP
        :param builtins.str auth_uri: As per the service_account.json downloaded from GCP
        :param builtins.str client_email: As per the service_account.json downloaded from GCP
        :param builtins.str client_id: As per the service_account.json downloaded from GCP
        :param builtins.str client_x509_cert_url: As per the service_account.json downloaded from GCP
        :param builtins.str private_key: As per the service_account.json downloaded from GCP
        :param builtins.str private_key_id: As per the service_account.json downloaded from GCP
        :param builtins.str project_id: As per the service_account.json downloaded from GCP
        :param builtins.str token_uri: As per the service_account.json downloaded from GCP
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be `service_account`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        """
        As per the service_account.json downloaded from GCP
        """
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class GcpMetricsSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class GcpMetricsSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class GcpMetricsSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.GcpMetricsSourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.GcpMetricsSourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.GcpMetricsSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.GcpMetricsSourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: Type of polling source. This has to be `GcpMetricsPath`.
        :param Sequence['GcpMetricsSourcePathCustomServiceArgs'] custom_services: Sumoloigc provides list of services that can be used in limit_to_services for which metrics would be collected. Custom Services allow you to define your own service w.r.t. metric collection. You can provide list of metric prefixes that should be collected as part of the custom service. This provides fine-grain control w.r.t. what all metrics are ingested by sumologic.
        :param Sequence[builtins.str] limit_to_regions: List of regions for which metrics would be collected (Empty to collect from all regions)
        :param Sequence[builtins.str] limit_to_services: List of services from which metrics would be collected
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Type of polling source. This has to be `GcpMetricsPath`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.GcpMetricsSourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.GcpMetricsSourcePathCustomService']]:
        """
        Sumoloigc provides list of services that can be used in limit_to_services for which metrics would be collected. Custom Services allow you to define your own service w.r.t. metric collection. You can provide list of metric prefixes that should be collected as part of the custom service. This provides fine-grain control w.r.t. what all metrics are ingested by sumologic.
        """
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        """
        List of regions for which metrics would be collected (Empty to collect from all regions)
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        """
        List of services from which metrics would be collected
        """
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.GcpMetricsSourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.GcpMetricsSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class GcpMetricsSourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.GcpMetricsSourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.GcpMetricsSourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class GcpMetricsSourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class GcpMetricsSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] prefixes: List of metric type prefixes. Eg: `["compute.googleapis.com/instance/","compute.googleapis.com/guest/"]`
        :param builtins.str service_name: Name of the custom service you want to define.
        """
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        """
        List of metric type prefixes. Eg: `["compute.googleapis.com/instance/","compute.googleapis.com/guest/"]`
        """
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        """
        Name of the custom service you want to define.
        """
        return pulumi.get(self, "service_name")


@pulumi.output_type
class GcpMetricsSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpMetricsSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpMetricsSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpMetricsSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class GcpMetricsSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GcpSourceAuthentication(dict):
    def __init__(__self__, *,
                 type: Optional[builtins.str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class GcpSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class GcpSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GcpSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GcpSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GcpSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class GcpSourcePath(dict):
    def __init__(__self__, *,
                 type: Optional[builtins.str] = None):
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class HierarchyFilter(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str key: Filtering key.
        :param builtins.str value: Value required for the filtering key.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Filtering key.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Value required for the filtering key.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class HierarchyLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevelArgs' level: A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel':
        """
        A hierarchy of entities. The order is up-down, left to right levels with condition, then level without condition. Maximum supported total depth is 6.
        """
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevel":
            suggest = "next_level"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_level: Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel'] = None,
                 next_levels_with_conditions: Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param 'HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelArgs' next_level: Next level without a condition.
               
               The following attributes are exported:
        :param Sequence['HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionArgs'] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_level is not None:
            pulumi.set(__self__, "next_level", next_level)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevel")
    def next_level(self) -> Optional['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel']:
        """
        Next level without a condition.

        The following attributes are exported:
        """
        return pulumi.get(self, "next_level")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence['outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition']]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithCondition(dict):
    def __init__(__self__, *,
                 condition: builtins.str,
                 level: 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel'):
        """
        :param builtins.str condition: Condition to be checked against for level.entityType value, for now full string match.
        """
        pulumi.set(__self__, "condition", condition)
        pulumi.set(__self__, "level", level)

    @property
    @pulumi.getter
    def condition(self) -> builtins.str:
        """
        Condition to be checked against for level.entityType value, for now full string match.
        """
        return pulumi.get(self, "condition")

    @property
    @pulumi.getter
    def level(self) -> 'outputs.HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel':
        return pulumi.get(self, "level")


@pulumi.output_type
class HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entityType":
            suggest = "entity_type"
        elif key == "nextLevelsWithConditions":
            suggest = "next_levels_with_conditions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HierarchyLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevelNextLevelsWithConditionLevel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entity_type: builtins.str,
                 next_levels_with_conditions: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str entity_type: Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        :param Sequence[builtins.str] next_levels_with_conditions: Zero or more next levels with conditions.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        if next_levels_with_conditions is not None:
            pulumi.set(__self__, "next_levels_with_conditions", next_levels_with_conditions)

    @property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> builtins.str:
        """
        Indicates the name and type for all entities at this hierarchy level, e.g. service or pod in case of kubernetes entities.
        """
        return pulumi.get(self, "entity_type")

    @property
    @pulumi.getter(name="nextLevelsWithConditions")
    def next_levels_with_conditions(self) -> Optional[Sequence[builtins.str]]:
        """
        Zero or more next levels with conditions.
        """
        return pulumi.get(self, "next_levels_with_conditions")


@pulumi.output_type
class HttpSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class HttpSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in HttpSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        HttpSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        HttpSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class KinesisLogSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisLogSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisLogSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisLogSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 access_key: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication` or `NoAuthentication`
        """
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication` or `NoAuthentication`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KinesisLogSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class KinesisLogSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisLogSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisLogSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisLogSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class KinesisLogSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "scanInterval":
            suggest = "scan_interval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisLogSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisLogSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisLogSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 scan_interval: Optional[builtins.int] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str bucket_name: The name of the bucket. This is needed if using type `KinesisLogPath`.
        :param builtins.str path_expression: The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must include `http-endpoint-failed/`.
        :param builtins.int scan_interval: The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        :param builtins.str type: Must be either `KinesisLogPath` or `NoPathExpression`
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if scan_interval is not None:
            pulumi.set(__self__, "scan_interval", scan_interval)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        """
        The name of the bucket. This is needed if using type `KinesisLogPath`.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        """
        The path to the data. This is needed if using type `KinesisLogPath`. For Kinesis log source, it must include `http-endpoint-failed/`.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="scanInterval")
    def scan_interval(self) -> Optional[builtins.int]:
        """
        The Time interval in milliseconds of scans for new data. The default is 300000 and the minimum value is 1000 milliseconds.
        """
        return pulumi.get(self, "scan_interval")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Must be either `KinesisLogPath` or `NoPathExpression`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class KinesisMetricsSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisMetricsSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisMetricsSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisMetricsSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class KinesisMetricsSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class KinesisMetricsSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisMetricsSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisMetricsSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisMetricsSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class KinesisMetricsSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KinesisMetricsSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KinesisMetricsSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KinesisMetricsSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 tag_filters: Optional[Sequence['outputs.KinesisMetricsSourcePathTagFilter']] = None):
        """
        :param builtins.str type: Must be `KinesisMetricPath`
        :param Sequence['KinesisMetricsSourcePathTagFilterArgs'] tag_filters: Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        pulumi.set(__self__, "type", type)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be `KinesisMetricPath`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.KinesisMetricsSourcePathTagFilter']]:
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class KinesisMetricsSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param Sequence[builtins.str] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        :param builtins.str type: This value has to be set to `TagFilters`
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class LocalFileSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class LocalFileSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LocalFileSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LocalFileSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LocalFileSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        """
        :param builtins.str name: The name of the local file source. This is required, and has to be unique. Changing this will force recreation the source.
        """
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        The name of the local file source. This is required, and has to be unique. Changing this will force recreation the source.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class LogSearchQueryParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchQueryParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchQueryParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchQueryParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_type: builtins.str,
                 name: builtins.str,
                 value: builtins.str,
                 description: Optional[builtins.str] = None):
        """
        :param builtins.str data_type: The data type of the parameter. Supported values are:
               1. `NUMBER`
               2. `STRING`
               3. `ANY`
               4. `KEYWORD`
        :param builtins.str name: Name of the search.
        :param builtins.str value: Default value of scheduled search parameter.
        :param builtins.str description: Description of the search.
        """
        pulumi.set(__self__, "data_type", data_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> builtins.str:
        """
        The data type of the parameter. Supported values are:
        1. `NUMBER`
        2. `STRING`
        3. `ANY`
        4. `KEYWORD`
        """
        return pulumi.get(self, "data_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the search.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Default value of scheduled search parameter.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        Description of the search.
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class LogSearchSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "parseableTimeRange":
            suggest = "parseable_time_range"
        elif key == "scheduleType":
            suggest = "schedule_type"
        elif key == "timeZone":
            suggest = "time_zone"
        elif key == "cronExpression":
            suggest = "cron_expression"
        elif key == "muteErrorEmails":
            suggest = "mute_error_emails"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification: 'outputs.LogSearchScheduleNotification',
                 parseable_time_range: 'outputs.LogSearchScheduleParseableTimeRange',
                 schedule_type: builtins.str,
                 time_zone: builtins.str,
                 cron_expression: Optional[builtins.str] = None,
                 mute_error_emails: Optional[builtins.bool] = None,
                 parameters: Optional[Sequence['outputs.LogSearchScheduleParameter']] = None,
                 threshold: Optional['outputs.LogSearchScheduleThreshold'] = None):
        """
        :param 'LogSearchScheduleNotificationArgs' notification: Notification of the log search. See
               notification schema
        :param 'LogSearchScheduleParseableTimeRangeArgs' parseable_time_range: Time range of the scheduled log search. See
               time range schema
        :param builtins.str schedule_type: Run schedule of the scheduled search. Set to "Custom" to specify the schedule with
               a CRON expression. Possible schedule types are: `15Minutes`, `1Hour`, `2Hours`, `4Hours`, `6Hours`,
               `8Hours`, `12Hours`, `1Day`, `1Week`, `Custom`.
               
               > With `Custom`, `1Day` and `1Week` schedule types you need to provide the corresponding cron expression
               to determine when to actually run the search. E.g. valid cron for `1Day` is `0 0 16 ? * 2-6 *`.
        :param builtins.str time_zone: Time zone for the scheduled log search. Either an abbreviation such as "PST",
               a full name such as "America/Los_Angeles", or a custom ID such as "GMT-8:00". Note that the support of
               abbreviations is for JDK 1.1.x compatibility only and full names should be used.
        :param builtins.str cron_expression: Cron-like expression specifying the search's schedule. `schedule_type` must be set
               to "Custom", otherwise, `schedule_type` takes precedence over `cron_expression`.
        :param builtins.bool mute_error_emails: If enabled, emails are not sent out in case of errors with the search.
        :param 'LogSearchScheduleThresholdArgs' threshold: Threshold for when to send notification. See
               threshold schema
        """
        pulumi.set(__self__, "notification", notification)
        pulumi.set(__self__, "parseable_time_range", parseable_time_range)
        pulumi.set(__self__, "schedule_type", schedule_type)
        pulumi.set(__self__, "time_zone", time_zone)
        if cron_expression is not None:
            pulumi.set(__self__, "cron_expression", cron_expression)
        if mute_error_emails is not None:
            pulumi.set(__self__, "mute_error_emails", mute_error_emails)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def notification(self) -> 'outputs.LogSearchScheduleNotification':
        """
        Notification of the log search. See
        notification schema
        """
        return pulumi.get(self, "notification")

    @property
    @pulumi.getter(name="parseableTimeRange")
    def parseable_time_range(self) -> 'outputs.LogSearchScheduleParseableTimeRange':
        """
        Time range of the scheduled log search. See
        time range schema
        """
        return pulumi.get(self, "parseable_time_range")

    @property
    @pulumi.getter(name="scheduleType")
    def schedule_type(self) -> builtins.str:
        """
        Run schedule of the scheduled search. Set to "Custom" to specify the schedule with
        a CRON expression. Possible schedule types are: `15Minutes`, `1Hour`, `2Hours`, `4Hours`, `6Hours`,
        `8Hours`, `12Hours`, `1Day`, `1Week`, `Custom`.

        > With `Custom`, `1Day` and `1Week` schedule types you need to provide the corresponding cron expression
        to determine when to actually run the search. E.g. valid cron for `1Day` is `0 0 16 ? * 2-6 *`.
        """
        return pulumi.get(self, "schedule_type")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> builtins.str:
        """
        Time zone for the scheduled log search. Either an abbreviation such as "PST",
        a full name such as "America/Los_Angeles", or a custom ID such as "GMT-8:00". Note that the support of
        abbreviations is for JDK 1.1.x compatibility only and full names should be used.
        """
        return pulumi.get(self, "time_zone")

    @property
    @pulumi.getter(name="cronExpression")
    def cron_expression(self) -> Optional[builtins.str]:
        """
        Cron-like expression specifying the search's schedule. `schedule_type` must be set
        to "Custom", otherwise, `schedule_type` takes precedence over `cron_expression`.
        """
        return pulumi.get(self, "cron_expression")

    @property
    @pulumi.getter(name="muteErrorEmails")
    def mute_error_emails(self) -> Optional[builtins.bool]:
        """
        If enabled, emails are not sent out in case of errors with the search.
        """
        return pulumi.get(self, "mute_error_emails")

    @property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.LogSearchScheduleParameter']]:
        return pulumi.get(self, "parameters")

    @property
    @pulumi.getter
    def threshold(self) -> Optional['outputs.LogSearchScheduleThreshold']:
        """
        Threshold for when to send notification. See
        threshold schema
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class LogSearchScheduleNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "alertSearchNotification":
            suggest = "alert_search_notification"
        elif key == "cseSignalNotification":
            suggest = "cse_signal_notification"
        elif key == "emailSearchNotification":
            suggest = "email_search_notification"
        elif key == "saveToLookupNotification":
            suggest = "save_to_lookup_notification"
        elif key == "saveToViewNotification":
            suggest = "save_to_view_notification"
        elif key == "serviceNowSearchNotification":
            suggest = "service_now_search_notification"
        elif key == "webhookSearchNotification":
            suggest = "webhook_search_notification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert_search_notification: Optional['outputs.LogSearchScheduleNotificationAlertSearchNotification'] = None,
                 cse_signal_notification: Optional['outputs.LogSearchScheduleNotificationCseSignalNotification'] = None,
                 email_search_notification: Optional['outputs.LogSearchScheduleNotificationEmailSearchNotification'] = None,
                 save_to_lookup_notification: Optional['outputs.LogSearchScheduleNotificationSaveToLookupNotification'] = None,
                 save_to_view_notification: Optional['outputs.LogSearchScheduleNotificationSaveToViewNotification'] = None,
                 service_now_search_notification: Optional['outputs.LogSearchScheduleNotificationServiceNowSearchNotification'] = None,
                 webhook_search_notification: Optional['outputs.LogSearchScheduleNotificationWebhookSearchNotification'] = None):
        """
        :param 'LogSearchScheduleNotificationAlertSearchNotificationArgs' alert_search_notification: Run an script action. See
               alert_search_notification schema for details.
        :param 'LogSearchScheduleNotificationCseSignalNotificationArgs' cse_signal_notification: Create a CSE signal with a scheduled search.
               See cse_signal_notification schema schema for details.
        :param 'LogSearchScheduleNotificationEmailSearchNotificationArgs' email_search_notification: Send an alert via email. See
               email_search_notification schema schema for details.
        :param 'LogSearchScheduleNotificationSaveToLookupNotificationArgs' save_to_lookup_notification: Save results to a Lookup Table. See
               save_to_lookup_notification schema schema for details.
        :param 'LogSearchScheduleNotificationSaveToViewNotificationArgs' save_to_view_notification: Save results to an index. See
               save_to_view_notification schema schema for details.
        :param 'LogSearchScheduleNotificationServiceNowSearchNotificationArgs' service_now_search_notification: Send results to Service Now. See
               service_now_search_notification schema schema for details.
        :param 'LogSearchScheduleNotificationWebhookSearchNotificationArgs' webhook_search_notification: Send an alert via Webhook. See
               webhook_search_notification schema schema for details.
        """
        if alert_search_notification is not None:
            pulumi.set(__self__, "alert_search_notification", alert_search_notification)
        if cse_signal_notification is not None:
            pulumi.set(__self__, "cse_signal_notification", cse_signal_notification)
        if email_search_notification is not None:
            pulumi.set(__self__, "email_search_notification", email_search_notification)
        if save_to_lookup_notification is not None:
            pulumi.set(__self__, "save_to_lookup_notification", save_to_lookup_notification)
        if save_to_view_notification is not None:
            pulumi.set(__self__, "save_to_view_notification", save_to_view_notification)
        if service_now_search_notification is not None:
            pulumi.set(__self__, "service_now_search_notification", service_now_search_notification)
        if webhook_search_notification is not None:
            pulumi.set(__self__, "webhook_search_notification", webhook_search_notification)

    @property
    @pulumi.getter(name="alertSearchNotification")
    def alert_search_notification(self) -> Optional['outputs.LogSearchScheduleNotificationAlertSearchNotification']:
        """
        Run an script action. See
        alert_search_notification schema for details.
        """
        return pulumi.get(self, "alert_search_notification")

    @property
    @pulumi.getter(name="cseSignalNotification")
    def cse_signal_notification(self) -> Optional['outputs.LogSearchScheduleNotificationCseSignalNotification']:
        """
        Create a CSE signal with a scheduled search.
        See cse_signal_notification schema schema for details.
        """
        return pulumi.get(self, "cse_signal_notification")

    @property
    @pulumi.getter(name="emailSearchNotification")
    def email_search_notification(self) -> Optional['outputs.LogSearchScheduleNotificationEmailSearchNotification']:
        """
        Send an alert via email. See
        email_search_notification schema schema for details.
        """
        return pulumi.get(self, "email_search_notification")

    @property
    @pulumi.getter(name="saveToLookupNotification")
    def save_to_lookup_notification(self) -> Optional['outputs.LogSearchScheduleNotificationSaveToLookupNotification']:
        """
        Save results to a Lookup Table. See
        save_to_lookup_notification schema schema for details.
        """
        return pulumi.get(self, "save_to_lookup_notification")

    @property
    @pulumi.getter(name="saveToViewNotification")
    def save_to_view_notification(self) -> Optional['outputs.LogSearchScheduleNotificationSaveToViewNotification']:
        """
        Save results to an index. See
        save_to_view_notification schema schema for details.
        """
        return pulumi.get(self, "save_to_view_notification")

    @property
    @pulumi.getter(name="serviceNowSearchNotification")
    def service_now_search_notification(self) -> Optional['outputs.LogSearchScheduleNotificationServiceNowSearchNotification']:
        """
        Send results to Service Now. See
        service_now_search_notification schema schema for details.
        """
        return pulumi.get(self, "service_now_search_notification")

    @property
    @pulumi.getter(name="webhookSearchNotification")
    def webhook_search_notification(self) -> Optional['outputs.LogSearchScheduleNotificationWebhookSearchNotification']:
        """
        Send an alert via Webhook. See
        webhook_search_notification schema schema for details.
        """
        return pulumi.get(self, "webhook_search_notification")


@pulumi.output_type
class LogSearchScheduleNotificationAlertSearchNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceId":
            suggest = "source_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleNotificationAlertSearchNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleNotificationAlertSearchNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleNotificationAlertSearchNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_id: builtins.str):
        """
        :param builtins.str source_id: Identifier of the collector's source.
        """
        pulumi.set(__self__, "source_id", source_id)

    @property
    @pulumi.getter(name="sourceId")
    def source_id(self) -> builtins.str:
        """
        Identifier of the collector's source.
        """
        return pulumi.get(self, "source_id")


@pulumi.output_type
class LogSearchScheduleNotificationCseSignalNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "recordType":
            suggest = "record_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleNotificationCseSignalNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleNotificationCseSignalNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleNotificationCseSignalNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 record_type: builtins.str):
        """
        :param builtins.str record_type: Name of the Cloud SIEM Enterprise Record to be created.
        """
        pulumi.set(__self__, "record_type", record_type)

    @property
    @pulumi.getter(name="recordType")
    def record_type(self) -> builtins.str:
        """
        Name of the Cloud SIEM Enterprise Record to be created.
        """
        return pulumi.get(self, "record_type")


@pulumi.output_type
class LogSearchScheduleNotificationEmailSearchNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toLists":
            suggest = "to_lists"
        elif key == "includeCsvAttachment":
            suggest = "include_csv_attachment"
        elif key == "includeHistogram":
            suggest = "include_histogram"
        elif key == "includeQuery":
            suggest = "include_query"
        elif key == "includeResultSet":
            suggest = "include_result_set"
        elif key == "subjectTemplate":
            suggest = "subject_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleNotificationEmailSearchNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleNotificationEmailSearchNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleNotificationEmailSearchNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 to_lists: Sequence[builtins.str],
                 include_csv_attachment: Optional[builtins.bool] = None,
                 include_histogram: Optional[builtins.bool] = None,
                 include_query: Optional[builtins.bool] = None,
                 include_result_set: Optional[builtins.bool] = None,
                 subject_template: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] to_lists: A list of email recipients.
        :param builtins.bool include_csv_attachment: If the search results should be included in the notification email
               as a CSV attachment.
        :param builtins.bool include_histogram: If the search result histogram should be included in the notification email.
        :param builtins.bool include_query: If the search query should be included in the notification email.
        :param builtins.bool include_result_set: If the search result set should be included in the notification email.
        :param builtins.str subject_template: Subject of the email. If the notification is scheduled with a threshold,
               the default subject template will be `Search Alert: {{AlertCondition}} results found for {{SearchName}}`.
               For email notifications without a threshold, the default subject template is `Search Results: {{SearchName}}`.
        """
        pulumi.set(__self__, "to_lists", to_lists)
        if include_csv_attachment is not None:
            pulumi.set(__self__, "include_csv_attachment", include_csv_attachment)
        if include_histogram is not None:
            pulumi.set(__self__, "include_histogram", include_histogram)
        if include_query is not None:
            pulumi.set(__self__, "include_query", include_query)
        if include_result_set is not None:
            pulumi.set(__self__, "include_result_set", include_result_set)
        if subject_template is not None:
            pulumi.set(__self__, "subject_template", subject_template)

    @property
    @pulumi.getter(name="toLists")
    def to_lists(self) -> Sequence[builtins.str]:
        """
        A list of email recipients.
        """
        return pulumi.get(self, "to_lists")

    @property
    @pulumi.getter(name="includeCsvAttachment")
    def include_csv_attachment(self) -> Optional[builtins.bool]:
        """
        If the search results should be included in the notification email
        as a CSV attachment.
        """
        return pulumi.get(self, "include_csv_attachment")

    @property
    @pulumi.getter(name="includeHistogram")
    def include_histogram(self) -> Optional[builtins.bool]:
        """
        If the search result histogram should be included in the notification email.
        """
        return pulumi.get(self, "include_histogram")

    @property
    @pulumi.getter(name="includeQuery")
    def include_query(self) -> Optional[builtins.bool]:
        """
        If the search query should be included in the notification email.
        """
        return pulumi.get(self, "include_query")

    @property
    @pulumi.getter(name="includeResultSet")
    def include_result_set(self) -> Optional[builtins.bool]:
        """
        If the search result set should be included in the notification email.
        """
        return pulumi.get(self, "include_result_set")

    @property
    @pulumi.getter(name="subjectTemplate")
    def subject_template(self) -> Optional[builtins.str]:
        """
        Subject of the email. If the notification is scheduled with a threshold,
        the default subject template will be `Search Alert: {{AlertCondition}} results found for {{SearchName}}`.
        For email notifications without a threshold, the default subject template is `Search Results: {{SearchName}}`.
        """
        return pulumi.get(self, "subject_template")


@pulumi.output_type
class LogSearchScheduleNotificationSaveToLookupNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isLookupMergeOperation":
            suggest = "is_lookup_merge_operation"
        elif key == "lookupFilePath":
            suggest = "lookup_file_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleNotificationSaveToLookupNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleNotificationSaveToLookupNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleNotificationSaveToLookupNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_lookup_merge_operation: builtins.bool,
                 lookup_file_path: builtins.str):
        """
        :param builtins.bool is_lookup_merge_operation: Whether to merge the file contents with existing data in the lookup table.
        :param builtins.str lookup_file_path: Path of the lookup table to save the results to.
        """
        pulumi.set(__self__, "is_lookup_merge_operation", is_lookup_merge_operation)
        pulumi.set(__self__, "lookup_file_path", lookup_file_path)

    @property
    @pulumi.getter(name="isLookupMergeOperation")
    def is_lookup_merge_operation(self) -> builtins.bool:
        """
        Whether to merge the file contents with existing data in the lookup table.
        """
        return pulumi.get(self, "is_lookup_merge_operation")

    @property
    @pulumi.getter(name="lookupFilePath")
    def lookup_file_path(self) -> builtins.str:
        """
        Path of the lookup table to save the results to.
        """
        return pulumi.get(self, "lookup_file_path")


@pulumi.output_type
class LogSearchScheduleNotificationSaveToViewNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewName":
            suggest = "view_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleNotificationSaveToViewNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleNotificationSaveToViewNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleNotificationSaveToViewNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view_name: builtins.str):
        """
        :param builtins.str view_name: Name of the View(Index) to save the results to.
        """
        pulumi.set(__self__, "view_name", view_name)

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> builtins.str:
        """
        Name of the View(Index) to save the results to.
        """
        return pulumi.get(self, "view_name")


@pulumi.output_type
class LogSearchScheduleNotificationServiceNowSearchNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalId":
            suggest = "external_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleNotificationServiceNowSearchNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleNotificationServiceNowSearchNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleNotificationServiceNowSearchNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_id: builtins.str,
                 fields: Optional['outputs.LogSearchScheduleNotificationServiceNowSearchNotificationFields'] = None):
        """
        :param builtins.str external_id: Service Now Identifier.
        :param 'LogSearchScheduleNotificationServiceNowSearchNotificationFieldsArgs' fields: Service Now fields.
        """
        pulumi.set(__self__, "external_id", external_id)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @property
    @pulumi.getter(name="externalId")
    def external_id(self) -> builtins.str:
        """
        Service Now Identifier.
        """
        return pulumi.get(self, "external_id")

    @property
    @pulumi.getter
    def fields(self) -> Optional['outputs.LogSearchScheduleNotificationServiceNowSearchNotificationFields']:
        """
        Service Now fields.
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class LogSearchScheduleNotificationServiceNowSearchNotificationFields(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "eventType":
            suggest = "event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleNotificationServiceNowSearchNotificationFields. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleNotificationServiceNowSearchNotificationFields.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleNotificationServiceNowSearchNotificationFields.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 event_type: Optional[builtins.str] = None,
                 node: Optional[builtins.str] = None,
                 resource: Optional[builtins.str] = None,
                 severity: Optional[builtins.int] = None):
        """
        :param builtins.str event_type: The category that the event source uses to identify the event.
        :param builtins.str node: The physical or virtual device on which the event occurred.
        :param builtins.str resource: The component on the node to which the event applies.
        :param builtins.int severity: An integer value representing the severity of the alert. Supported values are:
               * 0 for Clear
               * 1 for Critical
               * 2 for Major
               * 3 for Minor
               * 4 for Warning
        """
        if event_type is not None:
            pulumi.set(__self__, "event_type", event_type)
        if node is not None:
            pulumi.set(__self__, "node", node)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> Optional[builtins.str]:
        """
        The category that the event source uses to identify the event.
        """
        return pulumi.get(self, "event_type")

    @property
    @pulumi.getter
    def node(self) -> Optional[builtins.str]:
        """
        The physical or virtual device on which the event occurred.
        """
        return pulumi.get(self, "node")

    @property
    @pulumi.getter
    def resource(self) -> Optional[builtins.str]:
        """
        The component on the node to which the event applies.
        """
        return pulumi.get(self, "resource")

    @property
    @pulumi.getter
    def severity(self) -> Optional[builtins.int]:
        """
        An integer value representing the severity of the alert. Supported values are:
        * 0 for Clear
        * 1 for Critical
        * 2 for Major
        * 3 for Minor
        * 4 for Warning
        """
        return pulumi.get(self, "severity")


@pulumi.output_type
class LogSearchScheduleNotificationWebhookSearchNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webhookId":
            suggest = "webhook_id"
        elif key == "itemizeAlerts":
            suggest = "itemize_alerts"
        elif key == "maxItemizedAlerts":
            suggest = "max_itemized_alerts"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleNotificationWebhookSearchNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleNotificationWebhookSearchNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleNotificationWebhookSearchNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 webhook_id: builtins.str,
                 itemize_alerts: Optional[builtins.bool] = None,
                 max_itemized_alerts: Optional[builtins.int] = None,
                 payload: Optional[builtins.str] = None):
        """
        :param builtins.str webhook_id: Identifier of the webhook connection.
        :param builtins.bool itemize_alerts: If set to true, one webhook per result will be sent when the trigger conditions are met.
        :param builtins.int max_itemized_alerts: The maximum number of results for which we send separate alerts.
        :param builtins.str payload: A JSON object in the format required by the target WebHook URL.
        """
        pulumi.set(__self__, "webhook_id", webhook_id)
        if itemize_alerts is not None:
            pulumi.set(__self__, "itemize_alerts", itemize_alerts)
        if max_itemized_alerts is not None:
            pulumi.set(__self__, "max_itemized_alerts", max_itemized_alerts)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)

    @property
    @pulumi.getter(name="webhookId")
    def webhook_id(self) -> builtins.str:
        """
        Identifier of the webhook connection.
        """
        return pulumi.get(self, "webhook_id")

    @property
    @pulumi.getter(name="itemizeAlerts")
    def itemize_alerts(self) -> Optional[builtins.bool]:
        """
        If set to true, one webhook per result will be sent when the trigger conditions are met.
        """
        return pulumi.get(self, "itemize_alerts")

    @property
    @pulumi.getter(name="maxItemizedAlerts")
    def max_itemized_alerts(self) -> Optional[builtins.int]:
        """
        The maximum number of results for which we send separate alerts.
        """
        return pulumi.get(self, "max_itemized_alerts")

    @property
    @pulumi.getter
    def payload(self) -> Optional[builtins.str]:
        """
        A JSON object in the format required by the target WebHook URL.
        """
        return pulumi.get(self, "payload")


@pulumi.output_type
class LogSearchScheduleParameter(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str name: Name of the search.
        :param builtins.str value: Default value of scheduled search parameter.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        """
        Name of the search.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Default value of scheduled search parameter.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LogSearchScheduleParseableTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRange'] = None):
        """
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeArgs' begin_bounded_time_range: Bounded time range. See
               begin_bounded_time_range schema schema for details.
        :param 'LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRangeArgs' complete_literal_time_range: Literal time range. See
               complete_literal_time_range schema for details.
        """
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRange']:
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRange']:
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeTo'] = None):
        """
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromArgs' from_: Start boundary of bounded time range. See
               time_range_boundary schema for details.
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToArgs' to: End boundary of bounded time range. See
               time_range_boundary schema for details.
        """
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFrom':
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeTo']:
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        """
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs' epoch_time_range: Time since the epoch.
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs' iso8601_time_range: Time in ISO 8601 format.
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs' literal_time_range: Time in literal format.
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs' relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        """
        :param builtins.int epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        """
        :param builtins.str iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        """
        :param builtins.str relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        """
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs' epoch_time_range: Time since the epoch.
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs' iso8601_time_range: Time in ISO 8601 format.
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs' literal_time_range: Time in literal format.
        :param 'LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs' relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        """
        :param builtins.int epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        """
        :param builtins.str iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        """
        :param builtins.str relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleParseableTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class LogSearchScheduleThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchScheduleThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchScheduleThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchScheduleThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 count: builtins.int,
                 operator: builtins.str,
                 threshold_type: builtins.str):
        """
        :param builtins.int count: Expected result count.
        :param builtins.str operator: Criterion to be applied when comparing actual result count with expected count. Possible
               values are: `eq`, `gt`, `ge`, `lt`, and `le`.
        :param builtins.str threshold_type: Threshold type for the scheduled log search. Possible values are: `message` and `group`.
               Use `group` as threshold type if the search query is of aggregate type. For non-aggregate queries, set it
               to `message`.
        """
        pulumi.set(__self__, "count", count)
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def count(self) -> builtins.int:
        """
        Expected result count.
        """
        return pulumi.get(self, "count")

    @property
    @pulumi.getter
    def operator(self) -> builtins.str:
        """
        Criterion to be applied when comparing actual result count with expected count. Possible
        values are: `eq`, `gt`, `ge`, `lt`, and `le`.
        """
        return pulumi.get(self, "operator")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> builtins.str:
        """
        Threshold type for the scheduled log search. Possible values are: `message` and `group`.
        Use `group` as threshold type if the search query is of aggregate type. For non-aggregate queries, set it
        to `message`.
        """
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class LogSearchTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.LogSearchTimeRangeCompleteLiteralTimeRange'] = None):
        """
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeArgs' begin_bounded_time_range: Bounded time range. See
               begin_bounded_time_range schema schema for details.
        :param 'LogSearchTimeRangeCompleteLiteralTimeRangeArgs' complete_literal_time_range: Literal time range. See
               complete_literal_time_range schema for details.
        """
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRange']:
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.LogSearchTimeRangeCompleteLiteralTimeRange']:
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.LogSearchTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeTo'] = None):
        """
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeFromArgs' from_: Start boundary of bounded time range. See
               time_range_boundary schema for details.
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeToArgs' to: End boundary of bounded time range. See
               time_range_boundary schema for details.
        """
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.LogSearchTimeRangeBeginBoundedTimeRangeFrom':
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeTo']:
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        """
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs' epoch_time_range: Time since the epoch.
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs' iso8601_time_range: Time in ISO 8601 format.
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs' literal_time_range: Time in literal format.
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs' relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        """
        :param builtins.int epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        """
        :param builtins.str iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        """
        :param builtins.str relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        """
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs' epoch_time_range: Time since the epoch.
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs' iso8601_time_range: Time in ISO 8601 format.
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs' literal_time_range: Time in literal format.
        :param 'LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs' relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        """
        :param builtins.int epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        """
        :param builtins.str iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        """
        :param builtins.str relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class LogSearchTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LogSearchTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LogSearchTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LogSearchTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class LookupTableField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fieldName":
            suggest = "field_name"
        elif key == "fieldType":
            suggest = "field_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LookupTableField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LookupTableField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LookupTableField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field_name: builtins.str,
                 field_type: builtins.str):
        pulumi.set(__self__, "field_name", field_name)
        pulumi.set(__self__, "field_type", field_type)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> builtins.str:
        return pulumi.get(self, "field_name")

    @property
    @pulumi.getter(name="fieldType")
    def field_type(self) -> builtins.str:
        return pulumi.get(self, "field_type")


@pulumi.output_type
class MetadataSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class MetadataSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class MetadataSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class MetadataSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetadataSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetadataSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetadataSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 tag_filters: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str type: type of polling source. Only allowed value is `AwsMetadataPath`.
        :param Sequence[builtins.str] limit_to_namespaces: List of namespaces. For `AwsMetadataPath` the only valid namespace is `AWS/EC2`.
        :param Sequence[builtins.str] limit_to_regions: List of Amazon regions.
        :param Sequence[builtins.str] tag_filters: Leave this field blank to collect all tags configured for the EC2 instance. To collect a subset of tags, follow the instructions in [Define EC2 tag filters][2]
        """
        pulumi.set(__self__, "type", type)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. Only allowed value is `AwsMetadataPath`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        """
        List of namespaces. For `AwsMetadataPath` the only valid namespace is `AWS/EC2`.
        """
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        """
        List of Amazon regions.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence[builtins.str]]:
        """
        Leave this field blank to collect all tags configured for the EC2 instance. To collect a subset of tags, follow the instructions in [Define EC2 tag filters][2]
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class MetricsSearchMetricsQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowId":
            suggest = "row_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchMetricsQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchMetricsQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchMetricsQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: builtins.str,
                 row_id: builtins.str):
        """
        :param builtins.str query: A metric query consists of a metric, one or more filters and optionally, one or more [Metrics Operators](https://help.sumologic.com/?cid=10144).
               Strictly speaking, both filters and operators are optional.
               Most of the [Metrics Operators](https://help.sumologic.com/?cid=10144) are allowed in the query string except `fillmissing`, `outlier`, `quantize` and `timeshift`.
               In practice, your metric queries will almost always contain filters that narrow the scope of your query.
               For more information about the query language see [Metrics Queries](https://help.sumologic.com/?cid=1079).
        :param builtins.str row_id: Row id for the query row, A to Z letter.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)

    @property
    @pulumi.getter
    def query(self) -> builtins.str:
        """
        A metric query consists of a metric, one or more filters and optionally, one or more [Metrics Operators](https://help.sumologic.com/?cid=10144).
        Strictly speaking, both filters and operators are optional.
        Most of the [Metrics Operators](https://help.sumologic.com/?cid=10144) are allowed in the query string except `fillmissing`, `outlier`, `quantize` and `timeshift`.
        In practice, your metric queries will almost always contain filters that narrow the scope of your query.
        For more information about the query language see [Metrics Queries](https://help.sumologic.com/?cid=1079).
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> builtins.str:
        """
        Row id for the query row, A to Z letter.
        """
        return pulumi.get(self, "row_id")


@pulumi.output_type
class MetricsSearchTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.MetricsSearchTimeRangeCompleteLiteralTimeRange'] = None):
        """
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeArgs' begin_bounded_time_range: Bounded time range. See
               begin_bounded_time_range schema schema for details.
        :param 'MetricsSearchTimeRangeCompleteLiteralTimeRangeArgs' complete_literal_time_range: Literal time range. See
               complete_literal_time_range schema for details.
        """
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRange']:
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeCompleteLiteralTimeRange']:
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeTo'] = None):
        """
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeFromArgs' from_: Start boundary of bounded time range. See
               time_range_boundary schema for details.
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeToArgs' to: End boundary of bounded time range. See
               time_range_boundary schema for details.
        """
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFrom':
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeTo']:
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        """
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs' epoch_time_range: Time since the epoch.
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs' iso8601_time_range: Time in ISO 8601 format.
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs' literal_time_range: Time in literal format.
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs' relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        """
        :param builtins.int epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        """
        :param builtins.str iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        """
        :param builtins.str relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        """
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs' epoch_time_range: Time since the epoch.
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs' iso8601_time_range: Time in ISO 8601 format.
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs' literal_time_range: Time in literal format.
        :param 'MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs' relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        """
        :param builtins.int epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        """
        :param builtins.str iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        """
        :param builtins.str relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class MetricsSearchTimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchTimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchTimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class MetricsSearchV2Query(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryKey":
            suggest = "query_key"
        elif key == "queryString":
            suggest = "query_string"
        elif key == "queryType":
            suggest = "query_type"
        elif key == "metricsQueryMode":
            suggest = "metrics_query_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2Query. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2Query.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2Query.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_key: builtins.str,
                 query_string: builtins.str,
                 query_type: builtins.str,
                 metrics_query_mode: Optional[builtins.str] = None):
        """
        :param builtins.str query_key: Key for the query row, A to Z letter.
        :param builtins.str query_string: A metric query consists of a metric, one or more filters and optionally, one or more [Metrics Operators](https://help.sumologic.com/?cid=10144).
        :param builtins.str query_type: The type of the query, either `Metrics` or `Logs`.
        :param builtins.str metrics_query_mode: Will ONLY be specified for metrics queries. The provider only supports `Advanced` as metrics query mode.
        """
        pulumi.set(__self__, "query_key", query_key)
        pulumi.set(__self__, "query_string", query_string)
        pulumi.set(__self__, "query_type", query_type)
        if metrics_query_mode is not None:
            pulumi.set(__self__, "metrics_query_mode", metrics_query_mode)

    @property
    @pulumi.getter(name="queryKey")
    def query_key(self) -> builtins.str:
        """
        Key for the query row, A to Z letter.
        """
        return pulumi.get(self, "query_key")

    @property
    @pulumi.getter(name="queryString")
    def query_string(self) -> builtins.str:
        """
        A metric query consists of a metric, one or more filters and optionally, one or more [Metrics Operators](https://help.sumologic.com/?cid=10144).
        """
        return pulumi.get(self, "query_string")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> builtins.str:
        """
        The type of the query, either `Metrics` or `Logs`.
        """
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter(name="metricsQueryMode")
    def metrics_query_mode(self) -> Optional[builtins.str]:
        """
        Will ONLY be specified for metrics queries. The provider only supports `Advanced` as metrics query mode.
        """
        return pulumi.get(self, "metrics_query_mode")


@pulumi.output_type
class MetricsSearchV2TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "beginBoundedTimeRange":
            suggest = "begin_bounded_time_range"
        elif key == "completeLiteralTimeRange":
            suggest = "complete_literal_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 begin_bounded_time_range: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRange'] = None,
                 complete_literal_time_range: Optional['outputs.MetricsSearchV2TimeRangeCompleteLiteralTimeRange'] = None):
        """
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeArgs' begin_bounded_time_range: Bounded time range. See
               begin_bounded_time_range schema schema for details.
        :param 'MetricsSearchV2TimeRangeCompleteLiteralTimeRangeArgs' complete_literal_time_range: Literal time range. See
               complete_literal_time_range schema for details.
        """
        if begin_bounded_time_range is not None:
            pulumi.set(__self__, "begin_bounded_time_range", begin_bounded_time_range)
        if complete_literal_time_range is not None:
            pulumi.set(__self__, "complete_literal_time_range", complete_literal_time_range)

    @property
    @pulumi.getter(name="beginBoundedTimeRange")
    def begin_bounded_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRange']:
        """
        Bounded time range. See
        begin_bounded_time_range schema schema for details.
        """
        return pulumi.get(self, "begin_bounded_time_range")

    @property
    @pulumi.getter(name="completeLiteralTimeRange")
    def complete_literal_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeCompleteLiteralTimeRange']:
        """
        Literal time range. See
        complete_literal_time_range schema for details.
        """
        return pulumi.get(self, "complete_literal_time_range")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "from":
            suggest = "from_"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 from_: 'outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFrom',
                 to: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeTo'] = None):
        """
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromArgs' from_: Start boundary of bounded time range. See
               time_range_boundary schema for details.
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeToArgs' to: End boundary of bounded time range. See
               time_range_boundary schema for details.
        """
        pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)

    @property
    @pulumi.getter(name="from")
    def from_(self) -> 'outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFrom':
        """
        Start boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "from_")

    @property
    @pulumi.getter
    def to(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeTo']:
        """
        End boundary of bounded time range. See
        time_range_boundary schema for details.
        """
        return pulumi.get(self, "to")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeFrom(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeFrom. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFrom.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromRelativeTimeRange'] = None):
        """
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromEpochTimeRangeArgs' epoch_time_range: Time since the epoch.
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromIso8601TimeRangeArgs' iso8601_time_range: Time in ISO 8601 format.
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromLiteralTimeRangeArgs' literal_time_range: Time in literal format.
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromRelativeTimeRangeArgs' relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromEpochTimeRange']:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromIso8601TimeRange']:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromLiteralTimeRange']:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromRelativeTimeRange']:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        """
        :param builtins.int epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        """
        :param builtins.str iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeFromRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        """
        :param builtins.str relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeTo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochTimeRange":
            suggest = "epoch_time_range"
        elif key == "iso8601TimeRange":
            suggest = "iso8601_time_range"
        elif key == "literalTimeRange":
            suggest = "literal_time_range"
        elif key == "relativeTimeRange":
            suggest = "relative_time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeTo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeTo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_time_range: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeToEpochTimeRange'] = None,
                 iso8601_time_range: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeToIso8601TimeRange'] = None,
                 literal_time_range: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeToLiteralTimeRange'] = None,
                 relative_time_range: Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeToRelativeTimeRange'] = None):
        """
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeToEpochTimeRangeArgs' epoch_time_range: Time since the epoch.
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeToIso8601TimeRangeArgs' iso8601_time_range: Time in ISO 8601 format.
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeToLiteralTimeRangeArgs' literal_time_range: Time in literal format.
        :param 'MetricsSearchV2TimeRangeBeginBoundedTimeRangeToRelativeTimeRangeArgs' relative_time_range: Time in relative format.
        """
        if epoch_time_range is not None:
            pulumi.set(__self__, "epoch_time_range", epoch_time_range)
        if iso8601_time_range is not None:
            pulumi.set(__self__, "iso8601_time_range", iso8601_time_range)
        if literal_time_range is not None:
            pulumi.set(__self__, "literal_time_range", literal_time_range)
        if relative_time_range is not None:
            pulumi.set(__self__, "relative_time_range", relative_time_range)

    @property
    @pulumi.getter(name="epochTimeRange")
    def epoch_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeToEpochTimeRange']:
        """
        Time since the epoch.
        """
        return pulumi.get(self, "epoch_time_range")

    @property
    @pulumi.getter(name="iso8601TimeRange")
    def iso8601_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeToIso8601TimeRange']:
        """
        Time in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time_range")

    @property
    @pulumi.getter(name="literalTimeRange")
    def literal_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeToLiteralTimeRange']:
        """
        Time in literal format.
        """
        return pulumi.get(self, "literal_time_range")

    @property
    @pulumi.getter(name="relativeTimeRange")
    def relative_time_range(self) -> Optional['outputs.MetricsSearchV2TimeRangeBeginBoundedTimeRangeToRelativeTimeRange']:
        """
        Time in relative format.
        """
        return pulumi.get(self, "relative_time_range")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeToEpochTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "epochMillis":
            suggest = "epoch_millis"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeToEpochTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeToEpochTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 epoch_millis: builtins.int):
        """
        :param builtins.int epoch_millis: Time as a number of milliseconds since the epoch.
        """
        pulumi.set(__self__, "epoch_millis", epoch_millis)

    @property
    @pulumi.getter(name="epochMillis")
    def epoch_millis(self) -> builtins.int:
        """
        Time as a number of milliseconds since the epoch.
        """
        return pulumi.get(self, "epoch_millis")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeToIso8601TimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "iso8601Time":
            suggest = "iso8601_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeToIso8601TimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeToIso8601TimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 iso8601_time: builtins.str):
        """
        :param builtins.str iso8601_time: Time as a string in ISO 8601 format.
        """
        pulumi.set(__self__, "iso8601_time", iso8601_time)

    @property
    @pulumi.getter(name="iso8601Time")
    def iso8601_time(self) -> builtins.str:
        """
        Time as a string in ISO 8601 format.
        """
        return pulumi.get(self, "iso8601_time")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeToLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeToLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeToLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class MetricsSearchV2TimeRangeBeginBoundedTimeRangeToRelativeTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "relativeTime":
            suggest = "relative_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeBeginBoundedTimeRangeToRelativeTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeBeginBoundedTimeRangeToRelativeTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 relative_time: builtins.str):
        """
        :param builtins.str relative_time: Relative time as a string consisting of following elements:
               1. `-` (optional): minus sign indicates time in the past,
               2. `<number>`: number of time units,
               3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).
               
               Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
               `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        pulumi.set(__self__, "relative_time", relative_time)

    @property
    @pulumi.getter(name="relativeTime")
    def relative_time(self) -> builtins.str:
        """
        Relative time as a string consisting of following elements:
        1. `-` (optional): minus sign indicates time in the past,
        2. `<number>`: number of time units,
        3. `<time_unit>`: time unit; possible values are: `w` (week), `d` (day), `h` (hour), `m` (minute), `s` (second).

        Multiple pairs of `<number><time_unit>` may be provided, and they may be in any order. For example,
        `-2w5d3h` points to the moment in time 2 weeks, 5 days and 3 hours ago.
        """
        return pulumi.get(self, "relative_time")


@pulumi.output_type
class MetricsSearchV2TimeRangeCompleteLiteralTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rangeName":
            suggest = "range_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MetricsSearchV2TimeRangeCompleteLiteralTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MetricsSearchV2TimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MetricsSearchV2TimeRangeCompleteLiteralTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 range_name: builtins.str):
        pulumi.set(__self__, "range_name", range_name)

    @property
    @pulumi.getter(name="rangeName")
    def range_name(self) -> builtins.str:
        return pulumi.get(self, "range_name")


@pulumi.output_type
class MonitorFolderObjPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subjectId":
            suggest = "subject_id"
        elif key == "subjectType":
            suggest = "subject_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorFolderObjPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorFolderObjPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorFolderObjPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permissions: Sequence[builtins.str],
                 subject_id: builtins.str,
                 subject_type: builtins.str):
        """
        :param Sequence[builtins.str] permissions: A Set of Permissions. Valid Permission Values: 
               - `Create`
               - `Read`
               - `Update`
               - `Delete`
               - `Manage`
               
               Additional data provided in state:
        :param builtins.str subject_id: A Role ID or the Org ID of the account
        :param builtins.str subject_type: Valid values:
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "subject_id", subject_id)
        pulumi.set(__self__, "subject_type", subject_type)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[builtins.str]:
        """
        A Set of Permissions. Valid Permission Values: 
        - `Create`
        - `Read`
        - `Update`
        - `Delete`
        - `Manage`

        Additional data provided in state:
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="subjectId")
    def subject_id(self) -> builtins.str:
        """
        A Role ID or the Org ID of the account
        """
        return pulumi.get(self, "subject_id")

    @property
    @pulumi.getter(name="subjectType")
    def subject_type(self) -> builtins.str:
        """
        Valid values:
        """
        return pulumi.get(self, "subject_type")


@pulumi.output_type
class MonitorNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "runForTriggerTypes":
            suggest = "run_for_trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 notification: 'outputs.MonitorNotificationNotification',
                 run_for_trigger_types: Sequence[builtins.str]):
        pulumi.set(__self__, "notification", notification)
        pulumi.set(__self__, "run_for_trigger_types", run_for_trigger_types)

    @property
    @pulumi.getter
    def notification(self) -> 'outputs.MonitorNotificationNotification':
        return pulumi.get(self, "notification")

    @property
    @pulumi.getter(name="runForTriggerTypes")
    def run_for_trigger_types(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "run_for_trigger_types")


@pulumi.output_type
class MonitorNotificationNotification(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actionType":
            suggest = "action_type"
        elif key == "connectionId":
            suggest = "connection_id"
        elif key == "connectionType":
            suggest = "connection_type"
        elif key == "messageBody":
            suggest = "message_body"
        elif key == "payloadOverride":
            suggest = "payload_override"
        elif key == "resolutionPayloadOverride":
            suggest = "resolution_payload_override"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorNotificationNotification. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorNotificationNotification.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorNotificationNotification.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 action_type: Optional[builtins.str] = None,
                 connection_id: Optional[builtins.str] = None,
                 connection_type: Optional[builtins.str] = None,
                 message_body: Optional[builtins.str] = None,
                 payload_override: Optional[builtins.str] = None,
                 recipients: Optional[Sequence[builtins.str]] = None,
                 resolution_payload_override: Optional[builtins.str] = None,
                 subject: Optional[builtins.str] = None,
                 time_zone: Optional[builtins.str] = None):
        if action_type is not None:
            pulumi.set(__self__, "action_type", action_type)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if message_body is not None:
            pulumi.set(__self__, "message_body", message_body)
        if payload_override is not None:
            pulumi.set(__self__, "payload_override", payload_override)
        if recipients is not None:
            pulumi.set(__self__, "recipients", recipients)
        if resolution_payload_override is not None:
            pulumi.set(__self__, "resolution_payload_override", resolution_payload_override)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @property
    @pulumi.getter(name="actionType")
    @_utilities.deprecated("""The field `action_type` is deprecated and will be removed in a future release of the provider - please use `connection_type` instead.""")
    def action_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "action_type")

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "connection_id")

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "connection_type")

    @property
    @pulumi.getter(name="messageBody")
    def message_body(self) -> Optional[builtins.str]:
        return pulumi.get(self, "message_body")

    @property
    @pulumi.getter(name="payloadOverride")
    def payload_override(self) -> Optional[builtins.str]:
        return pulumi.get(self, "payload_override")

    @property
    @pulumi.getter
    def recipients(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "recipients")

    @property
    @pulumi.getter(name="resolutionPayloadOverride")
    def resolution_payload_override(self) -> Optional[builtins.str]:
        return pulumi.get(self, "resolution_payload_override")

    @property
    @pulumi.getter
    def subject(self) -> Optional[builtins.str]:
        return pulumi.get(self, "subject")

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[builtins.str]:
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class MonitorObjPermission(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "subjectId":
            suggest = "subject_id"
        elif key == "subjectType":
            suggest = "subject_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorObjPermission. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorObjPermission.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorObjPermission.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 permissions: Sequence[builtins.str],
                 subject_id: builtins.str,
                 subject_type: builtins.str):
        """
        :param Sequence[builtins.str] permissions: A Set of Permissions. Valid Permission Values:
               - `Read`
               - `Update`
               - `Delete`
               - `Manage`
               
               Additional data provided in state:
        :param builtins.str subject_id: A Role ID or the Org ID of the account
        :param builtins.str subject_type: Valid values:
        """
        pulumi.set(__self__, "permissions", permissions)
        pulumi.set(__self__, "subject_id", subject_id)
        pulumi.set(__self__, "subject_type", subject_type)

    @property
    @pulumi.getter
    def permissions(self) -> Sequence[builtins.str]:
        """
        A Set of Permissions. Valid Permission Values:
        - `Read`
        - `Update`
        - `Delete`
        - `Manage`

        Additional data provided in state:
        """
        return pulumi.get(self, "permissions")

    @property
    @pulumi.getter(name="subjectId")
    def subject_id(self) -> builtins.str:
        """
        A Role ID or the Org ID of the account
        """
        return pulumi.get(self, "subject_id")

    @property
    @pulumi.getter(name="subjectType")
    def subject_type(self) -> builtins.str:
        """
        Valid values:
        """
        return pulumi.get(self, "subject_type")


@pulumi.output_type
class MonitorQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowId":
            suggest = "row_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: builtins.str,
                 row_id: builtins.str):
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)

    @property
    @pulumi.getter
    def query(self) -> builtins.str:
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> builtins.str:
        return pulumi.get(self, "row_id")


@pulumi.output_type
class MonitorTrigger(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"
        elif key == "detectionMethod":
            suggest = "detection_method"
        elif key == "minDataPoints":
            suggest = "min_data_points"
        elif key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "resolutionWindow":
            suggest = "resolution_window"
        elif key == "thresholdType":
            suggest = "threshold_type"
        elif key == "triggerSource":
            suggest = "trigger_source"
        elif key == "triggerType":
            suggest = "trigger_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTrigger. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTrigger.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTrigger.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_range: builtins.str,
                 detection_method: Optional[builtins.str] = None,
                 frequency: Optional[builtins.str] = None,
                 min_data_points: Optional[builtins.int] = None,
                 occurrence_type: Optional[builtins.str] = None,
                 resolution_window: Optional[builtins.str] = None,
                 threshold: Optional[builtins.float] = None,
                 threshold_type: Optional[builtins.str] = None,
                 trigger_source: Optional[builtins.str] = None,
                 trigger_type: Optional[builtins.str] = None):
        """
        :param builtins.str resolution_window: The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        pulumi.set(__self__, "time_range", time_range)
        if detection_method is not None:
            pulumi.set(__self__, "detection_method", detection_method)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if resolution_window is not None:
            pulumi.set(__self__, "resolution_window", resolution_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)
        if trigger_source is not None:
            pulumi.set(__self__, "trigger_source", trigger_source)
        if trigger_type is not None:
            pulumi.set(__self__, "trigger_type", trigger_type)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter(name="detectionMethod")
    def detection_method(self) -> Optional[builtins.str]:
        return pulumi.get(self, "detection_method")

    @property
    @pulumi.getter
    def frequency(self) -> Optional[builtins.str]:
        return pulumi.get(self, "frequency")

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[builtins.int]:
        return pulumi.get(self, "min_data_points")

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter(name="resolutionWindow")
    def resolution_window(self) -> Optional[builtins.str]:
        """
        The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        return pulumi.get(self, "resolution_window")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "threshold_type")

    @property
    @pulumi.getter(name="triggerSource")
    def trigger_source(self) -> Optional[builtins.str]:
        return pulumi.get(self, "trigger_source")

    @property
    @pulumi.getter(name="triggerType")
    def trigger_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "trigger_type")


@pulumi.output_type
class MonitorTriggerConditions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logsAnomalyCondition":
            suggest = "logs_anomaly_condition"
        elif key == "logsMissingDataCondition":
            suggest = "logs_missing_data_condition"
        elif key == "logsOutlierCondition":
            suggest = "logs_outlier_condition"
        elif key == "logsStaticCondition":
            suggest = "logs_static_condition"
        elif key == "metricsAnomalyCondition":
            suggest = "metrics_anomaly_condition"
        elif key == "metricsMissingDataCondition":
            suggest = "metrics_missing_data_condition"
        elif key == "metricsOutlierCondition":
            suggest = "metrics_outlier_condition"
        elif key == "metricsStaticCondition":
            suggest = "metrics_static_condition"
        elif key == "sloBurnRateCondition":
            suggest = "slo_burn_rate_condition"
        elif key == "sloSliCondition":
            suggest = "slo_sli_condition"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 logs_anomaly_condition: Optional['outputs.MonitorTriggerConditionsLogsAnomalyCondition'] = None,
                 logs_missing_data_condition: Optional['outputs.MonitorTriggerConditionsLogsMissingDataCondition'] = None,
                 logs_outlier_condition: Optional['outputs.MonitorTriggerConditionsLogsOutlierCondition'] = None,
                 logs_static_condition: Optional['outputs.MonitorTriggerConditionsLogsStaticCondition'] = None,
                 metrics_anomaly_condition: Optional['outputs.MonitorTriggerConditionsMetricsAnomalyCondition'] = None,
                 metrics_missing_data_condition: Optional['outputs.MonitorTriggerConditionsMetricsMissingDataCondition'] = None,
                 metrics_outlier_condition: Optional['outputs.MonitorTriggerConditionsMetricsOutlierCondition'] = None,
                 metrics_static_condition: Optional['outputs.MonitorTriggerConditionsMetricsStaticCondition'] = None,
                 slo_burn_rate_condition: Optional['outputs.MonitorTriggerConditionsSloBurnRateCondition'] = None,
                 slo_sli_condition: Optional['outputs.MonitorTriggerConditionsSloSliCondition'] = None):
        if logs_anomaly_condition is not None:
            pulumi.set(__self__, "logs_anomaly_condition", logs_anomaly_condition)
        if logs_missing_data_condition is not None:
            pulumi.set(__self__, "logs_missing_data_condition", logs_missing_data_condition)
        if logs_outlier_condition is not None:
            pulumi.set(__self__, "logs_outlier_condition", logs_outlier_condition)
        if logs_static_condition is not None:
            pulumi.set(__self__, "logs_static_condition", logs_static_condition)
        if metrics_anomaly_condition is not None:
            pulumi.set(__self__, "metrics_anomaly_condition", metrics_anomaly_condition)
        if metrics_missing_data_condition is not None:
            pulumi.set(__self__, "metrics_missing_data_condition", metrics_missing_data_condition)
        if metrics_outlier_condition is not None:
            pulumi.set(__self__, "metrics_outlier_condition", metrics_outlier_condition)
        if metrics_static_condition is not None:
            pulumi.set(__self__, "metrics_static_condition", metrics_static_condition)
        if slo_burn_rate_condition is not None:
            pulumi.set(__self__, "slo_burn_rate_condition", slo_burn_rate_condition)
        if slo_sli_condition is not None:
            pulumi.set(__self__, "slo_sli_condition", slo_sli_condition)

    @property
    @pulumi.getter(name="logsAnomalyCondition")
    def logs_anomaly_condition(self) -> Optional['outputs.MonitorTriggerConditionsLogsAnomalyCondition']:
        return pulumi.get(self, "logs_anomaly_condition")

    @property
    @pulumi.getter(name="logsMissingDataCondition")
    def logs_missing_data_condition(self) -> Optional['outputs.MonitorTriggerConditionsLogsMissingDataCondition']:
        return pulumi.get(self, "logs_missing_data_condition")

    @property
    @pulumi.getter(name="logsOutlierCondition")
    def logs_outlier_condition(self) -> Optional['outputs.MonitorTriggerConditionsLogsOutlierCondition']:
        return pulumi.get(self, "logs_outlier_condition")

    @property
    @pulumi.getter(name="logsStaticCondition")
    def logs_static_condition(self) -> Optional['outputs.MonitorTriggerConditionsLogsStaticCondition']:
        return pulumi.get(self, "logs_static_condition")

    @property
    @pulumi.getter(name="metricsAnomalyCondition")
    def metrics_anomaly_condition(self) -> Optional['outputs.MonitorTriggerConditionsMetricsAnomalyCondition']:
        return pulumi.get(self, "metrics_anomaly_condition")

    @property
    @pulumi.getter(name="metricsMissingDataCondition")
    def metrics_missing_data_condition(self) -> Optional['outputs.MonitorTriggerConditionsMetricsMissingDataCondition']:
        return pulumi.get(self, "metrics_missing_data_condition")

    @property
    @pulumi.getter(name="metricsOutlierCondition")
    def metrics_outlier_condition(self) -> Optional['outputs.MonitorTriggerConditionsMetricsOutlierCondition']:
        return pulumi.get(self, "metrics_outlier_condition")

    @property
    @pulumi.getter(name="metricsStaticCondition")
    def metrics_static_condition(self) -> Optional['outputs.MonitorTriggerConditionsMetricsStaticCondition']:
        return pulumi.get(self, "metrics_static_condition")

    @property
    @pulumi.getter(name="sloBurnRateCondition")
    def slo_burn_rate_condition(self) -> Optional['outputs.MonitorTriggerConditionsSloBurnRateCondition']:
        return pulumi.get(self, "slo_burn_rate_condition")

    @property
    @pulumi.getter(name="sloSliCondition")
    def slo_sli_condition(self) -> Optional['outputs.MonitorTriggerConditionsSloSliCondition']:
        return pulumi.get(self, "slo_sli_condition")


@pulumi.output_type
class MonitorTriggerConditionsLogsAnomalyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anomalyDetectorType":
            suggest = "anomaly_detector_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsAnomalyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsAnomalyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsAnomalyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anomaly_detector_type: builtins.str,
                 critical: 'outputs.MonitorTriggerConditionsLogsAnomalyConditionCritical',
                 field: builtins.str,
                 direction: Optional[builtins.str] = None):
        pulumi.set(__self__, "anomaly_detector_type", anomaly_detector_type)
        pulumi.set(__self__, "critical", critical)
        pulumi.set(__self__, "field", field)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter(name="anomalyDetectorType")
    def anomaly_detector_type(self) -> builtins.str:
        return pulumi.get(self, "anomaly_detector_type")

    @property
    @pulumi.getter
    def critical(self) -> 'outputs.MonitorTriggerConditionsLogsAnomalyConditionCritical':
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def field(self) -> builtins.str:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def direction(self) -> Optional[builtins.str]:
        return pulumi.get(self, "direction")


@pulumi.output_type
class MonitorTriggerConditionsLogsAnomalyConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"
        elif key == "minAnomalyCount":
            suggest = "min_anomaly_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsAnomalyConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsAnomalyConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsAnomalyConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_range: builtins.str,
                 min_anomaly_count: Optional[builtins.int] = None,
                 sensitivity: Optional[builtins.float] = None):
        pulumi.set(__self__, "time_range", time_range)
        if min_anomaly_count is not None:
            pulumi.set(__self__, "min_anomaly_count", min_anomaly_count)
        if sensitivity is not None:
            pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter(name="minAnomalyCount")
    def min_anomaly_count(self) -> Optional[builtins.int]:
        return pulumi.get(self, "min_anomaly_count")

    @property
    @pulumi.getter
    def sensitivity(self) -> Optional[builtins.float]:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class MonitorTriggerConditionsLogsMissingDataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsMissingDataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsMissingDataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsMissingDataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_range: builtins.str,
                 frequency: Optional[builtins.str] = None):
        pulumi.set(__self__, "time_range", time_range)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter
    def frequency(self) -> Optional[builtins.str]:
        return pulumi.get(self, "frequency")


@pulumi.output_type
class MonitorTriggerConditionsLogsOutlierCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsLogsOutlierConditionCritical'] = None,
                 direction: Optional[builtins.str] = None,
                 field: Optional[builtins.str] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsLogsOutlierConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsLogsOutlierConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def direction(self) -> Optional[builtins.str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def field(self) -> Optional[builtins.str]:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsLogsOutlierConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsLogsOutlierConditionCritical(dict):
    def __init__(__self__, *,
                 consecutive: Optional[builtins.int] = None,
                 threshold: Optional[builtins.float] = None,
                 window: Optional[builtins.int] = None):
        if consecutive is not None:
            pulumi.set(__self__, "consecutive", consecutive)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def consecutive(self) -> Optional[builtins.int]:
        return pulumi.get(self, "consecutive")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def window(self) -> Optional[builtins.int]:
        return pulumi.get(self, "window")


@pulumi.output_type
class MonitorTriggerConditionsLogsOutlierConditionWarning(dict):
    def __init__(__self__, *,
                 consecutive: Optional[builtins.int] = None,
                 threshold: Optional[builtins.float] = None,
                 window: Optional[builtins.int] = None):
        if consecutive is not None:
            pulumi.set(__self__, "consecutive", consecutive)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if window is not None:
            pulumi.set(__self__, "window", window)

    @property
    @pulumi.getter
    def consecutive(self) -> Optional[builtins.int]:
        return pulumi.get(self, "consecutive")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def window(self) -> Optional[builtins.int]:
        return pulumi.get(self, "window")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsLogsStaticConditionCritical'] = None,
                 field: Optional[builtins.str] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsLogsStaticConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsLogsStaticConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def field(self) -> Optional[builtins.str]:
        return pulumi.get(self, "field")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsLogsStaticConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert: 'outputs.MonitorTriggerConditionsLogsStaticConditionCriticalAlert',
                 resolution: 'outputs.MonitorTriggerConditionsLogsStaticConditionCriticalResolution',
                 time_range: builtins.str,
                 frequency: Optional[builtins.str] = None):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)

    @property
    @pulumi.getter
    def alert(self) -> 'outputs.MonitorTriggerConditionsLogsStaticConditionCriticalAlert':
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter
    def resolution(self) -> 'outputs.MonitorTriggerConditionsLogsStaticConditionCriticalResolution':
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter
    def frequency(self) -> Optional[builtins.str]:
        return pulumi.get(self, "frequency")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionCriticalAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionCriticalAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCriticalAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCriticalAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold: Optional[builtins.float] = None,
                 threshold_type: Optional[builtins.str] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionCriticalResolution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resolutionWindow":
            suggest = "resolution_window"
        elif key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionCriticalResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCriticalResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionCriticalResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resolution_window: Optional[builtins.str] = None,
                 threshold: Optional[builtins.float] = None,
                 threshold_type: Optional[builtins.str] = None):
        """
        :param builtins.str resolution_window: The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        if resolution_window is not None:
            pulumi.set(__self__, "resolution_window", resolution_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="resolutionWindow")
    def resolution_window(self) -> Optional[builtins.str]:
        """
        The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        return pulumi.get(self, "resolution_window")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert: 'outputs.MonitorTriggerConditionsLogsStaticConditionWarningAlert',
                 resolution: 'outputs.MonitorTriggerConditionsLogsStaticConditionWarningResolution',
                 time_range: builtins.str,
                 frequency: Optional[builtins.str] = None):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)

    @property
    @pulumi.getter
    def alert(self) -> 'outputs.MonitorTriggerConditionsLogsStaticConditionWarningAlert':
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter
    def resolution(self) -> 'outputs.MonitorTriggerConditionsLogsStaticConditionWarningResolution':
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter
    def frequency(self) -> Optional[builtins.str]:
        return pulumi.get(self, "frequency")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionWarningAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionWarningAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarningAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarningAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 threshold: Optional[builtins.float] = None,
                 threshold_type: Optional[builtins.str] = None):
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsLogsStaticConditionWarningResolution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resolutionWindow":
            suggest = "resolution_window"
        elif key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsLogsStaticConditionWarningResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarningResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsLogsStaticConditionWarningResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resolution_window: Optional[builtins.str] = None,
                 threshold: Optional[builtins.float] = None,
                 threshold_type: Optional[builtins.str] = None):
        """
        :param builtins.str resolution_window: The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        if resolution_window is not None:
            pulumi.set(__self__, "resolution_window", resolution_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="resolutionWindow")
    def resolution_window(self) -> Optional[builtins.str]:
        """
        The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
        """
        return pulumi.get(self, "resolution_window")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsMetricsAnomalyCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "anomalyDetectorType":
            suggest = "anomaly_detector_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsAnomalyCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsAnomalyCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsAnomalyCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 anomaly_detector_type: builtins.str,
                 critical: 'outputs.MonitorTriggerConditionsMetricsAnomalyConditionCritical',
                 direction: Optional[builtins.str] = None):
        pulumi.set(__self__, "anomaly_detector_type", anomaly_detector_type)
        pulumi.set(__self__, "critical", critical)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter(name="anomalyDetectorType")
    def anomaly_detector_type(self) -> builtins.str:
        return pulumi.get(self, "anomaly_detector_type")

    @property
    @pulumi.getter
    def critical(self) -> 'outputs.MonitorTriggerConditionsMetricsAnomalyConditionCritical':
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def direction(self) -> Optional[builtins.str]:
        return pulumi.get(self, "direction")


@pulumi.output_type
class MonitorTriggerConditionsMetricsAnomalyConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"
        elif key == "minAnomalyCount":
            suggest = "min_anomaly_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsAnomalyConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsAnomalyConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsAnomalyConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_range: builtins.str,
                 min_anomaly_count: Optional[builtins.int] = None,
                 sensitivity: Optional[builtins.float] = None):
        pulumi.set(__self__, "time_range", time_range)
        if min_anomaly_count is not None:
            pulumi.set(__self__, "min_anomaly_count", min_anomaly_count)
        if sensitivity is not None:
            pulumi.set(__self__, "sensitivity", sensitivity)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter(name="minAnomalyCount")
    def min_anomaly_count(self) -> Optional[builtins.int]:
        return pulumi.get(self, "min_anomaly_count")

    @property
    @pulumi.getter
    def sensitivity(self) -> Optional[builtins.float]:
        return pulumi.get(self, "sensitivity")


@pulumi.output_type
class MonitorTriggerConditionsMetricsMissingDataCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeRange":
            suggest = "time_range"
        elif key == "triggerSource":
            suggest = "trigger_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsMissingDataCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsMissingDataCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsMissingDataCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_range: builtins.str,
                 trigger_source: builtins.str):
        pulumi.set(__self__, "time_range", time_range)
        pulumi.set(__self__, "trigger_source", trigger_source)

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")

    @property
    @pulumi.getter(name="triggerSource")
    def trigger_source(self) -> builtins.str:
        return pulumi.get(self, "trigger_source")


@pulumi.output_type
class MonitorTriggerConditionsMetricsOutlierCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsMetricsOutlierConditionCritical'] = None,
                 direction: Optional[builtins.str] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsMetricsOutlierConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsMetricsOutlierConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def direction(self) -> Optional[builtins.str]:
        return pulumi.get(self, "direction")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsMetricsOutlierConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsMetricsOutlierConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineWindow":
            suggest = "baseline_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsOutlierConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsOutlierConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsOutlierConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_window: Optional[builtins.str] = None,
                 threshold: Optional[builtins.float] = None):
        if baseline_window is not None:
            pulumi.set(__self__, "baseline_window", baseline_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="baselineWindow")
    def baseline_window(self) -> Optional[builtins.str]:
        return pulumi.get(self, "baseline_window")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class MonitorTriggerConditionsMetricsOutlierConditionWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baselineWindow":
            suggest = "baseline_window"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsOutlierConditionWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsOutlierConditionWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsOutlierConditionWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 baseline_window: Optional[builtins.str] = None,
                 threshold: Optional[builtins.float] = None):
        if baseline_window is not None:
            pulumi.set(__self__, "baseline_window", baseline_window)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter(name="baselineWindow")
    def baseline_window(self) -> Optional[builtins.str]:
        return pulumi.get(self, "baseline_window")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsMetricsStaticConditionCritical'] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsMetricsStaticConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsMetricsStaticConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsMetricsStaticConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert: 'outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalAlert',
                 occurrence_type: builtins.str,
                 resolution: 'outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalResolution',
                 time_range: builtins.str):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "occurrence_type", occurrence_type)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> 'outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalAlert':
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> builtins.str:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def resolution(self) -> 'outputs.MonitorTriggerConditionsMetricsStaticConditionCriticalResolution':
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionCriticalAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minDataPoints":
            suggest = "min_data_points"
        elif key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionCriticalAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCriticalAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCriticalAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_data_points: Optional[builtins.int] = None,
                 threshold: Optional[builtins.float] = None,
                 threshold_type: Optional[builtins.str] = None):
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[builtins.int]:
        return pulumi.get(self, "min_data_points")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionCriticalResolution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minDataPoints":
            suggest = "min_data_points"
        elif key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionCriticalResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCriticalResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionCriticalResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_data_points: Optional[builtins.int] = None,
                 occurrence_type: Optional[builtins.str] = None,
                 threshold: Optional[builtins.float] = None,
                 threshold_type: Optional[builtins.str] = None):
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[builtins.int]:
        return pulumi.get(self, "min_data_points")

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alert: 'outputs.MonitorTriggerConditionsMetricsStaticConditionWarningAlert',
                 occurrence_type: builtins.str,
                 resolution: 'outputs.MonitorTriggerConditionsMetricsStaticConditionWarningResolution',
                 time_range: builtins.str):
        pulumi.set(__self__, "alert", alert)
        pulumi.set(__self__, "occurrence_type", occurrence_type)
        pulumi.set(__self__, "resolution", resolution)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter
    def alert(self) -> 'outputs.MonitorTriggerConditionsMetricsStaticConditionWarningAlert':
        return pulumi.get(self, "alert")

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> builtins.str:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def resolution(self) -> 'outputs.MonitorTriggerConditionsMetricsStaticConditionWarningResolution':
        return pulumi.get(self, "resolution")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionWarningAlert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minDataPoints":
            suggest = "min_data_points"
        elif key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionWarningAlert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarningAlert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarningAlert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_data_points: Optional[builtins.int] = None,
                 threshold: Optional[builtins.float] = None,
                 threshold_type: Optional[builtins.str] = None):
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[builtins.int]:
        return pulumi.get(self, "min_data_points")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsMetricsStaticConditionWarningResolution(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "minDataPoints":
            suggest = "min_data_points"
        elif key == "occurrenceType":
            suggest = "occurrence_type"
        elif key == "thresholdType":
            suggest = "threshold_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsMetricsStaticConditionWarningResolution. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarningResolution.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsMetricsStaticConditionWarningResolution.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 min_data_points: Optional[builtins.int] = None,
                 occurrence_type: Optional[builtins.str] = None,
                 threshold: Optional[builtins.float] = None,
                 threshold_type: Optional[builtins.str] = None):
        if min_data_points is not None:
            pulumi.set(__self__, "min_data_points", min_data_points)
        if occurrence_type is not None:
            pulumi.set(__self__, "occurrence_type", occurrence_type)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)
        if threshold_type is not None:
            pulumi.set(__self__, "threshold_type", threshold_type)

    @property
    @pulumi.getter(name="minDataPoints")
    def min_data_points(self) -> Optional[builtins.int]:
        return pulumi.get(self, "min_data_points")

    @property
    @pulumi.getter(name="occurrenceType")
    def occurrence_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "occurrence_type")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter(name="thresholdType")
    def threshold_type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "threshold_type")


@pulumi.output_type
class MonitorTriggerConditionsSloBurnRateCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsSloBurnRateConditionCritical'] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsSloBurnRateConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsSloBurnRateConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsSloBurnRateConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsSloBurnRateConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateThreshold":
            suggest = "burn_rate_threshold"
        elif key == "burnRates":
            suggest = "burn_rates"
        elif key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsSloBurnRateConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsSloBurnRateConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsSloBurnRateConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burn_rate_threshold: Optional[builtins.float] = None,
                 burn_rates: Optional[Sequence['outputs.MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRate']] = None,
                 time_range: Optional[builtins.str] = None):
        if burn_rate_threshold is not None:
            pulumi.set(__self__, "burn_rate_threshold", burn_rate_threshold)
        if burn_rates is not None:
            pulumi.set(__self__, "burn_rates", burn_rates)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="burnRateThreshold")
    def burn_rate_threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "burn_rate_threshold")

    @property
    @pulumi.getter(name="burnRates")
    def burn_rates(self) -> Optional[Sequence['outputs.MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRate']]:
        return pulumi.get(self, "burn_rates")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[builtins.str]:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateThreshold":
            suggest = "burn_rate_threshold"
        elif key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burn_rate_threshold: builtins.float,
                 time_range: builtins.str):
        pulumi.set(__self__, "burn_rate_threshold", burn_rate_threshold)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="burnRateThreshold")
    def burn_rate_threshold(self) -> builtins.float:
        return pulumi.get(self, "burn_rate_threshold")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsSloBurnRateConditionWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateThreshold":
            suggest = "burn_rate_threshold"
        elif key == "burnRates":
            suggest = "burn_rates"
        elif key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsSloBurnRateConditionWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsSloBurnRateConditionWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsSloBurnRateConditionWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burn_rate_threshold: Optional[builtins.float] = None,
                 burn_rates: Optional[Sequence['outputs.MonitorTriggerConditionsSloBurnRateConditionWarningBurnRate']] = None,
                 time_range: Optional[builtins.str] = None):
        if burn_rate_threshold is not None:
            pulumi.set(__self__, "burn_rate_threshold", burn_rate_threshold)
        if burn_rates is not None:
            pulumi.set(__self__, "burn_rates", burn_rates)
        if time_range is not None:
            pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="burnRateThreshold")
    def burn_rate_threshold(self) -> Optional[builtins.float]:
        return pulumi.get(self, "burn_rate_threshold")

    @property
    @pulumi.getter(name="burnRates")
    def burn_rates(self) -> Optional[Sequence['outputs.MonitorTriggerConditionsSloBurnRateConditionWarningBurnRate']]:
        return pulumi.get(self, "burn_rates")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> Optional[builtins.str]:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsSloBurnRateConditionWarningBurnRate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "burnRateThreshold":
            suggest = "burn_rate_threshold"
        elif key == "timeRange":
            suggest = "time_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsSloBurnRateConditionWarningBurnRate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsSloBurnRateConditionWarningBurnRate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsSloBurnRateConditionWarningBurnRate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 burn_rate_threshold: builtins.float,
                 time_range: builtins.str):
        pulumi.set(__self__, "burn_rate_threshold", burn_rate_threshold)
        pulumi.set(__self__, "time_range", time_range)

    @property
    @pulumi.getter(name="burnRateThreshold")
    def burn_rate_threshold(self) -> builtins.float:
        return pulumi.get(self, "burn_rate_threshold")

    @property
    @pulumi.getter(name="timeRange")
    def time_range(self) -> builtins.str:
        return pulumi.get(self, "time_range")


@pulumi.output_type
class MonitorTriggerConditionsSloSliCondition(dict):
    def __init__(__self__, *,
                 critical: Optional['outputs.MonitorTriggerConditionsSloSliConditionCritical'] = None,
                 warning: Optional['outputs.MonitorTriggerConditionsSloSliConditionWarning'] = None):
        if critical is not None:
            pulumi.set(__self__, "critical", critical)
        if warning is not None:
            pulumi.set(__self__, "warning", warning)

    @property
    @pulumi.getter
    def critical(self) -> Optional['outputs.MonitorTriggerConditionsSloSliConditionCritical']:
        return pulumi.get(self, "critical")

    @property
    @pulumi.getter
    def warning(self) -> Optional['outputs.MonitorTriggerConditionsSloSliConditionWarning']:
        return pulumi.get(self, "warning")


@pulumi.output_type
class MonitorTriggerConditionsSloSliConditionCritical(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sliThreshold":
            suggest = "sli_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsSloSliConditionCritical. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsSloSliConditionCritical.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsSloSliConditionCritical.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sli_threshold: builtins.float):
        pulumi.set(__self__, "sli_threshold", sli_threshold)

    @property
    @pulumi.getter(name="sliThreshold")
    def sli_threshold(self) -> builtins.float:
        return pulumi.get(self, "sli_threshold")


@pulumi.output_type
class MonitorTriggerConditionsSloSliConditionWarning(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sliThreshold":
            suggest = "sli_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MonitorTriggerConditionsSloSliConditionWarning. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MonitorTriggerConditionsSloSliConditionWarning.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MonitorTriggerConditionsSloSliConditionWarning.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 sli_threshold: builtins.float):
        pulumi.set(__self__, "sli_threshold", sli_threshold)

    @property
    @pulumi.getter(name="sliThreshold")
    def sli_threshold(self) -> builtins.float:
        return pulumi.get(self, "sli_threshold")


@pulumi.output_type
class MutingScheduleMonitor(dict):
    def __init__(__self__, *,
                 all: Optional[builtins.bool] = None,
                 ids: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.bool all: True if the schedule applies to all monitors
        :param Sequence[builtins.str] ids: List of monitor Ids in hex. Must be empty if `all` is true.
        """
        if all is not None:
            pulumi.set(__self__, "all", all)
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @property
    @pulumi.getter
    def all(self) -> Optional[builtins.bool]:
        """
        True if the schedule applies to all monitors
        """
        return pulumi.get(self, "all")

    @property
    @pulumi.getter
    def ids(self) -> Optional[Sequence[builtins.str]]:
        """
        List of monitor Ids in hex. Must be empty if `all` is true.
        """
        return pulumi.get(self, "ids")


@pulumi.output_type
class MutingScheduleNotificationGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groupKey":
            suggest = "group_key"
        elif key == "groupValues":
            suggest = "group_values"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MutingScheduleNotificationGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MutingScheduleNotificationGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MutingScheduleNotificationGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 group_key: builtins.str,
                 group_values: Sequence[builtins.str]):
        """
        :param builtins.str group_key: Field name of an alert group defined in monitors. See [Alert Grouping](https://help.sumologic.com/docs/alerts/monitors/alert-grouping/) for more details.
        :param Sequence[builtins.str] group_values: Values of alert groups generated by monitors
               
               [1]: https://help.sumologic.com/docs/alerts/monitors/muting-schedules/
        """
        pulumi.set(__self__, "group_key", group_key)
        pulumi.set(__self__, "group_values", group_values)

    @property
    @pulumi.getter(name="groupKey")
    def group_key(self) -> builtins.str:
        """
        Field name of an alert group defined in monitors. See [Alert Grouping](https://help.sumologic.com/docs/alerts/monitors/alert-grouping/) for more details.
        """
        return pulumi.get(self, "group_key")

    @property
    @pulumi.getter(name="groupValues")
    def group_values(self) -> Sequence[builtins.str]:
        """
        Values of alert groups generated by monitors

        [1]: https://help.sumologic.com/docs/alerts/monitors/muting-schedules/
        """
        return pulumi.get(self, "group_values")


@pulumi.output_type
class MutingScheduleSchedule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startDate":
            suggest = "start_date"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in MutingScheduleSchedule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        MutingScheduleSchedule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        MutingScheduleSchedule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: builtins.int,
                 start_date: builtins.str,
                 start_time: builtins.str,
                 timezone: builtins.str,
                 rrule: Optional[builtins.str] = None):
        """
        :param builtins.int duration: Duration of the muting in minutes
        :param builtins.str start_date: Schedule start date in the format of `yyyy-mm-dd`
        :param builtins.str start_time: Schedule start time in the format of `hh:mm`
        :param builtins.str timezone: Time zone for the schedule per
               [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        :param builtins.str rrule: Recurrence Rule. See https://freetools.textmagic.com/rrule-generator for more details.
        """
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_date", start_date)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "timezone", timezone)
        if rrule is not None:
            pulumi.set(__self__, "rrule", rrule)

    @property
    @pulumi.getter
    def duration(self) -> builtins.int:
        """
        Duration of the muting in minutes
        """
        return pulumi.get(self, "duration")

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> builtins.str:
        """
        Schedule start date in the format of `yyyy-mm-dd`
        """
        return pulumi.get(self, "start_date")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> builtins.str:
        """
        Schedule start time in the format of `hh:mm`
        """
        return pulumi.get(self, "start_time")

    @property
    @pulumi.getter
    def timezone(self) -> builtins.str:
        """
        Time zone for the schedule per
        [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter
    def rrule(self) -> Optional[builtins.str]:
        """
        Recurrence Rule. See https://freetools.textmagic.com/rrule-generator for more details.
        """
        return pulumi.get(self, "rrule")


@pulumi.output_type
class PoliciesUserConcurrentSessionsLimit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxConcurrentSessions":
            suggest = "max_concurrent_sessions"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PoliciesUserConcurrentSessionsLimit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PoliciesUserConcurrentSessionsLimit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PoliciesUserConcurrentSessionsLimit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: builtins.bool,
                 max_concurrent_sessions: Optional[builtins.int] = None):
        """
        :param builtins.bool enabled: Whether the [User Concurrent Sessions Limit Policy](https://help.sumologic.com/Manage/Security/Set_a_Limit_for_User_Concurrent_Sessions) is enabled.
        :param builtins.int max_concurrent_sessions: Maximum number of concurrent sessions a user may have. Defaults to `100`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if max_concurrent_sessions is not None:
            pulumi.set(__self__, "max_concurrent_sessions", max_concurrent_sessions)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether the [User Concurrent Sessions Limit Policy](https://help.sumologic.com/Manage/Security/Set_a_Limit_for_User_Concurrent_Sessions) is enabled.
        """
        return pulumi.get(self, "enabled")

    @property
    @pulumi.getter(name="maxConcurrentSessions")
    def max_concurrent_sessions(self) -> Optional[builtins.int]:
        """
        Maximum number of concurrent sessions a user may have. Defaults to `100`.
        """
        return pulumi.get(self, "max_concurrent_sessions")


@pulumi.output_type
class PollingSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PollingSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PollingSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PollingSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`
        """
        return pulumi.get(self, "secret_key")


@pulumi.output_type
class PollingSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class PollingSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PollingSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PollingSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PollingSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class PollingSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "tagFilters":
            suggest = "tag_filters"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PollingSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PollingSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PollingSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 bucket_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 path_expression: Optional[builtins.str] = None,
                 tag_filters: Optional[Sequence['outputs.PollingSourcePathTagFilter']] = None):
        """
        :param builtins.str type: type of polling source. Can be one of `S3BucketPathExpression` or  `CloudWatchPath`
        :param builtins.str bucket_name: The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        :param Sequence[builtins.str] limit_to_namespaces: List of namespaces to limit metrics collection. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace. This is a valid parameter if using type `CloudWatchPath`.
        :param Sequence[builtins.str] limit_to_regions: List of Amazon regions to limit metricscollection. This is a valid parameter if  using type `CloudWatchPath`.
        :param builtins.str path_expression: The path to the data. This is needed if using type `S3BucketPathExpression`.
        :param Sequence['PollingSourcePathTagFilterArgs'] tag_filters: Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. This is a valid parameter if using type `CloudWatchPath` More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        pulumi.set(__self__, "type", type)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. Can be one of `S3BucketPathExpression` or  `CloudWatchPath`
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        """
        The name of the bucket. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        """
        List of namespaces to limit metrics collection. By default all namespaces are selected. Details can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#aws%C2%A0tag-filtering-namespace-support). You can also  specify custom namespace. This is a valid parameter if using type `CloudWatchPath`.
        """
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        """
        List of Amazon regions to limit metricscollection. This is a valid parameter if  using type `CloudWatchPath`.
        """
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        """
        The path to the data. This is needed if using type `S3BucketPathExpression`.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.PollingSourcePathTagFilter']]:
        """
        Tag filters allow you to filter the CloudWatch metrics you collect by the AWS tags you have assigned to your AWS resources. You can define tag filters for each supported namespace. If you do not define any tag filters, all metrics will be collected for the regions and namespaces you configured for the source above. This is a valid parameter if using type `CloudWatchPath` More info on tag filters can be found [here](https://help.sumologic.com/03Send-Data/Sources/02Sources-for-Hosted-Collectors/Amazon-Web-Services/Amazon-CloudWatch-Source-for-Metrics#about-aws-tag-filtering)
        """
        return pulumi.get(self, "tag_filters")


@pulumi.output_type
class PollingSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str namespace: Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        :param Sequence[builtins.str] tags: List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        :param builtins.str type: This value has to be set to `TagFilters`
        """
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        """
        Namespace for which you want to define the tag filters. Use  value as `All` to apply the tag filter for all namespaces.
        """
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        """
        List of key-value pairs of tag filters. Eg: `["k3=v3"]`
        """
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        This value has to be set to `TagFilters`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RoleV2SelectedView(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewName":
            suggest = "view_name"
        elif key == "viewFilter":
            suggest = "view_filter"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RoleV2SelectedView. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RoleV2SelectedView.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RoleV2SelectedView.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 view_name: builtins.str,
                 view_filter: Optional[builtins.str] = None):
        pulumi.set(__self__, "view_name", view_name)
        if view_filter is not None:
            pulumi.set(__self__, "view_filter", view_filter)

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> builtins.str:
        return pulumi.get(self, "view_name")

    @property
    @pulumi.getter(name="viewFilter")
    def view_filter(self) -> Optional[builtins.str]:
        return pulumi.get(self, "view_filter")


@pulumi.output_type
class RumSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class RumSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RumSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RumSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RumSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class RumSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"
        elif key == "applicationName":
            suggest = "application_name"
        elif key == "customTags":
            suggest = "custom_tags"
        elif key == "deploymentEnvironment":
            suggest = "deployment_environment"
        elif key == "ignoreUrls":
            suggest = "ignore_urls"
        elif key == "propagateTraceHeaderCorsUrls":
            suggest = "propagate_trace_header_cors_urls"
        elif key == "samplingRate":
            suggest = "sampling_rate"
        elif key == "selectedCountry":
            suggest = "selected_country"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RumSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RumSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RumSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_name: builtins.str,
                 application_name: Optional[builtins.str] = None,
                 custom_tags: Optional[Mapping[str, builtins.str]] = None,
                 deployment_environment: Optional[builtins.str] = None,
                 ignore_urls: Optional[Sequence[builtins.str]] = None,
                 propagate_trace_header_cors_urls: Optional[Sequence[builtins.str]] = None,
                 sampling_rate: Optional[builtins.float] = None,
                 selected_country: Optional[builtins.str] = None):
        """
        :param builtins.str service_name: Add a Service Name of a text string to show for the service name in spans (for example, "bookings-web-app").
        :param builtins.str application_name: (Recommended) Add an Application Name tag of a text string to show for the app name in spans (for example, bookings-app). This groups services in the Application Service View. If left blank, services will belong to a "default" application.
        :param Mapping[str, builtins.str] custom_tags: Defines custom tags attached to the spans. For example: "internal.version = 0.1.21"
        :param builtins.str deployment_environment: Your production, staging, or development environment name.
        :param Sequence[builtins.str] ignore_urls: Add a list of URLs not to collect trace data from. Supports regex. Make sure provided URLs are valid JavaScript flavor regexes. For example: "/^https:\\/\\/www.tracker.com\\/.*/, /^https:\\/\\/api.mydomain.com\\/log\\/.*/"
        :param Sequence[builtins.str] propagate_trace_header_cors_urls: (Recommended) Add a list of URLs or URL patterns that pass tracing context to construct traces end-to-end. Provided URLs should be valid JavaScript flavor regexes. Some examples are "/^https:\\/\\/api.mydomain.com\\/apiv3\\/.*/" and "/^https:\\/\\/www.3rdparty.com\\/.*/".
        :param builtins.float sampling_rate: Add a Probabilistic sampling rate for heavy traffic sites in a decimal value based on percentage, for example, 10% would be entered as 0.1. Supports floating values between 0.0 and 1.0, defaults to 1.0 (all data is passed).
        :param builtins.str selected_country: Specify if you want to enrich spans with the details level up to the city - if left blank, enrichment works down to the state level.
        """
        pulumi.set(__self__, "service_name", service_name)
        if application_name is not None:
            pulumi.set(__self__, "application_name", application_name)
        if custom_tags is not None:
            pulumi.set(__self__, "custom_tags", custom_tags)
        if deployment_environment is not None:
            pulumi.set(__self__, "deployment_environment", deployment_environment)
        if ignore_urls is not None:
            pulumi.set(__self__, "ignore_urls", ignore_urls)
        if propagate_trace_header_cors_urls is not None:
            pulumi.set(__self__, "propagate_trace_header_cors_urls", propagate_trace_header_cors_urls)
        if sampling_rate is not None:
            pulumi.set(__self__, "sampling_rate", sampling_rate)
        if selected_country is not None:
            pulumi.set(__self__, "selected_country", selected_country)

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> builtins.str:
        """
        Add a Service Name of a text string to show for the service name in spans (for example, "bookings-web-app").
        """
        return pulumi.get(self, "service_name")

    @property
    @pulumi.getter(name="applicationName")
    def application_name(self) -> Optional[builtins.str]:
        """
        (Recommended) Add an Application Name tag of a text string to show for the app name in spans (for example, bookings-app). This groups services in the Application Service View. If left blank, services will belong to a "default" application.
        """
        return pulumi.get(self, "application_name")

    @property
    @pulumi.getter(name="customTags")
    def custom_tags(self) -> Optional[Mapping[str, builtins.str]]:
        """
        Defines custom tags attached to the spans. For example: "internal.version = 0.1.21"
        """
        return pulumi.get(self, "custom_tags")

    @property
    @pulumi.getter(name="deploymentEnvironment")
    def deployment_environment(self) -> Optional[builtins.str]:
        """
        Your production, staging, or development environment name.
        """
        return pulumi.get(self, "deployment_environment")

    @property
    @pulumi.getter(name="ignoreUrls")
    def ignore_urls(self) -> Optional[Sequence[builtins.str]]:
        """
        Add a list of URLs not to collect trace data from. Supports regex. Make sure provided URLs are valid JavaScript flavor regexes. For example: "/^https:\\/\\/www.tracker.com\\/.*/, /^https:\\/\\/api.mydomain.com\\/log\\/.*/"
        """
        return pulumi.get(self, "ignore_urls")

    @property
    @pulumi.getter(name="propagateTraceHeaderCorsUrls")
    def propagate_trace_header_cors_urls(self) -> Optional[Sequence[builtins.str]]:
        """
        (Recommended) Add a list of URLs or URL patterns that pass tracing context to construct traces end-to-end. Provided URLs should be valid JavaScript flavor regexes. Some examples are "/^https:\\/\\/api.mydomain.com\\/apiv3\\/.*/" and "/^https:\\/\\/www.3rdparty.com\\/.*/".
        """
        return pulumi.get(self, "propagate_trace_header_cors_urls")

    @property
    @pulumi.getter(name="samplingRate")
    def sampling_rate(self) -> Optional[builtins.float]:
        """
        Add a Probabilistic sampling rate for heavy traffic sites in a decimal value based on percentage, for example, 10% would be entered as 0.1. Supports floating values between 0.0 and 1.0, defaults to 1.0 (all data is passed).
        """
        return pulumi.get(self, "sampling_rate")

    @property
    @pulumi.getter(name="selectedCountry")
    def selected_country(self) -> Optional[builtins.str]:
        """
        Specify if you want to enrich spans with the details level up to the city - if left blank, enrichment works down to the state level.
        """
        return pulumi.get(self, "selected_country")


@pulumi.output_type
class S3ArchiveSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3ArchiveSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3ArchiveSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3ArchiveSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param builtins.str region: Your AWS Bucket region.
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class S3ArchiveSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class S3ArchiveSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3ArchiveSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3ArchiveSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3ArchiveSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class S3ArchiveSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3ArchiveSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3ArchiveSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3ArchiveSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.S3ArchiveSourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.S3ArchiveSourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.S3ArchiveSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.S3ArchiveSourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        :param builtins.str bucket_name: The name of the bucket.
        :param builtins.str path_expression: The path to the data.
        :param builtins.str region: Your AWS Bucket region.
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.S3ArchiveSourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.S3ArchiveSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.S3ArchiveSourcePathSnsTopicOrSubscriptionArn']]:
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.S3ArchiveSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class S3ArchiveSourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.S3ArchiveSourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.S3ArchiveSourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class S3ArchiveSourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class S3ArchiveSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3ArchiveSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3ArchiveSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3ArchiveSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class S3ArchiveSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3ArchiveSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3ArchiveSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3ArchiveSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class S3ArchiveSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class S3AuditSourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param builtins.str region: Your AWS Bucket region.
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`.This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class S3AuditSourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class S3AuditSourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class S3AuditSourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.S3AuditSourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.S3AuditSourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.S3AuditSourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.S3AuditSourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        :param builtins.str bucket_name: The name of the bucket.
        :param builtins.str path_expression: The path to the data.
        :param builtins.str region: Your AWS Bucket region.
        :param Sequence['S3AuditSourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 Audit source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.S3AuditSourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.S3AuditSourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.S3AuditSourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.S3AuditSourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class S3AuditSourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.S3AuditSourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.S3AuditSourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class S3AuditSourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class S3AuditSourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class S3AuditSourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3AuditSourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3AuditSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3AuditSourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class S3AuditSourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class S3SourceAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "accessKey":
            suggest = "access_key"
        elif key == "authProviderX509CertUrl":
            suggest = "auth_provider_x509_cert_url"
        elif key == "authUri":
            suggest = "auth_uri"
        elif key == "clientEmail":
            suggest = "client_email"
        elif key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "clientX509CertUrl":
            suggest = "client_x509_cert_url"
        elif key == "privateKey":
            suggest = "private_key"
        elif key == "privateKeyId":
            suggest = "private_key_id"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "roleArn":
            suggest = "role_arn"
        elif key == "secretKey":
            suggest = "secret_key"
        elif key == "sharedAccessPolicyKey":
            suggest = "shared_access_policy_key"
        elif key == "sharedAccessPolicyName":
            suggest = "shared_access_policy_name"
        elif key == "tenantId":
            suggest = "tenant_id"
        elif key == "tokenUri":
            suggest = "token_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourceAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourceAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourceAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 access_key: Optional[builtins.str] = None,
                 auth_provider_x509_cert_url: Optional[builtins.str] = None,
                 auth_uri: Optional[builtins.str] = None,
                 client_email: Optional[builtins.str] = None,
                 client_id: Optional[builtins.str] = None,
                 client_secret: Optional[builtins.str] = None,
                 client_x509_cert_url: Optional[builtins.str] = None,
                 private_key: Optional[builtins.str] = None,
                 private_key_id: Optional[builtins.str] = None,
                 project_id: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 role_arn: Optional[builtins.str] = None,
                 secret_key: Optional[builtins.str] = None,
                 shared_access_policy_key: Optional[builtins.str] = None,
                 shared_access_policy_name: Optional[builtins.str] = None,
                 tenant_id: Optional[builtins.str] = None,
                 token_uri: Optional[builtins.str] = None):
        """
        :param builtins.str type: Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        :param builtins.str access_key: Your AWS access key if using type `S3BucketAuthentication`.
        :param builtins.str region: Your AWS Bucket region.
        :param builtins.str role_arn: Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        :param builtins.str secret_key: Your AWS secret key if using type `S3BucketAuthentication`.
        """
        pulumi.set(__self__, "type", type)
        if access_key is not None:
            pulumi.set(__self__, "access_key", access_key)
        if auth_provider_x509_cert_url is not None:
            pulumi.set(__self__, "auth_provider_x509_cert_url", auth_provider_x509_cert_url)
        if auth_uri is not None:
            pulumi.set(__self__, "auth_uri", auth_uri)
        if client_email is not None:
            pulumi.set(__self__, "client_email", client_email)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if client_x509_cert_url is not None:
            pulumi.set(__self__, "client_x509_cert_url", client_x509_cert_url)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if private_key_id is not None:
            pulumi.set(__self__, "private_key_id", private_key_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if shared_access_policy_key is not None:
            pulumi.set(__self__, "shared_access_policy_key", shared_access_policy_key)
        if shared_access_policy_name is not None:
            pulumi.set(__self__, "shared_access_policy_name", shared_access_policy_name)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)
        if token_uri is not None:
            pulumi.set(__self__, "token_uri", token_uri)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        Must be either `S3BucketAuthentication` or `AWSRoleBasedAuthentication`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="accessKey")
    def access_key(self) -> Optional[builtins.str]:
        """
        Your AWS access key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "access_key")

    @property
    @pulumi.getter(name="authProviderX509CertUrl")
    def auth_provider_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_provider_x509_cert_url")

    @property
    @pulumi.getter(name="authUri")
    def auth_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "auth_uri")

    @property
    @pulumi.getter(name="clientEmail")
    def client_email(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_email")

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_id")

    @property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_secret")

    @property
    @pulumi.getter(name="clientX509CertUrl")
    def client_x509_cert_url(self) -> Optional[builtins.str]:
        return pulumi.get(self, "client_x509_cert_url")

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key")

    @property
    @pulumi.getter(name="privateKeyId")
    def private_key_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "private_key_id")

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "project_id")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[builtins.str]:
        """
        Your AWS role ARN if using type `AWSRoleBasedAuthentication`. This is not supported for AWS China regions.
        """
        return pulumi.get(self, "role_arn")

    @property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[builtins.str]:
        """
        Your AWS secret key if using type `S3BucketAuthentication`.
        """
        return pulumi.get(self, "secret_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyKey")
    def shared_access_policy_key(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_key")

    @property
    @pulumi.getter(name="sharedAccessPolicyName")
    def shared_access_policy_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "shared_access_policy_name")

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[builtins.str]:
        return pulumi.get(self, "tenant_id")

    @property
    @pulumi.getter(name="tokenUri")
    def token_uri(self) -> Optional[builtins.str]:
        return pulumi.get(self, "token_uri")


@pulumi.output_type
class S3SourceDefaultDateFormat(dict):
    def __init__(__self__, *,
                 format: builtins.str,
                 locator: Optional[builtins.str] = None):
        pulumi.set(__self__, "format", format)
        if locator is not None:
            pulumi.set(__self__, "locator", locator)

    @property
    @pulumi.getter
    def format(self) -> builtins.str:
        return pulumi.get(self, "format")

    @property
    @pulumi.getter
    def locator(self) -> Optional[builtins.str]:
        return pulumi.get(self, "locator")


@pulumi.output_type
class S3SourceFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filterType":
            suggest = "filter_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourceFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourceFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourceFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filter_type: builtins.str,
                 name: builtins.str,
                 regexp: builtins.str,
                 mask: Optional[builtins.str] = None):
        pulumi.set(__self__, "filter_type", filter_type)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "regexp", regexp)
        if mask is not None:
            pulumi.set(__self__, "mask", mask)

    @property
    @pulumi.getter(name="filterType")
    def filter_type(self) -> builtins.str:
        return pulumi.get(self, "filter_type")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def regexp(self) -> builtins.str:
        return pulumi.get(self, "regexp")

    @property
    @pulumi.getter
    def mask(self) -> Optional[builtins.str]:
        return pulumi.get(self, "mask")


@pulumi.output_type
class S3SourcePath(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "azureTagFilters":
            suggest = "azure_tag_filters"
        elif key == "bucketName":
            suggest = "bucket_name"
        elif key == "consumerGroup":
            suggest = "consumer_group"
        elif key == "customServices":
            suggest = "custom_services"
        elif key == "eventHubName":
            suggest = "event_hub_name"
        elif key == "limitToNamespaces":
            suggest = "limit_to_namespaces"
        elif key == "limitToRegions":
            suggest = "limit_to_regions"
        elif key == "limitToServices":
            suggest = "limit_to_services"
        elif key == "pathExpression":
            suggest = "path_expression"
        elif key == "snsTopicOrSubscriptionArns":
            suggest = "sns_topic_or_subscription_arns"
        elif key == "tagFilters":
            suggest = "tag_filters"
        elif key == "useVersionedApi":
            suggest = "use_versioned_api"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourcePath. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourcePath.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourcePath.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 azure_tag_filters: Optional[Sequence['outputs.S3SourcePathAzureTagFilter']] = None,
                 bucket_name: Optional[builtins.str] = None,
                 consumer_group: Optional[builtins.str] = None,
                 custom_services: Optional[Sequence['outputs.S3SourcePathCustomService']] = None,
                 environment: Optional[builtins.str] = None,
                 event_hub_name: Optional[builtins.str] = None,
                 limit_to_namespaces: Optional[Sequence[builtins.str]] = None,
                 limit_to_regions: Optional[Sequence[builtins.str]] = None,
                 limit_to_services: Optional[Sequence[builtins.str]] = None,
                 namespace: Optional[builtins.str] = None,
                 path_expression: Optional[builtins.str] = None,
                 region: Optional[builtins.str] = None,
                 sns_topic_or_subscription_arns: Optional[Sequence['outputs.S3SourcePathSnsTopicOrSubscriptionArn']] = None,
                 tag_filters: Optional[Sequence['outputs.S3SourcePathTagFilter']] = None,
                 use_versioned_api: Optional[builtins.bool] = None):
        """
        :param builtins.str type: type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        :param builtins.str bucket_name: The name of the bucket.
        :param builtins.str path_expression: The path to the data.
        :param builtins.str region: Your AWS Bucket region.
        :param Sequence['S3SourcePathSnsTopicOrSubscriptionArnArgs'] sns_topic_or_subscription_arns: This is a computed field for SNS topic/subscription ARN.
        :param builtins.bool use_versioned_api: Whether to Use AWS versioned APIs. Default is set to `true`. If you're collecting from a Cisco Umbrella bucket this must be set to `false`.
        """
        pulumi.set(__self__, "type", type)
        if azure_tag_filters is not None:
            pulumi.set(__self__, "azure_tag_filters", azure_tag_filters)
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if consumer_group is not None:
            pulumi.set(__self__, "consumer_group", consumer_group)
        if custom_services is not None:
            pulumi.set(__self__, "custom_services", custom_services)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if event_hub_name is not None:
            pulumi.set(__self__, "event_hub_name", event_hub_name)
        if limit_to_namespaces is not None:
            pulumi.set(__self__, "limit_to_namespaces", limit_to_namespaces)
        if limit_to_regions is not None:
            pulumi.set(__self__, "limit_to_regions", limit_to_regions)
        if limit_to_services is not None:
            pulumi.set(__self__, "limit_to_services", limit_to_services)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path_expression is not None:
            pulumi.set(__self__, "path_expression", path_expression)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if sns_topic_or_subscription_arns is not None:
            pulumi.set(__self__, "sns_topic_or_subscription_arns", sns_topic_or_subscription_arns)
        if tag_filters is not None:
            pulumi.set(__self__, "tag_filters", tag_filters)
        if use_versioned_api is not None:
            pulumi.set(__self__, "use_versioned_api", use_versioned_api)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        """
        type of polling source. This has to be `S3BucketPathExpression` for `S3 source`.
        """
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="azureTagFilters")
    def azure_tag_filters(self) -> Optional[Sequence['outputs.S3SourcePathAzureTagFilter']]:
        return pulumi.get(self, "azure_tag_filters")

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[builtins.str]:
        """
        The name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @property
    @pulumi.getter(name="consumerGroup")
    def consumer_group(self) -> Optional[builtins.str]:
        return pulumi.get(self, "consumer_group")

    @property
    @pulumi.getter(name="customServices")
    def custom_services(self) -> Optional[Sequence['outputs.S3SourcePathCustomService']]:
        return pulumi.get(self, "custom_services")

    @property
    @pulumi.getter
    def environment(self) -> Optional[builtins.str]:
        return pulumi.get(self, "environment")

    @property
    @pulumi.getter(name="eventHubName")
    def event_hub_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "event_hub_name")

    @property
    @pulumi.getter(name="limitToNamespaces")
    def limit_to_namespaces(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_namespaces")

    @property
    @pulumi.getter(name="limitToRegions")
    def limit_to_regions(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_regions")

    @property
    @pulumi.getter(name="limitToServices")
    def limit_to_services(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "limit_to_services")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter(name="pathExpression")
    def path_expression(self) -> Optional[builtins.str]:
        """
        The path to the data.
        """
        return pulumi.get(self, "path_expression")

    @property
    @pulumi.getter
    def region(self) -> Optional[builtins.str]:
        """
        Your AWS Bucket region.
        """
        return pulumi.get(self, "region")

    @property
    @pulumi.getter(name="snsTopicOrSubscriptionArns")
    def sns_topic_or_subscription_arns(self) -> Optional[Sequence['outputs.S3SourcePathSnsTopicOrSubscriptionArn']]:
        """
        This is a computed field for SNS topic/subscription ARN.
        """
        return pulumi.get(self, "sns_topic_or_subscription_arns")

    @property
    @pulumi.getter(name="tagFilters")
    def tag_filters(self) -> Optional[Sequence['outputs.S3SourcePathTagFilter']]:
        return pulumi.get(self, "tag_filters")

    @property
    @pulumi.getter(name="useVersionedApi")
    def use_versioned_api(self) -> Optional[builtins.bool]:
        """
        Whether to Use AWS versioned APIs. Default is set to `true`. If you're collecting from a Cisco Umbrella bucket this must be set to `false`.
        """
        return pulumi.get(self, "use_versioned_api")


@pulumi.output_type
class S3SourcePathAzureTagFilter(dict):
    def __init__(__self__, *,
                 type: builtins.str,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence['outputs.S3SourcePathAzureTagFilterTag']] = None):
        pulumi.set(__self__, "type", type)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.S3SourcePathAzureTagFilterTag']]:
        return pulumi.get(self, "tags")


@pulumi.output_type
class S3SourcePathAzureTagFilterTag(dict):
    def __init__(__self__, *,
                 name: builtins.str,
                 values: Optional[Sequence[builtins.str]] = None):
        pulumi.set(__self__, "name", name)
        if values is not None:
            pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter
    def values(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "values")


@pulumi.output_type
class S3SourcePathCustomService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceName":
            suggest = "service_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourcePathCustomService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourcePathCustomService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourcePathCustomService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 prefixes: Optional[Sequence[builtins.str]] = None,
                 service_name: Optional[builtins.str] = None):
        if prefixes is not None:
            pulumi.set(__self__, "prefixes", prefixes)
        if service_name is not None:
            pulumi.set(__self__, "service_name", service_name)

    @property
    @pulumi.getter
    def prefixes(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "prefixes")

    @property
    @pulumi.getter(name="serviceName")
    def service_name(self) -> Optional[builtins.str]:
        return pulumi.get(self, "service_name")


@pulumi.output_type
class S3SourcePathSnsTopicOrSubscriptionArn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isSuccess":
            suggest = "is_success"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in S3SourcePathSnsTopicOrSubscriptionArn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        S3SourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        S3SourcePathSnsTopicOrSubscriptionArn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 arn: Optional[builtins.str] = None,
                 is_success: Optional[builtins.bool] = None):
        if arn is not None:
            pulumi.set(__self__, "arn", arn)
        if is_success is not None:
            pulumi.set(__self__, "is_success", is_success)

    @property
    @pulumi.getter
    def arn(self) -> Optional[builtins.str]:
        return pulumi.get(self, "arn")

    @property
    @pulumi.getter(name="isSuccess")
    def is_success(self) -> Optional[builtins.bool]:
        return pulumi.get(self, "is_success")


@pulumi.output_type
class S3SourcePathTagFilter(dict):
    def __init__(__self__, *,
                 namespace: Optional[builtins.str] = None,
                 tags: Optional[Sequence[builtins.str]] = None,
                 type: Optional[builtins.str] = None):
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[builtins.str]:
        return pulumi.get(self, "namespace")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "tags")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        return pulumi.get(self, "type")


@pulumi.output_type
class SamlConfigurationOnDemandProvisioningEnabled(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "onDemandProvisioningRoles":
            suggest = "on_demand_provisioning_roles"
        elif key == "firstNameAttribute":
            suggest = "first_name_attribute"
        elif key == "lastNameAttribute":
            suggest = "last_name_attribute"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SamlConfigurationOnDemandProvisioningEnabled. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SamlConfigurationOnDemandProvisioningEnabled.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SamlConfigurationOnDemandProvisioningEnabled.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 on_demand_provisioning_roles: Sequence[builtins.str],
                 first_name_attribute: Optional[builtins.str] = None,
                 last_name_attribute: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] on_demand_provisioning_roles: List of Sumo Logic RBAC roles to be assigned when user accounts are provisioned.
        :param builtins.str first_name_attribute: First name attribute of the new user account. Defaults to "".
        :param builtins.str last_name_attribute: Last name attribute of the new user account. Defaults to "".
        """
        pulumi.set(__self__, "on_demand_provisioning_roles", on_demand_provisioning_roles)
        if first_name_attribute is not None:
            pulumi.set(__self__, "first_name_attribute", first_name_attribute)
        if last_name_attribute is not None:
            pulumi.set(__self__, "last_name_attribute", last_name_attribute)

    @property
    @pulumi.getter(name="onDemandProvisioningRoles")
    def on_demand_provisioning_roles(self) -> Sequence[builtins.str]:
        """
        List of Sumo Logic RBAC roles to be assigned when user accounts are provisioned.
        """
        return pulumi.get(self, "on_demand_provisioning_roles")

    @property
    @pulumi.getter(name="firstNameAttribute")
    def first_name_attribute(self) -> Optional[builtins.str]:
        """
        First name attribute of the new user account. Defaults to "".
        """
        return pulumi.get(self, "first_name_attribute")

    @property
    @pulumi.getter(name="lastNameAttribute")
    def last_name_attribute(self) -> Optional[builtins.str]:
        """
        Last name attribute of the new user account. Defaults to "".
        """
        return pulumi.get(self, "last_name_attribute")


@pulumi.output_type
class ScanBudgetScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludedRoles":
            suggest = "excluded_roles"
        elif key == "excludedUsers":
            suggest = "excluded_users"
        elif key == "includedRoles":
            suggest = "included_roles"
        elif key == "includedUsers":
            suggest = "included_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ScanBudgetScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ScanBudgetScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ScanBudgetScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 excluded_roles: Optional[Sequence[builtins.str]] = None,
                 excluded_users: Optional[Sequence[builtins.str]] = None,
                 included_roles: Optional[Sequence[builtins.str]] = None,
                 included_users: Optional[Sequence[builtins.str]] = None):
        if excluded_roles is not None:
            pulumi.set(__self__, "excluded_roles", excluded_roles)
        if excluded_users is not None:
            pulumi.set(__self__, "excluded_users", excluded_users)
        if included_roles is not None:
            pulumi.set(__self__, "included_roles", included_roles)
        if included_users is not None:
            pulumi.set(__self__, "included_users", included_users)

    @property
    @pulumi.getter(name="excludedRoles")
    def excluded_roles(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "excluded_roles")

    @property
    @pulumi.getter(name="excludedUsers")
    def excluded_users(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "excluded_users")

    @property
    @pulumi.getter(name="includedRoles")
    def included_roles(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "included_roles")

    @property
    @pulumi.getter(name="includedUsers")
    def included_users(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "included_users")


@pulumi.output_type
class SloCompliance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "complianceType":
            suggest = "compliance_type"
        elif key == "startFrom":
            suggest = "start_from"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloCompliance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloCompliance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloCompliance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compliance_type: builtins.str,
                 size: builtins.str,
                 target: builtins.float,
                 timezone: builtins.str,
                 start_from: Optional[builtins.str] = None):
        """
        :param builtins.str compliance_type: The type of compliance to use. Valid values are `Rolling` or `Calendar`.
        :param builtins.str size: The size of the compliance period to use.
               - For `Rolling` compliance type it must be a multiple of days e.g. `1d`, `2d`.
               - For `Calendar` compliance type the allowed values are `Week`, `Month`, `Quarter`.
        :param builtins.float target: Target percentage for the SLI over the compliance period. Must be a number between 0 and 100.
        :param builtins.str timezone: Time zone for the SLO compliance. Follow the format in the [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        :param builtins.str start_from: Start of the calendar window. For `Week` its required and it would be the day of the week (for e.g. Sunday,
               Monday etc).  For `Quarter` its required, it would be the first month of the start of quarter (for e.g. January, February etc.).
               For `Month` it's not required and is set to first day of the month.
        """
        pulumi.set(__self__, "compliance_type", compliance_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "target", target)
        pulumi.set(__self__, "timezone", timezone)
        if start_from is not None:
            pulumi.set(__self__, "start_from", start_from)

    @property
    @pulumi.getter(name="complianceType")
    def compliance_type(self) -> builtins.str:
        """
        The type of compliance to use. Valid values are `Rolling` or `Calendar`.
        """
        return pulumi.get(self, "compliance_type")

    @property
    @pulumi.getter
    def size(self) -> builtins.str:
        """
        The size of the compliance period to use.
        - For `Rolling` compliance type it must be a multiple of days e.g. `1d`, `2d`.
        - For `Calendar` compliance type the allowed values are `Week`, `Month`, `Quarter`.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def target(self) -> builtins.float:
        """
        Target percentage for the SLI over the compliance period. Must be a number between 0 and 100.
        """
        return pulumi.get(self, "target")

    @property
    @pulumi.getter
    def timezone(self) -> builtins.str:
        """
        Time zone for the SLO compliance. Follow the format in the [IANA Time Zone Database](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List).
        """
        return pulumi.get(self, "timezone")

    @property
    @pulumi.getter(name="startFrom")
    def start_from(self) -> Optional[builtins.str]:
        """
        Start of the calendar window. For `Week` its required and it would be the day of the week (for e.g. Sunday,
        Monday etc).  For `Quarter` its required, it would be the first month of the start of quarter (for e.g. January, February etc.).
        For `Month` it's not required and is set to first day of the month.
        """
        return pulumi.get(self, "start_from")


@pulumi.output_type
class SloIndicator(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorBasedEvaluation":
            suggest = "monitor_based_evaluation"
        elif key == "requestBasedEvaluation":
            suggest = "request_based_evaluation"
        elif key == "windowBasedEvaluation":
            suggest = "window_based_evaluation"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloIndicator. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloIndicator.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloIndicator.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitor_based_evaluation: Optional['outputs.SloIndicatorMonitorBasedEvaluation'] = None,
                 request_based_evaluation: Optional['outputs.SloIndicatorRequestBasedEvaluation'] = None,
                 window_based_evaluation: Optional['outputs.SloIndicatorWindowBasedEvaluation'] = None):
        if monitor_based_evaluation is not None:
            pulumi.set(__self__, "monitor_based_evaluation", monitor_based_evaluation)
        if request_based_evaluation is not None:
            pulumi.set(__self__, "request_based_evaluation", request_based_evaluation)
        if window_based_evaluation is not None:
            pulumi.set(__self__, "window_based_evaluation", window_based_evaluation)

    @property
    @pulumi.getter(name="monitorBasedEvaluation")
    def monitor_based_evaluation(self) -> Optional['outputs.SloIndicatorMonitorBasedEvaluation']:
        return pulumi.get(self, "monitor_based_evaluation")

    @property
    @pulumi.getter(name="requestBasedEvaluation")
    def request_based_evaluation(self) -> Optional['outputs.SloIndicatorRequestBasedEvaluation']:
        return pulumi.get(self, "request_based_evaluation")

    @property
    @pulumi.getter(name="windowBasedEvaluation")
    def window_based_evaluation(self) -> Optional['outputs.SloIndicatorWindowBasedEvaluation']:
        return pulumi.get(self, "window_based_evaluation")


@pulumi.output_type
class SloIndicatorMonitorBasedEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorTriggers":
            suggest = "monitor_triggers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloIndicatorMonitorBasedEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloIndicatorMonitorBasedEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloIndicatorMonitorBasedEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitor_triggers: 'outputs.SloIndicatorMonitorBasedEvaluationMonitorTriggers'):
        """
        :param 'SloIndicatorMonitorBasedEvaluationMonitorTriggersArgs' monitor_triggers: Monitor details on which SLO will be based. Only single monitor is supported here.
        """
        pulumi.set(__self__, "monitor_triggers", monitor_triggers)

    @property
    @pulumi.getter(name="monitorTriggers")
    def monitor_triggers(self) -> 'outputs.SloIndicatorMonitorBasedEvaluationMonitorTriggers':
        """
        Monitor details on which SLO will be based. Only single monitor is supported here.
        """
        return pulumi.get(self, "monitor_triggers")


@pulumi.output_type
class SloIndicatorMonitorBasedEvaluationMonitorTriggers(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "monitorId":
            suggest = "monitor_id"
        elif key == "triggerTypes":
            suggest = "trigger_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloIndicatorMonitorBasedEvaluationMonitorTriggers. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloIndicatorMonitorBasedEvaluationMonitorTriggers.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloIndicatorMonitorBasedEvaluationMonitorTriggers.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 monitor_id: builtins.str,
                 trigger_types: builtins.str):
        """
        :param builtins.str monitor_id: ID of the monitor. Ex: `0000000000BCB3A4`
        :param builtins.str trigger_types: Type of monitor trigger which will attribute towards a successful or unsuccessful SLO 
               window. Valid values are `Critical`, `Warning`, `MissingData`. Only one trigger type is supported.
               
               [1]: https://help.sumologic.com/docs/observability/reliability-management-slo/
               
               [2]: slo_folder.html.markdown
               
               [3]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List
        """
        pulumi.set(__self__, "monitor_id", monitor_id)
        pulumi.set(__self__, "trigger_types", trigger_types)

    @property
    @pulumi.getter(name="monitorId")
    def monitor_id(self) -> builtins.str:
        """
        ID of the monitor. Ex: `0000000000BCB3A4`
        """
        return pulumi.get(self, "monitor_id")

    @property
    @pulumi.getter(name="triggerTypes")
    def trigger_types(self) -> builtins.str:
        """
        Type of monitor trigger which will attribute towards a successful or unsuccessful SLO 
        window. Valid values are `Critical`, `Warning`, `MissingData`. Only one trigger type is supported.

        [1]: https://help.sumologic.com/docs/observability/reliability-management-slo/

        [2]: slo_folder.html.markdown

        [3]: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones#List
        """
        return pulumi.get(self, "trigger_types")


@pulumi.output_type
class SloIndicatorRequestBasedEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryType":
            suggest = "query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloIndicatorRequestBasedEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloIndicatorRequestBasedEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloIndicatorRequestBasedEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 queries: Sequence['outputs.SloIndicatorRequestBasedEvaluationQuery'],
                 query_type: builtins.str,
                 op: Optional[builtins.str] = None,
                 threshold: Optional[builtins.float] = None):
        """
        :param Sequence['SloIndicatorRequestBasedEvaluationQueryArgs'] queries: The queries to use.
        :param builtins.str query_type: The type of query to use. Valid values are `Metrics` or `Logs`.
        :param builtins.str op: Comparison function with threshold. Valid values are `LessThan`, `LessThanOrEqual`, `GreaterThan`
               , `GreaterThanOrEqual`.
        :param builtins.float threshold: Compared against threshold query's raw data points to determine success criteria.
        """
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "query_type", query_type)
        if op is not None:
            pulumi.set(__self__, "op", op)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.SloIndicatorRequestBasedEvaluationQuery']:
        """
        The queries to use.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> builtins.str:
        """
        The type of query to use. Valid values are `Metrics` or `Logs`.
        """
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter
    def op(self) -> Optional[builtins.str]:
        """
        Comparison function with threshold. Valid values are `LessThan`, `LessThanOrEqual`, `GreaterThan`
        , `GreaterThanOrEqual`.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def threshold(self) -> Optional[builtins.float]:
        """
        Compared against threshold query's raw data points to determine success criteria.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class SloIndicatorRequestBasedEvaluationQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryGroupType":
            suggest = "query_group_type"
        elif key == "queryGroups":
            suggest = "query_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloIndicatorRequestBasedEvaluationQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloIndicatorRequestBasedEvaluationQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloIndicatorRequestBasedEvaluationQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_group_type: builtins.str,
                 query_groups: Sequence['outputs.SloIndicatorRequestBasedEvaluationQueryQueryGroup']):
        """
        :param builtins.str query_group_type: The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
               , `Threshold`.
        :param Sequence['SloIndicatorRequestBasedEvaluationQueryQueryGroupArgs'] query_groups: List of queries to use.
        """
        pulumi.set(__self__, "query_group_type", query_group_type)
        pulumi.set(__self__, "query_groups", query_groups)

    @property
    @pulumi.getter(name="queryGroupType")
    def query_group_type(self) -> builtins.str:
        """
        The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
        , `Threshold`.
        """
        return pulumi.get(self, "query_group_type")

    @property
    @pulumi.getter(name="queryGroups")
    def query_groups(self) -> Sequence['outputs.SloIndicatorRequestBasedEvaluationQueryQueryGroup']:
        """
        List of queries to use.
        """
        return pulumi.get(self, "query_groups")


@pulumi.output_type
class SloIndicatorRequestBasedEvaluationQueryQueryGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowId":
            suggest = "row_id"
        elif key == "useRowCount":
            suggest = "use_row_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloIndicatorRequestBasedEvaluationQueryQueryGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloIndicatorRequestBasedEvaluationQueryQueryGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloIndicatorRequestBasedEvaluationQueryQueryGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: builtins.str,
                 row_id: builtins.str,
                 use_row_count: builtins.bool,
                 field: Optional[builtins.str] = None):
        """
        :param builtins.str query: The query string to use.
        :param builtins.str row_id: The row ID to use.
        :param builtins.bool use_row_count: Whether to use the row count. Defaults to false.
        :param builtins.str field: Field of log query output to compare against. To be used only for logs based data
               type when `use_row_count` is false.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)
        pulumi.set(__self__, "use_row_count", use_row_count)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def query(self) -> builtins.str:
        """
        The query string to use.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> builtins.str:
        """
        The row ID to use.
        """
        return pulumi.get(self, "row_id")

    @property
    @pulumi.getter(name="useRowCount")
    def use_row_count(self) -> builtins.bool:
        """
        Whether to use the row count. Defaults to false.
        """
        return pulumi.get(self, "use_row_count")

    @property
    @pulumi.getter
    def field(self) -> Optional[builtins.str]:
        """
        Field of log query output to compare against. To be used only for logs based data
        type when `use_row_count` is false.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class SloIndicatorWindowBasedEvaluation(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryType":
            suggest = "query_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloIndicatorWindowBasedEvaluation. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloIndicatorWindowBasedEvaluation.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloIndicatorWindowBasedEvaluation.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 op: builtins.str,
                 queries: Sequence['outputs.SloIndicatorWindowBasedEvaluationQuery'],
                 query_type: builtins.str,
                 size: builtins.str,
                 threshold: builtins.float,
                 aggregation: Optional[builtins.str] = None):
        """
        :param builtins.str op: The operator used to define a successful window. Valid values are `LessThan`
               , `LessThanOrEqual`, `GreaterThan`
               , `GreaterThanOrEqual`.
        :param Sequence['SloIndicatorWindowBasedEvaluationQueryArgs'] queries: The queries to use.
        :param builtins.str query_type: The type of query to use. Valid values are `Metrics` or `Logs`.
        :param builtins.str size: The size of the window to use, minimum of `1m` and maximum of `1h`.
        :param builtins.float threshold: Threshold for classifying window as successful or unsuccessful, i.e. the minimum value
               for `(good windows / total windows) * 100`.
        :param builtins.str aggregation: Aggregation function applied over each window to arrive at SLI. Valid values are `Avg`
               , `Sum`, `Count`, `Max`, `Min` and `p[1-99]`.
        """
        pulumi.set(__self__, "op", op)
        pulumi.set(__self__, "queries", queries)
        pulumi.set(__self__, "query_type", query_type)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "threshold", threshold)
        if aggregation is not None:
            pulumi.set(__self__, "aggregation", aggregation)

    @property
    @pulumi.getter
    def op(self) -> builtins.str:
        """
        The operator used to define a successful window. Valid values are `LessThan`
        , `LessThanOrEqual`, `GreaterThan`
        , `GreaterThanOrEqual`.
        """
        return pulumi.get(self, "op")

    @property
    @pulumi.getter
    def queries(self) -> Sequence['outputs.SloIndicatorWindowBasedEvaluationQuery']:
        """
        The queries to use.
        """
        return pulumi.get(self, "queries")

    @property
    @pulumi.getter(name="queryType")
    def query_type(self) -> builtins.str:
        """
        The type of query to use. Valid values are `Metrics` or `Logs`.
        """
        return pulumi.get(self, "query_type")

    @property
    @pulumi.getter
    def size(self) -> builtins.str:
        """
        The size of the window to use, minimum of `1m` and maximum of `1h`.
        """
        return pulumi.get(self, "size")

    @property
    @pulumi.getter
    def threshold(self) -> builtins.float:
        """
        Threshold for classifying window as successful or unsuccessful, i.e. the minimum value
        for `(good windows / total windows) * 100`.
        """
        return pulumi.get(self, "threshold")

    @property
    @pulumi.getter
    def aggregation(self) -> Optional[builtins.str]:
        """
        Aggregation function applied over each window to arrive at SLI. Valid values are `Avg`
        , `Sum`, `Count`, `Max`, `Min` and `p[1-99]`.
        """
        return pulumi.get(self, "aggregation")


@pulumi.output_type
class SloIndicatorWindowBasedEvaluationQuery(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "queryGroupType":
            suggest = "query_group_type"
        elif key == "queryGroups":
            suggest = "query_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloIndicatorWindowBasedEvaluationQuery. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloIndicatorWindowBasedEvaluationQuery.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloIndicatorWindowBasedEvaluationQuery.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query_group_type: builtins.str,
                 query_groups: Sequence['outputs.SloIndicatorWindowBasedEvaluationQueryQueryGroup']):
        """
        :param builtins.str query_group_type: The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
               , `Threshold`.
        :param Sequence['SloIndicatorWindowBasedEvaluationQueryQueryGroupArgs'] query_groups: List of queries to use.
        """
        pulumi.set(__self__, "query_group_type", query_group_type)
        pulumi.set(__self__, "query_groups", query_groups)

    @property
    @pulumi.getter(name="queryGroupType")
    def query_group_type(self) -> builtins.str:
        """
        The type of query. Valid values are `Successful`, `Unsuccessful`, `Total`
        , `Threshold`.
        """
        return pulumi.get(self, "query_group_type")

    @property
    @pulumi.getter(name="queryGroups")
    def query_groups(self) -> Sequence['outputs.SloIndicatorWindowBasedEvaluationQueryQueryGroup']:
        """
        List of queries to use.
        """
        return pulumi.get(self, "query_groups")


@pulumi.output_type
class SloIndicatorWindowBasedEvaluationQueryQueryGroup(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rowId":
            suggest = "row_id"
        elif key == "useRowCount":
            suggest = "use_row_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SloIndicatorWindowBasedEvaluationQueryQueryGroup. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SloIndicatorWindowBasedEvaluationQueryQueryGroup.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SloIndicatorWindowBasedEvaluationQueryQueryGroup.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 query: builtins.str,
                 row_id: builtins.str,
                 use_row_count: builtins.bool,
                 field: Optional[builtins.str] = None):
        """
        :param builtins.str query: The query string to use.
        :param builtins.str row_id: The row ID to use.
        :param builtins.bool use_row_count: Whether to use the row count. Defaults to false.
        :param builtins.str field: Field of log query output to compare against. To be used only for logs based data
               type when `use_row_count` is false.
        """
        pulumi.set(__self__, "query", query)
        pulumi.set(__self__, "row_id", row_id)
        pulumi.set(__self__, "use_row_count", use_row_count)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def query(self) -> builtins.str:
        """
        The query string to use.
        """
        return pulumi.get(self, "query")

    @property
    @pulumi.getter(name="rowId")
    def row_id(self) -> builtins.str:
        """
        The row ID to use.
        """
        return pulumi.get(self, "row_id")

    @property
    @pulumi.getter(name="useRowCount")
    def use_row_count(self) -> builtins.bool:
        """
        Whether to use the row count. Defaults to false.
        """
        return pulumi.get(self, "use_row_count")

    @property
    @pulumi.getter
    def field(self) -> Optional[builtins.str]:
        """
        Field of log query output to compare against. To be used only for logs based data
        type when `use_row_count` is false.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class SourceTemplateSchemaRef(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "latestVersion":
            suggest = "latest_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SourceTemplateSchemaRef. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SourceTemplateSchemaRef.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SourceTemplateSchemaRef.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: builtins.str,
                 latest_version: Optional[builtins.str] = None,
                 version: Optional[builtins.str] = None):
        pulumi.set(__self__, "type", type)
        if latest_version is not None:
            pulumi.set(__self__, "latest_version", latest_version)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def type(self) -> builtins.str:
        return pulumi.get(self, "type")

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        return pulumi.get(self, "version")


@pulumi.output_type
class SourceTemplateSelector(dict):
    def __init__(__self__, *,
                 names: Optional[Sequence[builtins.str]] = None,
                 tags: Optional[Sequence[Sequence['outputs.SourceTemplateSelectorTag']]] = None):
        """
        :param Sequence[builtins.str] names: names to select custom agents
        :param Sequence[Sequence['SourceTemplateSelectorTagArgs']] tags: tags filter for agents
        """
        if names is not None:
            pulumi.set(__self__, "names", names)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def names(self) -> Optional[Sequence[builtins.str]]:
        """
        names to select custom agents
        """
        return pulumi.get(self, "names")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[Sequence['outputs.SourceTemplateSelectorTag']]]:
        """
        tags filter for agents
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class SourceTemplateSelectorTag(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 values: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] values: values of the given tag.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def values(self) -> Sequence[builtins.str]:
        """
        values of the given tag.
        """
        return pulumi.get(self, "values")


@pulumi.output_type
class GetAppsAppResult(dict):
    def __init__(__self__, *,
                 account_types: Sequence[builtins.str],
                 app_type: builtins.str,
                 author: builtins.str,
                 beta: builtins.bool,
                 description: builtins.str,
                 family: builtins.str,
                 icon: builtins.str,
                 installable: builtins.bool,
                 installs: builtins.int,
                 latest_version: builtins.str,
                 name: builtins.str,
                 show_on_marketplace: builtins.bool,
                 uuid: builtins.str,
                 attributes: Optional['outputs.GetAppsAppAttributesResult'] = None):
        pulumi.set(__self__, "account_types", account_types)
        pulumi.set(__self__, "app_type", app_type)
        pulumi.set(__self__, "author", author)
        pulumi.set(__self__, "beta", beta)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "family", family)
        pulumi.set(__self__, "icon", icon)
        pulumi.set(__self__, "installable", installable)
        pulumi.set(__self__, "installs", installs)
        pulumi.set(__self__, "latest_version", latest_version)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "show_on_marketplace", show_on_marketplace)
        pulumi.set(__self__, "uuid", uuid)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)

    @property
    @pulumi.getter(name="accountTypes")
    def account_types(self) -> Sequence[builtins.str]:
        return pulumi.get(self, "account_types")

    @property
    @pulumi.getter(name="appType")
    def app_type(self) -> builtins.str:
        return pulumi.get(self, "app_type")

    @property
    @pulumi.getter
    def author(self) -> builtins.str:
        return pulumi.get(self, "author")

    @property
    @pulumi.getter
    def beta(self) -> builtins.bool:
        return pulumi.get(self, "beta")

    @property
    @pulumi.getter
    def description(self) -> builtins.str:
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def family(self) -> builtins.str:
        return pulumi.get(self, "family")

    @property
    @pulumi.getter
    def icon(self) -> builtins.str:
        return pulumi.get(self, "icon")

    @property
    @pulumi.getter
    def installable(self) -> builtins.bool:
        return pulumi.get(self, "installable")

    @property
    @pulumi.getter
    def installs(self) -> builtins.int:
        return pulumi.get(self, "installs")

    @property
    @pulumi.getter(name="latestVersion")
    def latest_version(self) -> builtins.str:
        return pulumi.get(self, "latest_version")

    @property
    @pulumi.getter
    def name(self) -> builtins.str:
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="showOnMarketplace")
    def show_on_marketplace(self) -> builtins.bool:
        return pulumi.get(self, "show_on_marketplace")

    @property
    @pulumi.getter
    def uuid(self) -> builtins.str:
        return pulumi.get(self, "uuid")

    @property
    @pulumi.getter
    def attributes(self) -> Optional['outputs.GetAppsAppAttributesResult']:
        return pulumi.get(self, "attributes")


@pulumi.output_type
class GetAppsAppAttributesResult(dict):
    def __init__(__self__, *,
                 categories: Optional[Sequence[builtins.str]] = None,
                 collections: Optional[Sequence[builtins.str]] = None,
                 use_cases: Optional[Sequence[builtins.str]] = None):
        if categories is not None:
            pulumi.set(__self__, "categories", categories)
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if use_cases is not None:
            pulumi.set(__self__, "use_cases", use_cases)

    @property
    @pulumi.getter
    def categories(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "categories")

    @property
    @pulumi.getter
    def collections(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "collections")

    @property
    @pulumi.getter(name="useCases")
    def use_cases(self) -> Optional[Sequence[builtins.str]]:
        return pulumi.get(self, "use_cases")


@pulumi.output_type
class GetRoleV2SelectedViewResult(dict):
    def __init__(__self__, *,
                 view_filter: builtins.str,
                 view_name: builtins.str):
        pulumi.set(__self__, "view_filter", view_filter)
        pulumi.set(__self__, "view_name", view_name)

    @property
    @pulumi.getter(name="viewFilter")
    def view_filter(self) -> builtins.str:
        return pulumi.get(self, "view_filter")

    @property
    @pulumi.getter(name="viewName")
    def view_name(self) -> builtins.str:
        return pulumi.get(self, "view_name")


