// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.sumologic.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Double;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class MonitorTriggerArgs extends com.pulumi.resources.ResourceArgs {

    public static final MonitorTriggerArgs Empty = new MonitorTriggerArgs();

    @Import(name="detectionMethod")
    private @Nullable Output<String> detectionMethod;

    public Optional<Output<String>> detectionMethod() {
        return Optional.ofNullable(this.detectionMethod);
    }

    @Import(name="occurrenceType")
    private @Nullable Output<String> occurrenceType;

    public Optional<Output<String>> occurrenceType() {
        return Optional.ofNullable(this.occurrenceType);
    }

    /**
     * The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
     * 
     */
    @Import(name="resolutionWindow")
    private @Nullable Output<String> resolutionWindow;

    /**
     * @return The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
     * 
     */
    public Optional<Output<String>> resolutionWindow() {
        return Optional.ofNullable(this.resolutionWindow);
    }

    @Import(name="threshold")
    private @Nullable Output<Double> threshold;

    public Optional<Output<Double>> threshold() {
        return Optional.ofNullable(this.threshold);
    }

    @Import(name="thresholdType")
    private @Nullable Output<String> thresholdType;

    public Optional<Output<String>> thresholdType() {
        return Optional.ofNullable(this.thresholdType);
    }

    @Import(name="timeRange")
    private @Nullable Output<String> timeRange;

    public Optional<Output<String>> timeRange() {
        return Optional.ofNullable(this.timeRange);
    }

    @Import(name="triggerSource")
    private @Nullable Output<String> triggerSource;

    public Optional<Output<String>> triggerSource() {
        return Optional.ofNullable(this.triggerSource);
    }

    @Import(name="triggerType")
    private @Nullable Output<String> triggerType;

    public Optional<Output<String>> triggerType() {
        return Optional.ofNullable(this.triggerType);
    }

    private MonitorTriggerArgs() {}

    private MonitorTriggerArgs(MonitorTriggerArgs $) {
        this.detectionMethod = $.detectionMethod;
        this.occurrenceType = $.occurrenceType;
        this.resolutionWindow = $.resolutionWindow;
        this.threshold = $.threshold;
        this.thresholdType = $.thresholdType;
        this.timeRange = $.timeRange;
        this.triggerSource = $.triggerSource;
        this.triggerType = $.triggerType;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(MonitorTriggerArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private MonitorTriggerArgs $;

        public Builder() {
            $ = new MonitorTriggerArgs();
        }

        public Builder(MonitorTriggerArgs defaults) {
            $ = new MonitorTriggerArgs(Objects.requireNonNull(defaults));
        }

        public Builder detectionMethod(@Nullable Output<String> detectionMethod) {
            $.detectionMethod = detectionMethod;
            return this;
        }

        public Builder detectionMethod(String detectionMethod) {
            return detectionMethod(Output.of(detectionMethod));
        }

        public Builder occurrenceType(@Nullable Output<String> occurrenceType) {
            $.occurrenceType = occurrenceType;
            return this;
        }

        public Builder occurrenceType(String occurrenceType) {
            return occurrenceType(Output.of(occurrenceType));
        }

        /**
         * @param resolutionWindow The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
         * 
         * @return builder
         * 
         */
        public Builder resolutionWindow(@Nullable Output<String> resolutionWindow) {
            $.resolutionWindow = resolutionWindow;
            return this;
        }

        /**
         * @param resolutionWindow The resolution window that the recovery condition must be met in each evaluation that happens within this entire duration before the alert is recovered (resolved). If not specified, the time range of your trigger will be used.
         * 
         * @return builder
         * 
         */
        public Builder resolutionWindow(String resolutionWindow) {
            return resolutionWindow(Output.of(resolutionWindow));
        }

        public Builder threshold(@Nullable Output<Double> threshold) {
            $.threshold = threshold;
            return this;
        }

        public Builder threshold(Double threshold) {
            return threshold(Output.of(threshold));
        }

        public Builder thresholdType(@Nullable Output<String> thresholdType) {
            $.thresholdType = thresholdType;
            return this;
        }

        public Builder thresholdType(String thresholdType) {
            return thresholdType(Output.of(thresholdType));
        }

        public Builder timeRange(@Nullable Output<String> timeRange) {
            $.timeRange = timeRange;
            return this;
        }

        public Builder timeRange(String timeRange) {
            return timeRange(Output.of(timeRange));
        }

        public Builder triggerSource(@Nullable Output<String> triggerSource) {
            $.triggerSource = triggerSource;
            return this;
        }

        public Builder triggerSource(String triggerSource) {
            return triggerSource(Output.of(triggerSource));
        }

        public Builder triggerType(@Nullable Output<String> triggerType) {
            $.triggerType = triggerType;
            return this;
        }

        public Builder triggerType(String triggerType) {
            return triggerType(Output.of(triggerType));
        }

        public MonitorTriggerArgs build() {
            return $;
        }
    }

}
