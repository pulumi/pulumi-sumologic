// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.sumologic;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import com.pulumi.sumologic.inputs.LocalFileSourceDefaultDateFormatArgs;
import com.pulumi.sumologic.inputs.LocalFileSourceFilterArgs;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class LocalFileSourceArgs extends com.pulumi.resources.ResourceArgs {

    public static final LocalFileSourceArgs Empty = new LocalFileSourceArgs();

    @Import(name="automaticDateParsing")
    private @Nullable Output<Boolean> automaticDateParsing;

    public Optional<Output<Boolean>> automaticDateParsing() {
        return Optional.ofNullable(this.automaticDateParsing);
    }

    /**
     * The default source category for the source.
     * 
     */
    @Import(name="category")
    private @Nullable Output<String> category;

    /**
     * @return The default source category for the source.
     * 
     */
    public Optional<Output<String>> category() {
        return Optional.ofNullable(this.category);
    }

    @Import(name="collectorId", required=true)
    private Output<Integer> collectorId;

    public Output<Integer> collectorId() {
        return this.collectorId;
    }

    @Import(name="contentType")
    private @Nullable Output<String> contentType;

    public Optional<Output<String>> contentType() {
        return Optional.ofNullable(this.contentType);
    }

    @Import(name="cutoffRelativeTime")
    private @Nullable Output<String> cutoffRelativeTime;

    public Optional<Output<String>> cutoffRelativeTime() {
        return Optional.ofNullable(this.cutoffRelativeTime);
    }

    @Import(name="cutoffTimestamp")
    private @Nullable Output<Integer> cutoffTimestamp;

    public Optional<Output<Integer>> cutoffTimestamp() {
        return Optional.ofNullable(this.cutoffTimestamp);
    }

    @Import(name="defaultDateFormats")
    private @Nullable Output<List<LocalFileSourceDefaultDateFormatArgs>> defaultDateFormats;

    public Optional<Output<List<LocalFileSourceDefaultDateFormatArgs>>> defaultDateFormats() {
        return Optional.ofNullable(this.defaultDateFormats);
    }

    @Import(name="denyLists")
    private @Nullable Output<List<String>> denyLists;

    public Optional<Output<List<String>>> denyLists() {
        return Optional.ofNullable(this.denyLists);
    }

    /**
     * The description of the source.
     * 
     */
    @Import(name="description")
    private @Nullable Output<String> description;

    /**
     * @return The description of the source.
     * 
     */
    public Optional<Output<String>> description() {
        return Optional.ofNullable(this.description);
    }

    /**
     * Defines the encoding form. Default is &#34;UTF-8&#34;. Other supported encodings are listed [here](https://help.sumologic.com/docs/send-data/installed-collectors/sources/local-file-source/#supported-encoding-for-local-file-sources).
     * 
     */
    @Import(name="encoding")
    private @Nullable Output<String> encoding;

    /**
     * @return Defines the encoding form. Default is &#34;UTF-8&#34;. Other supported encodings are listed [here](https://help.sumologic.com/docs/send-data/installed-collectors/sources/local-file-source/#supported-encoding-for-local-file-sources).
     * 
     */
    public Optional<Output<String>> encoding() {
        return Optional.ofNullable(this.encoding);
    }

    /**
     * Map containing [key/value pairs][2].
     * 
     */
    @Import(name="fields")
    private @Nullable Output<Map<String,String>> fields;

    /**
     * @return Map containing [key/value pairs][2].
     * 
     */
    public Optional<Output<Map<String,String>>> fields() {
        return Optional.ofNullable(this.fields);
    }

    @Import(name="filters")
    private @Nullable Output<List<LocalFileSourceFilterArgs>> filters;

    public Optional<Output<List<LocalFileSourceFilterArgs>>> filters() {
        return Optional.ofNullable(this.filters);
    }

    @Import(name="forceTimezone")
    private @Nullable Output<Boolean> forceTimezone;

    public Optional<Output<Boolean>> forceTimezone() {
        return Optional.ofNullable(this.forceTimezone);
    }

    @Import(name="hostName")
    private @Nullable Output<String> hostName;

    public Optional<Output<String>> hostName() {
        return Optional.ofNullable(this.hostName);
    }

    @Import(name="manualPrefixRegexp")
    private @Nullable Output<String> manualPrefixRegexp;

    public Optional<Output<String>> manualPrefixRegexp() {
        return Optional.ofNullable(this.manualPrefixRegexp);
    }

    @Import(name="multilineProcessingEnabled")
    private @Nullable Output<Boolean> multilineProcessingEnabled;

    public Optional<Output<Boolean>> multilineProcessingEnabled() {
        return Optional.ofNullable(this.multilineProcessingEnabled);
    }

    /**
     * The name of the local file source. This is required, and has to be unique. Changing this will force recreation the source.
     * 
     */
    @Import(name="name")
    private @Nullable Output<String> name;

    /**
     * @return The name of the local file source. This is required, and has to be unique. Changing this will force recreation the source.
     * 
     */
    public Optional<Output<String>> name() {
        return Optional.ofNullable(this.name);
    }

    /**
     * A valid path expression (full path) of the file to collect. For files on Windows systems (not including Windows Events), enter the absolute path including the drive letter. Escape special characters and spaces with a backslash (). If you are collecting from Windows using CIFS/SMB, see Prerequisites for Windows Log Collection. Use a single asterisk wildcard [*] for file or folder names. Example:[var/foo/*.log]. Use two asterisks [**]to recurse within directories and subdirectories. Example: [var/*&#47;.log].
     * 
     */
    @Import(name="pathExpression", required=true)
    private Output<String> pathExpression;

    /**
     * @return A valid path expression (full path) of the file to collect. For files on Windows systems (not including Windows Events), enter the absolute path including the drive letter. Escape special characters and spaces with a backslash (). If you are collecting from Windows using CIFS/SMB, see Prerequisites for Windows Log Collection. Use a single asterisk wildcard [*] for file or folder names. Example:[var/foo/*.log]. Use two asterisks [**]to recurse within directories and subdirectories. Example: [var/*&#47;.log].
     * 
     */
    public Output<String> pathExpression() {
        return this.pathExpression;
    }

    @Import(name="timezone")
    private @Nullable Output<String> timezone;

    public Optional<Output<String>> timezone() {
        return Optional.ofNullable(this.timezone);
    }

    @Import(name="useAutolineMatching")
    private @Nullable Output<Boolean> useAutolineMatching;

    public Optional<Output<Boolean>> useAutolineMatching() {
        return Optional.ofNullable(this.useAutolineMatching);
    }

    private LocalFileSourceArgs() {}

    private LocalFileSourceArgs(LocalFileSourceArgs $) {
        this.automaticDateParsing = $.automaticDateParsing;
        this.category = $.category;
        this.collectorId = $.collectorId;
        this.contentType = $.contentType;
        this.cutoffRelativeTime = $.cutoffRelativeTime;
        this.cutoffTimestamp = $.cutoffTimestamp;
        this.defaultDateFormats = $.defaultDateFormats;
        this.denyLists = $.denyLists;
        this.description = $.description;
        this.encoding = $.encoding;
        this.fields = $.fields;
        this.filters = $.filters;
        this.forceTimezone = $.forceTimezone;
        this.hostName = $.hostName;
        this.manualPrefixRegexp = $.manualPrefixRegexp;
        this.multilineProcessingEnabled = $.multilineProcessingEnabled;
        this.name = $.name;
        this.pathExpression = $.pathExpression;
        this.timezone = $.timezone;
        this.useAutolineMatching = $.useAutolineMatching;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(LocalFileSourceArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private LocalFileSourceArgs $;

        public Builder() {
            $ = new LocalFileSourceArgs();
        }

        public Builder(LocalFileSourceArgs defaults) {
            $ = new LocalFileSourceArgs(Objects.requireNonNull(defaults));
        }

        public Builder automaticDateParsing(@Nullable Output<Boolean> automaticDateParsing) {
            $.automaticDateParsing = automaticDateParsing;
            return this;
        }

        public Builder automaticDateParsing(Boolean automaticDateParsing) {
            return automaticDateParsing(Output.of(automaticDateParsing));
        }

        /**
         * @param category The default source category for the source.
         * 
         * @return builder
         * 
         */
        public Builder category(@Nullable Output<String> category) {
            $.category = category;
            return this;
        }

        /**
         * @param category The default source category for the source.
         * 
         * @return builder
         * 
         */
        public Builder category(String category) {
            return category(Output.of(category));
        }

        public Builder collectorId(Output<Integer> collectorId) {
            $.collectorId = collectorId;
            return this;
        }

        public Builder collectorId(Integer collectorId) {
            return collectorId(Output.of(collectorId));
        }

        public Builder contentType(@Nullable Output<String> contentType) {
            $.contentType = contentType;
            return this;
        }

        public Builder contentType(String contentType) {
            return contentType(Output.of(contentType));
        }

        public Builder cutoffRelativeTime(@Nullable Output<String> cutoffRelativeTime) {
            $.cutoffRelativeTime = cutoffRelativeTime;
            return this;
        }

        public Builder cutoffRelativeTime(String cutoffRelativeTime) {
            return cutoffRelativeTime(Output.of(cutoffRelativeTime));
        }

        public Builder cutoffTimestamp(@Nullable Output<Integer> cutoffTimestamp) {
            $.cutoffTimestamp = cutoffTimestamp;
            return this;
        }

        public Builder cutoffTimestamp(Integer cutoffTimestamp) {
            return cutoffTimestamp(Output.of(cutoffTimestamp));
        }

        public Builder defaultDateFormats(@Nullable Output<List<LocalFileSourceDefaultDateFormatArgs>> defaultDateFormats) {
            $.defaultDateFormats = defaultDateFormats;
            return this;
        }

        public Builder defaultDateFormats(List<LocalFileSourceDefaultDateFormatArgs> defaultDateFormats) {
            return defaultDateFormats(Output.of(defaultDateFormats));
        }

        public Builder defaultDateFormats(LocalFileSourceDefaultDateFormatArgs... defaultDateFormats) {
            return defaultDateFormats(List.of(defaultDateFormats));
        }

        public Builder denyLists(@Nullable Output<List<String>> denyLists) {
            $.denyLists = denyLists;
            return this;
        }

        public Builder denyLists(List<String> denyLists) {
            return denyLists(Output.of(denyLists));
        }

        public Builder denyLists(String... denyLists) {
            return denyLists(List.of(denyLists));
        }

        /**
         * @param description The description of the source.
         * 
         * @return builder
         * 
         */
        public Builder description(@Nullable Output<String> description) {
            $.description = description;
            return this;
        }

        /**
         * @param description The description of the source.
         * 
         * @return builder
         * 
         */
        public Builder description(String description) {
            return description(Output.of(description));
        }

        /**
         * @param encoding Defines the encoding form. Default is &#34;UTF-8&#34;. Other supported encodings are listed [here](https://help.sumologic.com/docs/send-data/installed-collectors/sources/local-file-source/#supported-encoding-for-local-file-sources).
         * 
         * @return builder
         * 
         */
        public Builder encoding(@Nullable Output<String> encoding) {
            $.encoding = encoding;
            return this;
        }

        /**
         * @param encoding Defines the encoding form. Default is &#34;UTF-8&#34;. Other supported encodings are listed [here](https://help.sumologic.com/docs/send-data/installed-collectors/sources/local-file-source/#supported-encoding-for-local-file-sources).
         * 
         * @return builder
         * 
         */
        public Builder encoding(String encoding) {
            return encoding(Output.of(encoding));
        }

        /**
         * @param fields Map containing [key/value pairs][2].
         * 
         * @return builder
         * 
         */
        public Builder fields(@Nullable Output<Map<String,String>> fields) {
            $.fields = fields;
            return this;
        }

        /**
         * @param fields Map containing [key/value pairs][2].
         * 
         * @return builder
         * 
         */
        public Builder fields(Map<String,String> fields) {
            return fields(Output.of(fields));
        }

        public Builder filters(@Nullable Output<List<LocalFileSourceFilterArgs>> filters) {
            $.filters = filters;
            return this;
        }

        public Builder filters(List<LocalFileSourceFilterArgs> filters) {
            return filters(Output.of(filters));
        }

        public Builder filters(LocalFileSourceFilterArgs... filters) {
            return filters(List.of(filters));
        }

        public Builder forceTimezone(@Nullable Output<Boolean> forceTimezone) {
            $.forceTimezone = forceTimezone;
            return this;
        }

        public Builder forceTimezone(Boolean forceTimezone) {
            return forceTimezone(Output.of(forceTimezone));
        }

        public Builder hostName(@Nullable Output<String> hostName) {
            $.hostName = hostName;
            return this;
        }

        public Builder hostName(String hostName) {
            return hostName(Output.of(hostName));
        }

        public Builder manualPrefixRegexp(@Nullable Output<String> manualPrefixRegexp) {
            $.manualPrefixRegexp = manualPrefixRegexp;
            return this;
        }

        public Builder manualPrefixRegexp(String manualPrefixRegexp) {
            return manualPrefixRegexp(Output.of(manualPrefixRegexp));
        }

        public Builder multilineProcessingEnabled(@Nullable Output<Boolean> multilineProcessingEnabled) {
            $.multilineProcessingEnabled = multilineProcessingEnabled;
            return this;
        }

        public Builder multilineProcessingEnabled(Boolean multilineProcessingEnabled) {
            return multilineProcessingEnabled(Output.of(multilineProcessingEnabled));
        }

        /**
         * @param name The name of the local file source. This is required, and has to be unique. Changing this will force recreation the source.
         * 
         * @return builder
         * 
         */
        public Builder name(@Nullable Output<String> name) {
            $.name = name;
            return this;
        }

        /**
         * @param name The name of the local file source. This is required, and has to be unique. Changing this will force recreation the source.
         * 
         * @return builder
         * 
         */
        public Builder name(String name) {
            return name(Output.of(name));
        }

        /**
         * @param pathExpression A valid path expression (full path) of the file to collect. For files on Windows systems (not including Windows Events), enter the absolute path including the drive letter. Escape special characters and spaces with a backslash (). If you are collecting from Windows using CIFS/SMB, see Prerequisites for Windows Log Collection. Use a single asterisk wildcard [*] for file or folder names. Example:[var/foo/*.log]. Use two asterisks [**]to recurse within directories and subdirectories. Example: [var/*&#47;.log].
         * 
         * @return builder
         * 
         */
        public Builder pathExpression(Output<String> pathExpression) {
            $.pathExpression = pathExpression;
            return this;
        }

        /**
         * @param pathExpression A valid path expression (full path) of the file to collect. For files on Windows systems (not including Windows Events), enter the absolute path including the drive letter. Escape special characters and spaces with a backslash (). If you are collecting from Windows using CIFS/SMB, see Prerequisites for Windows Log Collection. Use a single asterisk wildcard [*] for file or folder names. Example:[var/foo/*.log]. Use two asterisks [**]to recurse within directories and subdirectories. Example: [var/*&#47;.log].
         * 
         * @return builder
         * 
         */
        public Builder pathExpression(String pathExpression) {
            return pathExpression(Output.of(pathExpression));
        }

        public Builder timezone(@Nullable Output<String> timezone) {
            $.timezone = timezone;
            return this;
        }

        public Builder timezone(String timezone) {
            return timezone(Output.of(timezone));
        }

        public Builder useAutolineMatching(@Nullable Output<Boolean> useAutolineMatching) {
            $.useAutolineMatching = useAutolineMatching;
            return this;
        }

        public Builder useAutolineMatching(Boolean useAutolineMatching) {
            return useAutolineMatching(Output.of(useAutolineMatching));
        }

        public LocalFileSourceArgs build() {
            if ($.collectorId == null) {
                throw new MissingRequiredPropertyException("LocalFileSourceArgs", "collectorId");
            }
            if ($.pathExpression == null) {
                throw new MissingRequiredPropertyException("LocalFileSourceArgs", "pathExpression");
            }
            return $;
        }
    }

}
