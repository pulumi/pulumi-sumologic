// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.sumologic;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Export;
import com.pulumi.core.annotations.ResourceType;
import com.pulumi.core.internal.Codegen;
import com.pulumi.sumologic.MonitorArgs;
import com.pulumi.sumologic.Utilities;
import com.pulumi.sumologic.inputs.MonitorState;
import com.pulumi.sumologic.outputs.MonitorNotification;
import com.pulumi.sumologic.outputs.MonitorObjPermission;
import com.pulumi.sumologic.outputs.MonitorQuery;
import com.pulumi.sumologic.outputs.MonitorTrigger;
import com.pulumi.sumologic.outputs.MonitorTriggerConditions;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import javax.annotation.Nullable;

/**
 * Provides the ability to create, read, delete, and update [Monitors](https://help.sumologic.com/?cid=10020).
 * If Fine Grain Permission (FGP) feature is enabled with Monitors Content at one&#39;s Sumo Logic account, one can also set those permission details under this monitor resource. For further details about FGP, please see this [Monitor Permission document](https://help.sumologic.com/Visualizations-and-Alerts/Alerts/Monitors#configure-permissions-for-a-monitor).
 * 
 * ## Example SLO Monitors
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.sumologic.Monitor;
 * import com.pulumi.sumologic.MonitorArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsSloSliConditionArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsSloSliConditionCriticalArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsSloSliConditionWarningArgs;
 * import com.pulumi.sumologic.inputs.MonitorNotificationArgs;
 * import com.pulumi.sumologic.inputs.MonitorNotificationNotificationArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsSloBurnRateConditionArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsSloBurnRateConditionCriticalArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsSloBurnRateConditionWarningArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var tfSloMonitor1 = new Monitor("tfSloMonitor1", MonitorArgs.builder()
 *             .name("SLO SLI monitor")
 *             .type("MonitorsLibraryMonitor")
 *             .isDisabled(false)
 *             .contentType("Monitor")
 *             .monitorType("Slo")
 *             .sloId("0000000000000009")
 *             .evaluationDelay("5m")
 *             .tags(Map.ofEntries(
 *                 Map.entry("team", "monitoring"),
 *                 Map.entry("application", "sumologic")
 *             ))
 *             .triggerConditions(MonitorTriggerConditionsArgs.builder()
 *                 .sloSliCondition(MonitorTriggerConditionsSloSliConditionArgs.builder()
 *                     .critical(MonitorTriggerConditionsSloSliConditionCriticalArgs.builder()
 *                         .sliThreshold(99.5)
 *                         .build())
 *                     .warning(MonitorTriggerConditionsSloSliConditionWarningArgs.builder()
 *                         .sliThreshold(99.9)
 *                         .build())
 *                     .build())
 *                 .build())
 *             .notifications(MonitorNotificationArgs.builder()
 *                 .notification(MonitorNotificationNotificationArgs.builder()
 *                     .connectionType("Email")
 *                     .recipients("abc}{@literal @}{@code example.com")
 *                     .subject("Monitor Alert: }{{{@code TriggerType}}}{@code  on }{{{@code Name}}}{@code ")
 *                     .timeZone("PST")
 *                     .messageBody("Triggered }{{{@code TriggerType}}}{@code  Alert on }{{{@code Name}}}{@code : }{{{@code QueryURL}}}{@code ")
 *                     .build())
 *                 .runForTriggerTypes(                
 *                     "Critical",
 *                     "ResolvedCritical")
 *                 .build())
 *             .playbook("test playbook")
 *             .build());
 * 
 *         var tfSloMonitor2 = new Monitor("tfSloMonitor2", MonitorArgs.builder()
 *             .name("SLO Burn rate monitor")
 *             .type("MonitorsLibraryMonitor")
 *             .isDisabled(false)
 *             .contentType("Monitor")
 *             .monitorType("Slo")
 *             .sloId("0000000000000009")
 *             .evaluationDelay("5m")
 *             .tags(Map.ofEntries(
 *                 Map.entry("team", "monitoring"),
 *                 Map.entry("application", "sumologic")
 *             ))
 *             .triggerConditions(MonitorTriggerConditionsArgs.builder()
 *                 .sloBurnRateCondition(MonitorTriggerConditionsSloBurnRateConditionArgs.builder()
 *                     .critical(MonitorTriggerConditionsSloBurnRateConditionCriticalArgs.builder()
 *                         .burnRates(MonitorTriggerConditionsSloBurnRateConditionCriticalBurnRateArgs.builder()
 *                             .burnRateThreshold(50)
 *                             .timeRange("1d")
 *                             .build())
 *                         .build())
 *                     .warning(MonitorTriggerConditionsSloBurnRateConditionWarningArgs.builder()
 *                         .burnRates(                        
 *                             MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgs.builder()
 *                                 .burnRateThreshold(30)
 *                                 .timeRange("3d")
 *                                 .build(),
 *                             MonitorTriggerConditionsSloBurnRateConditionWarningBurnRateArgs.builder()
 *                                 .burnRateThreshold(20)
 *                                 .timeRange("4d")
 *                                 .build())
 *                         .build())
 *                     .build())
 *                 .build())
 *             .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Example Logs Anomaly Monitor
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.sumologic.Monitor;
 * import com.pulumi.sumologic.MonitorArgs;
 * import com.pulumi.sumologic.inputs.MonitorQueryArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsLogsAnomalyConditionArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerConditionsLogsAnomalyConditionCriticalArgs;
 * import com.pulumi.sumologic.inputs.MonitorNotificationArgs;
 * import com.pulumi.sumologic.inputs.MonitorNotificationNotificationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var tfExampleAnomalyMonitor = new Monitor("tfExampleAnomalyMonitor", MonitorArgs.builder()
 *             .name("Example Anomaly Monitor")
 *             .description("example anomaly monitor")
 *             .type("MonitorsLibraryMonitor")
 *             .monitorType("Logs")
 *             .isDisabled(false)
 *             .queries(MonitorQueryArgs.builder()
 *                 .rowId("A")
 *                 .query("_sourceCategory=api error | timeslice 5m | count by _sourceHost")
 *                 .build())
 *             .triggerConditions(MonitorTriggerConditionsArgs.builder()
 *                 .logsAnomalyCondition(MonitorTriggerConditionsLogsAnomalyConditionArgs.builder()
 *                     .field("_count")
 *                     .anomalyDetectorType("Cluster")
 *                     .critical(MonitorTriggerConditionsLogsAnomalyConditionCriticalArgs.builder()
 *                         .sensitivity(0.4)
 *                         .minAnomalyCount(9)
 *                         .timeRange("-3h")
 *                         .build())
 *                     .build())
 *                 .build())
 *             .notifications(MonitorNotificationArgs.builder()
 *                 .notification(MonitorNotificationNotificationArgs.builder()
 *                     .connectionType("Email")
 *                     .recipients("anomaly}{@literal @}{@code example.com")
 *                     .subject("Monitor Alert: }{{{@code TriggerType}}}{@code  on }{{{@code Name}}}{@code ")
 *                     .timeZone("PST")
 *                     .messageBody("Triggered }{{{@code TriggerType}}}{@code  Alert on }{{{@code Name}}}{@code : }{{{@code QueryURL}}}{@code ")
 *                     .build())
 *                 .runForTriggerTypes(                
 *                     "Critical",
 *                     "ResolvedCritical")
 *                 .build())
 *             .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Monitor Folders
 * 
 * &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD
 * NOTE: Monitor folders are considered a different resource from Library content folders.
 * 
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.sumologic.MonitorFolder;
 * import com.pulumi.sumologic.MonitorFolderArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App {
 *     public static void main(String[] args) {
 *         Pulumi.run(App::stack);
 *     }
 * 
 *     public static void stack(Context ctx) {
 *         var tfMonitorFolder1 = new MonitorFolder("tfMonitorFolder1", MonitorFolderArgs.builder()
 *             .name("test folder")
 *             .description("a folder for monitors")
 *             .build());
 * 
 *     }
 * }
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * =======
 * NOTE: Monitor folders are considered a different resource from Library content folders. See sumologic.MonitorFolder for more details.
 * &gt; &gt; &gt; &gt; &gt; &gt; &gt; v2.11.0
 * 
 * ## The `trigger_conditions` block
 * 
 * A `trigger_conditions` block configures conditions for sending notifications.
 * 
 * ## The `triggers` block
 * 
 * The `triggers` block is deprecated. Please use `trigger_conditions` to specify notification conditions.
 * 
 * Here&#39;s an example logs monitor that uses `triggers` to specify trigger conditions:
 * &lt;!--Start PulumiCodeChooser --&gt;
 * <pre>
 * {@code
 * package generated_program;
 * 
 * import com.pulumi.Context;
 * import com.pulumi.Pulumi;
 * import com.pulumi.core.Output;
 * import com.pulumi.sumologic.Monitor;
 * import com.pulumi.sumologic.MonitorArgs;
 * import com.pulumi.sumologic.inputs.MonitorQueryArgs;
 * import com.pulumi.sumologic.inputs.MonitorTriggerArgs;
 * import com.pulumi.sumologic.inputs.MonitorNotificationArgs;
 * import com.pulumi.sumologic.inputs.MonitorNotificationNotificationArgs;
 * import java.util.List;
 * import java.util.ArrayList;
 * import java.util.Map;
 * import java.io.File;
 * import java.nio.file.Files;
 * import java.nio.file.Paths;
 * 
 * public class App }{{@code
 *     public static void main(String[] args) }{{@code
 *         Pulumi.run(App::stack);
 *     }}{@code
 * 
 *     public static void stack(Context ctx) }{{@code
 *         var tfLogsMonitor1 = new Monitor("tfLogsMonitor1", MonitorArgs.builder()
 *             .name("Terraform Logs Monitor")
 *             .description("tf logs monitor")
 *             .type("MonitorsLibraryMonitor")
 *             .isDisabled(false)
 *             .contentType("Monitor")
 *             .monitorType("Logs")
 *             .queries(MonitorQueryArgs.builder()
 *                 .rowId("A")
 *                 .query("_sourceCategory=event-action info")
 *                 .build())
 *             .triggers(            
 *                 MonitorTriggerArgs.builder()
 *                     .thresholdType("GreaterThan")
 *                     .threshold(40)
 *                     .timeRange("15m")
 *                     .occurrenceType("ResultCount")
 *                     .triggerSource("AllResults")
 *                     .triggerType("Critical")
 *                     .detectionMethod("StaticCondition")
 *                     .build(),
 *                 MonitorTriggerArgs.builder()
 *                     .thresholdType("LessThanOrEqual")
 *                     .threshold(40)
 *                     .timeRange("15m")
 *                     .occurrenceType("ResultCount")
 *                     .triggerSource("AllResults")
 *                     .triggerType("ResolvedCritical")
 *                     .detectionMethod("StaticCondition")
 *                     .resolutionWindow("5m")
 *                     .build())
 *             .notifications(            
 *                 MonitorNotificationArgs.builder()
 *                     .notification(MonitorNotificationNotificationArgs.builder()
 *                         .connectionType("Email")
 *                         .recipients("abc}{@literal @}{@code example.com")
 *                         .subject("Monitor Alert: }{{{@code TriggerType}}}{@code  on }{{{@code Name}}}{@code ")
 *                         .timeZone("PST")
 *                         .messageBody("Triggered }{{{@code TriggerType}}}{@code  Alert on }{{{@code Name}}}{@code : }{{{@code QueryURL}}}{@code ")
 *                         .build())
 *                     .runForTriggerTypes(                    
 *                         "Critical",
 *                         "ResolvedCritical")
 *                     .build(),
 *                 MonitorNotificationArgs.builder()
 *                     .notification(MonitorNotificationNotificationArgs.builder()
 *                         .connectionType("Webhook")
 *                         .connectionId("0000000000ABC123")
 *                         .build())
 *                     .runForTriggerTypes(                    
 *                         "Critical",
 *                         "ResolvedCritical")
 *                     .build())
 *             .build());
 * 
 *     }}{@code
 * }}{@code
 * }
 * </pre>
 * &lt;!--End PulumiCodeChooser --&gt;
 * 
 * ## Import
 * 
 * Monitors can be imported using the monitor ID, such as:
 * 
 * hcl
 * 
 * ```sh
 * $ pulumi import sumologic:index/monitor:Monitor test 1234567890
 * ```
 * 
 */
@ResourceType(type="sumologic:index/monitor:Monitor")
public class Monitor extends com.pulumi.resources.CustomResource {
    /**
     * The display name when creating alerts. Monitor name will be used if `alert_name` is not provided. All template variables can be used in `alert_name` except `{{AlertName}}`, `{{AlertResponseURL}}`, `{{ResultsJson}}`, and `{{Playbook}}`.
     * 
     */
    @Export(name="alertName", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> alertName;

    /**
     * @return The display name when creating alerts. Monitor name will be used if `alert_name` is not provided. All template variables can be used in `alert_name` except `{{AlertName}}`, `{{AlertResponseURL}}`, `{{ResultsJson}}`, and `{{Playbook}}`.
     * 
     */
    public Output<Optional<String>> alertName() {
        return Codegen.optional(this.alertName);
    }
    /**
     * The type of the content object. Valid value:
     * - `Monitor`
     * 
     */
    @Export(name="contentType", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> contentType;

    /**
     * @return The type of the content object. Valid value:
     * - `Monitor`
     * 
     */
    public Output<Optional<String>> contentType() {
        return Codegen.optional(this.contentType);
    }
    @Export(name="createdAt", refs={String.class}, tree="[0]")
    private Output<String> createdAt;

    public Output<String> createdAt() {
        return this.createdAt;
    }
    @Export(name="createdBy", refs={String.class}, tree="[0]")
    private Output<String> createdBy;

    public Output<String> createdBy() {
        return this.createdBy;
    }
    /**
     * The description of the monitor.
     * 
     */
    @Export(name="description", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> description;

    /**
     * @return The description of the monitor.
     * 
     */
    public Output<Optional<String>> description() {
        return Codegen.optional(this.description);
    }
    /**
     * Evaluation delay as a string consists of the following elements:
     * 1. `&lt;number&gt;`: number of time units,
     * 2. `&lt;time_unit&gt;`: time unit; possible values are: `h` (hour), `m` (minute), `s` (second).
     * 
     * Multiple pairs of `&lt;number&gt;&lt;time_unit&gt;` may be provided. For example,
     * `2m50s` means 2 minutes and 50 seconds.
     * 
     */
    @Export(name="evaluationDelay", refs={String.class}, tree="[0]")
    private Output<String> evaluationDelay;

    /**
     * @return Evaluation delay as a string consists of the following elements:
     * 1. `&lt;number&gt;`: number of time units,
     * 2. `&lt;time_unit&gt;`: time unit; possible values are: `h` (hour), `m` (minute), `s` (second).
     * 
     * Multiple pairs of `&lt;number&gt;&lt;time_unit&gt;` may be provided. For example,
     * `2m50s` means 2 minutes and 50 seconds.
     * 
     */
    public Output<String> evaluationDelay() {
        return this.evaluationDelay;
    }
    /**
     * Whether or not to group notifications for individual items that meet the trigger condition. Defaults to true.
     * 
     */
    @Export(name="groupNotifications", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> groupNotifications;

    /**
     * @return Whether or not to group notifications for individual items that meet the trigger condition. Defaults to true.
     * 
     */
    public Output<Optional<Boolean>> groupNotifications() {
        return Codegen.optional(this.groupNotifications);
    }
    /**
     * Whether or not the monitor is disabled. Disabled monitors will not run and will not generate or send notifications.
     * 
     */
    @Export(name="isDisabled", refs={Boolean.class}, tree="[0]")
    private Output</* @Nullable */ Boolean> isDisabled;

    /**
     * @return Whether or not the monitor is disabled. Disabled monitors will not run and will not generate or send notifications.
     * 
     */
    public Output<Optional<Boolean>> isDisabled() {
        return Codegen.optional(this.isDisabled);
    }
    @Export(name="isLocked", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> isLocked;

    public Output<Boolean> isLocked() {
        return this.isLocked;
    }
    @Export(name="isMutable", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> isMutable;

    public Output<Boolean> isMutable() {
        return this.isMutable;
    }
    @Export(name="isSystem", refs={Boolean.class}, tree="[0]")
    private Output<Boolean> isSystem;

    public Output<Boolean> isSystem() {
        return this.isSystem;
    }
    @Export(name="modifiedAt", refs={String.class}, tree="[0]")
    private Output<String> modifiedAt;

    public Output<String> modifiedAt() {
        return this.modifiedAt;
    }
    @Export(name="modifiedBy", refs={String.class}, tree="[0]")
    private Output<String> modifiedBy;

    public Output<String> modifiedBy() {
        return this.modifiedBy;
    }
    /**
     * The type of monitor. Valid values:
     * - `Logs`: A logs query monitor.
     * - `Metrics`: A metrics query monitor.
     * - `Slo`: A SLO based monitor.
     * 
     */
    @Export(name="monitorType", refs={String.class}, tree="[0]")
    private Output<String> monitorType;

    /**
     * @return The type of monitor. Valid values:
     * - `Logs`: A logs query monitor.
     * - `Metrics`: A metrics query monitor.
     * - `Slo`: A SLO based monitor.
     * 
     */
    public Output<String> monitorType() {
        return this.monitorType;
    }
    /**
     * The name of the monitor. The name must be alphanumeric.
     * 
     */
    @Export(name="name", refs={String.class}, tree="[0]")
    private Output<String> name;

    /**
     * @return The name of the monitor. The name must be alphanumeric.
     * 
     */
    public Output<String> name() {
        return this.name;
    }
    /**
     * The set of fields to be used to group alerts and notifications for a monitor. The value of this field will be considered only when &#39;groupNotifications&#39; is true. The fields with very high cardinality such as `_blockid`, `_raw`, `_messagetime`, `_receipttime`, and `_messageid` are not allowed for Alert Grouping.
     * 
     */
    @Export(name="notificationGroupFields", refs={List.class,String.class}, tree="[0,1]")
    private Output</* @Nullable */ List<String>> notificationGroupFields;

    /**
     * @return The set of fields to be used to group alerts and notifications for a monitor. The value of this field will be considered only when &#39;groupNotifications&#39; is true. The fields with very high cardinality such as `_blockid`, `_raw`, `_messagetime`, `_receipttime`, and `_messageid` are not allowed for Alert Grouping.
     * 
     */
    public Output<Optional<List<String>>> notificationGroupFields() {
        return Codegen.optional(this.notificationGroupFields);
    }
    /**
     * The notifications the monitor will send when the respective trigger condition is met.
     * 
     */
    @Export(name="notifications", refs={List.class,MonitorNotification.class}, tree="[0,1]")
    private Output</* @Nullable */ List<MonitorNotification>> notifications;

    /**
     * @return The notifications the monitor will send when the respective trigger condition is met.
     * 
     */
    public Output<Optional<List<MonitorNotification>>> notifications() {
        return Codegen.optional(this.notifications);
    }
    /**
     * `obj_permission` construct represents a Permission Statement associated with this Monitor. A set of `obj_permission` constructs can be specified under a Monitor. An `obj_permission` construct can be used to control permissions Explicitly associated with a Monitor. But, it cannot be used to control permissions Inherited from a Parent / Ancestor. Default FGP would be still set to the Monitor upon creation (e.g. the creating user would have full permission), even if no `obj_permission` construct is specified at a Monitor and the FGP feature is enabled at the account.
     * 
     */
    @Export(name="objPermissions", refs={List.class,MonitorObjPermission.class}, tree="[0,1]")
    private Output</* @Nullable */ List<MonitorObjPermission>> objPermissions;

    /**
     * @return `obj_permission` construct represents a Permission Statement associated with this Monitor. A set of `obj_permission` constructs can be specified under a Monitor. An `obj_permission` construct can be used to control permissions Explicitly associated with a Monitor. But, it cannot be used to control permissions Inherited from a Parent / Ancestor. Default FGP would be still set to the Monitor upon creation (e.g. the creating user would have full permission), even if no `obj_permission` construct is specified at a Monitor and the FGP feature is enabled at the account.
     * 
     */
    public Output<Optional<List<MonitorObjPermission>>> objPermissions() {
        return Codegen.optional(this.objPermissions);
    }
    /**
     * The ID of the Monitor Folder that contains this monitor. Defaults to the root folder.
     * 
     */
    @Export(name="parentId", refs={String.class}, tree="[0]")
    private Output<String> parentId;

    /**
     * @return The ID of the Monitor Folder that contains this monitor. Defaults to the root folder.
     * 
     */
    public Output<String> parentId() {
        return this.parentId;
    }
    /**
     * Notes such as links and instruction to help you resolve alerts triggered by this monitor. {{Markdown}} supported. It will be enabled only if available for your organization. Please contact your Sumo Logic account team to learn more.
     * 
     */
    @Export(name="playbook", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> playbook;

    /**
     * @return Notes such as links and instruction to help you resolve alerts triggered by this monitor. {{Markdown}} supported. It will be enabled only if available for your organization. Please contact your Sumo Logic account team to learn more.
     * 
     */
    public Output<Optional<String>> playbook() {
        return Codegen.optional(this.playbook);
    }
    @Export(name="postRequestMap", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> postRequestMap;

    public Output<Optional<Map<String,String>>> postRequestMap() {
        return Codegen.optional(this.postRequestMap);
    }
    /**
     * All queries from the monitor.
     * 
     */
    @Export(name="queries", refs={List.class,MonitorQuery.class}, tree="[0,1]")
    private Output</* @Nullable */ List<MonitorQuery>> queries;

    /**
     * @return All queries from the monitor.
     * 
     */
    public Output<Optional<List<MonitorQuery>>> queries() {
        return Codegen.optional(this.queries);
    }
    /**
     * Identifier of the SLO definition for the monitor. This is only applicable &amp; required for Slo `monitor_type`.
     * 
     */
    @Export(name="sloId", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> sloId;

    /**
     * @return Identifier of the SLO definition for the monitor. This is only applicable &amp; required for Slo `monitor_type`.
     * 
     */
    public Output<Optional<String>> sloId() {
        return Codegen.optional(this.sloId);
    }
    /**
     * The current status for this monitor. Values are:
     * - `Critical`
     * - `Warning`
     * - `MissingData`
     * - `Normal`
     * - `Disabled`
     * 
     */
    @Export(name="statuses", refs={List.class,String.class}, tree="[0,1]")
    private Output<List<String>> statuses;

    /**
     * @return The current status for this monitor. Values are:
     * - `Critical`
     * - `Warning`
     * - `MissingData`
     * - `Normal`
     * - `Disabled`
     * 
     */
    public Output<List<String>> statuses() {
        return this.statuses;
    }
    /**
     * A map defining tag keys and tag values for the Monitor.
     * 
     */
    @Export(name="tags", refs={Map.class,String.class}, tree="[0,1,1]")
    private Output</* @Nullable */ Map<String,String>> tags;

    /**
     * @return A map defining tag keys and tag values for the Monitor.
     * 
     */
    public Output<Optional<Map<String,String>>> tags() {
        return Codegen.optional(this.tags);
    }
    @Export(name="timeZone", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> timeZone;

    public Output<Optional<String>> timeZone() {
        return Codegen.optional(this.timeZone);
    }
    /**
     * Defines the conditions of when to send notifications. NOTE: `trigger_conditions` supplants the `triggers` argument.
     * 
     */
    @Export(name="triggerConditions", refs={MonitorTriggerConditions.class}, tree="[0]")
    private Output</* @Nullable */ MonitorTriggerConditions> triggerConditions;

    /**
     * @return Defines the conditions of when to send notifications. NOTE: `trigger_conditions` supplants the `triggers` argument.
     * 
     */
    public Output<Optional<MonitorTriggerConditions>> triggerConditions() {
        return Codegen.optional(this.triggerConditions);
    }
    /**
     * Defines the conditions of when to send notifications.
     * 
     * @deprecated
     * The field `triggers` is deprecated and will be removed in a future release of the provider -- please use `trigger_conditions` instead.
     * 
     */
    @Deprecated /* The field `triggers` is deprecated and will be removed in a future release of the provider -- please use `trigger_conditions` instead. */
    @Export(name="triggers", refs={List.class,MonitorTrigger.class}, tree="[0,1]")
    private Output</* @Nullable */ List<MonitorTrigger>> triggers;

    /**
     * @return Defines the conditions of when to send notifications.
     * 
     */
    public Output<Optional<List<MonitorTrigger>>> triggers() {
        return Codegen.optional(this.triggers);
    }
    /**
     * The type of object model. Valid value:
     * - `MonitorsLibraryMonitor`
     * 
     */
    @Export(name="type", refs={String.class}, tree="[0]")
    private Output</* @Nullable */ String> type;

    /**
     * @return The type of object model. Valid value:
     * - `MonitorsLibraryMonitor`
     * 
     */
    public Output<Optional<String>> type() {
        return Codegen.optional(this.type);
    }
    @Export(name="version", refs={Integer.class}, tree="[0]")
    private Output<Integer> version;

    public Output<Integer> version() {
        return this.version;
    }

    /**
     *
     * @param name The _unique_ name of the resulting resource.
     */
    public Monitor(java.lang.String name) {
        this(name, MonitorArgs.Empty);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     */
    public Monitor(java.lang.String name, MonitorArgs args) {
        this(name, args, null);
    }
    /**
     *
     * @param name The _unique_ name of the resulting resource.
     * @param args The arguments to use to populate this resource's properties.
     * @param options A bag of options that control this resource's behavior.
     */
    public Monitor(java.lang.String name, MonitorArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("sumologic:index/monitor:Monitor", name, makeArgs(args, options), makeResourceOptions(options, Codegen.empty()), false);
    }

    private Monitor(java.lang.String name, Output<java.lang.String> id, @Nullable MonitorState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        super("sumologic:index/monitor:Monitor", name, state, makeResourceOptions(options, id), false);
    }

    private static MonitorArgs makeArgs(MonitorArgs args, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        if (options != null && options.getUrn().isPresent()) {
            return null;
        }
        return args == null ? MonitorArgs.Empty : args;
    }

    private static com.pulumi.resources.CustomResourceOptions makeResourceOptions(@Nullable com.pulumi.resources.CustomResourceOptions options, @Nullable Output<java.lang.String> id) {
        var defaultOptions = com.pulumi.resources.CustomResourceOptions.builder()
            .version(Utilities.getVersion())
            .build();
        return com.pulumi.resources.CustomResourceOptions.merge(defaultOptions, options, id);
    }

    /**
     * Get an existing Host resource's state with the given name, ID, and optional extra
     * properties used to qualify the lookup.
     *
     * @param name The _unique_ name of the resulting resource.
     * @param id The _unique_ provider ID of the resource to lookup.
     * @param state
     * @param options Optional settings to control the behavior of the CustomResource.
     */
    public static Monitor get(java.lang.String name, Output<java.lang.String> id, @Nullable MonitorState state, @Nullable com.pulumi.resources.CustomResourceOptions options) {
        return new Monitor(name, id, state, options);
    }
}
